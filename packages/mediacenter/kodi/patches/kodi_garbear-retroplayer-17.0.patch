diff --git a/.gitignore b/.gitignore
index 3c651af..9b3251f 100644
--- a/.gitignore
+++ b/.gitignore
@@ -125,6 +125,7 @@ cmake_install.cmake
 /addons/pvr.*
 /addons/adsp.*
 /addons/peripheral.*
+/addons/game.*
 /addons/xbmc.addon/addon.xml
 /addons/xbmc.json/addon.xml
 /addons/kodi.guilib/addon.xml
@@ -144,6 +145,7 @@ cmake_install.cmake
 /lib/addons/library.xbmc.pvr/Makefile
 /lib/addons/library.xbmc.codec/Makefile
 /lib/addons/library.kodi.peripheral/Makefile
+/lib/addons/library.kodi.game/Makefile
 /lib/addons/library.xbmc.addon/project/VS2010Express/Release
 /lib/addons/library.xbmc.addon/project/VS2010Express/Debug
 /lib/addons/library.kodi.adsp/project/VS2010Express/Release
@@ -157,6 +159,8 @@ cmake_install.cmake
 /lib/addons/library.kodi.audioengine/project/VS2010Express/Debug/
 /lib/addons/library.kodi.peripheral/project/VS2010Express/Release
 /lib/addons/library.kodi.peripheral/project/VS2010Express/Debug
+/lib/addons/library.kodi.game/project/VS2010Express/Release
+/lib/addons/library.kodi.game/project/VS2010Express/Debug
 
 # /lib/cpluff/
 /lib/cpluff/ABOUT-NLS
@@ -549,8 +553,3 @@ lib/cpluff/stamp-h1
 
 # Doxygen generated files
 /docs/html
-system/libmysql.dll
-system/python27.dll
-system/zlib.dll
-lib/addons/library.kodi.inputstream/project/VS2010Express/Debug
-lib/addons/library.kodi.inputstream/project/VS2010Express/Release
diff --git a/.travis.yml b/.travis.yml
index 8380864..233251f 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -69,7 +69,7 @@ install:
 # Linux dependencies
 #
   - if [[ "$TRAVIS_OS_NAME" == "linux" && "$BUILD" == "Kodi" ]]; then
-      sudo apt-get install -qq automake autopoint build-essential cmake curl default-jre gawk gdb gdc
+      sudo apt-get install -qq automake autopoint build-essential cmake curl dcadec-dev default-jre gawk gdb gdc
       gettext git-core gperf libasound2-dev libass-dev libbz2-dev libcap-dev libcdio-dev libcrossguid-dev libcurl3
       libcurl4-openssl-dev libdbus-1-dev libfontconfig-dev libegl1-mesa-dev libfreetype6-dev libfribidi-dev libgif-dev
       libiso9660-dev libjpeg-dev libltdl-dev liblzo2-dev libmicrohttpd-dev libmodplug-dev libmysqlclient-dev libnfs-dev
diff --git a/Kodi.xcodeproj/project.pbxproj b/Kodi.xcodeproj/project.pbxproj
index 06d63bd..d89762a 100644
--- a/Kodi.xcodeproj/project.pbxproj
+++ b/Kodi.xcodeproj/project.pbxproj
@@ -253,6 +253,46 @@
 		5EB3113C1A978B9B00551907 /* CueInfoLoader.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 5EB3113A1A978B9B00551907 /* CueInfoLoader.cpp */; };
 		5EE4F9181A9FF36F002E20F8 /* CueInfoLoader.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 5EB3113A1A978B9B00551907 /* CueInfoLoader.cpp */; };
 		5EF801001A97892A0035AA4D /* ReplayGain.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 5EF800FE1A97892A0035AA4D /* ReplayGain.cpp */; };
+		680659601C98BFB400811653 /* AddonCallbacksGame.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 6806595E1C98BFB400811653 /* AddonCallbacksGame.cpp */; };
+		680659611C98BFB400811653 /* AddonCallbacksGame.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 6806595E1C98BFB400811653 /* AddonCallbacksGame.cpp */; };
+		6806596E1C98C02900811653 /* GameClient.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 680659681C98C02900811653 /* GameClient.cpp */; };
+		6806596F1C98C02900811653 /* GameClient.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 680659681C98C02900811653 /* GameClient.cpp */; };
+		680659701C98C02900811653 /* GameClientInput.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 6806596A1C98C02900811653 /* GameClientInput.cpp */; };
+		680659711C98C02900811653 /* GameClientInput.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 6806596A1C98C02900811653 /* GameClientInput.cpp */; };
+		680659721C98C02900811653 /* GameClientProperties.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 6806596C1C98C02900811653 /* GameClientProperties.cpp */; };
+		680659731C98C02900811653 /* GameClientProperties.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 6806596C1C98C02900811653 /* GameClientProperties.cpp */; };
+		6806597D1C98C04200811653 /* GameFileAutoLauncher.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 680659741C98C04200811653 /* GameFileAutoLauncher.cpp */; };
+		6806597E1C98C04200811653 /* GameFileAutoLauncher.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 680659741C98C04200811653 /* GameFileAutoLauncher.cpp */; };
+		6806597F1C98C04200811653 /* GameManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 680659761C98C04200811653 /* GameManager.cpp */; };
+		680659801C98C04200811653 /* GameManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 680659761C98C04200811653 /* GameManager.cpp */; };
+		680659811C98C04200811653 /* GameSettings.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 680659781C98C04200811653 /* GameSettings.cpp */; };
+		680659821C98C04200811653 /* GameSettings.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 680659781C98C04200811653 /* GameSettings.cpp */; };
+		680659831C98C04200811653 /* SerialState.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 6806597B1C98C04200811653 /* SerialState.cpp */; };
+		680659841C98C04200811653 /* SerialState.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 6806597B1C98C04200811653 /* SerialState.cpp */; };
+		680659881C98C05700811653 /* GameInfoTag.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 680659861C98C05700811653 /* GameInfoTag.cpp */; };
+		680659891C98C05700811653 /* GameInfoTag.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 680659861C98C05700811653 /* GameInfoTag.cpp */; };
+		6806598E1C98C06600811653 /* GUIViewStateWindowGames.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 6806598A1C98C06600811653 /* GUIViewStateWindowGames.cpp */; };
+		6806598F1C98C06600811653 /* GUIViewStateWindowGames.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 6806598A1C98C06600811653 /* GUIViewStateWindowGames.cpp */; };
+		680659901C98C06600811653 /* GUIWindowGames.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 6806598C1C98C06600811653 /* GUIWindowGames.cpp */; };
+		680659911C98C06600811653 /* GUIWindowGames.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 6806598C1C98C06600811653 /* GUIWindowGames.cpp */; };
+		680659961C98C07500811653 /* PortManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 680659921C98C07500811653 /* PortManager.cpp */; };
+		680659971C98C07500811653 /* PortManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 680659921C98C07500811653 /* PortManager.cpp */; };
+		680659981C98C07500811653 /* PortMapper.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 680659941C98C07500811653 /* PortMapper.cpp */; };
+		680659991C98C07500811653 /* PortMapper.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 680659941C98C07500811653 /* PortMapper.cpp */; };
+		6806599C1C98C0C200811653 /* InputStreamGame.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 6806599A1C98C0C200811653 /* InputStreamGame.cpp */; };
+		6806599D1C98C0C200811653 /* InputStreamGame.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 6806599A1C98C0C200811653 /* InputStreamGame.cpp */; };
+		680659A01C98C0E500811653 /* PixelConverter.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 6806599E1C98C0E500811653 /* PixelConverter.cpp */; };
+		680659A11C98C0E500811653 /* PixelConverter.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 6806599E1C98C0E500811653 /* PixelConverter.cpp */; };
+		680659A91C98C13900811653 /* GenericKeyboardJoystick.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 680659A51C98C13900811653 /* GenericKeyboardJoystick.cpp */; };
+		680659AA1C98C13900811653 /* GenericKeyboardJoystick.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 680659A51C98C13900811653 /* GenericKeyboardJoystick.cpp */; };
+		680659AB1C98C13900811653 /* GenericKeyboardJoystickHandling.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 680659A71C98C13900811653 /* GenericKeyboardJoystickHandling.cpp */; };
+		680659AC1C98C13900811653 /* GenericKeyboardJoystickHandling.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 680659A71C98C13900811653 /* GenericKeyboardJoystickHandling.cpp */; };
+		680659AF1C98C15800811653 /* PeripheralBusApplication.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 680659AD1C98C15800811653 /* PeripheralBusApplication.cpp */; };
+		680659B01C98C15800811653 /* PeripheralBusApplication.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 680659AD1C98C15800811653 /* PeripheralBusApplication.cpp */; };
+		680659B31C98C16C00811653 /* PeripheralJoystickEmulation.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 680659B11C98C16C00811653 /* PeripheralJoystickEmulation.cpp */; };
+		680659B41C98C16C00811653 /* PeripheralJoystickEmulation.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 680659B11C98C16C00811653 /* PeripheralJoystickEmulation.cpp */; };
+		680659B71C98C19F00811653 /* DVDDemuxGame.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 680659B51C98C19F00811653 /* DVDDemuxGame.cpp */; };
+		680659B81C98C19F00811653 /* DVDDemuxGame.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 680659B51C98C19F00811653 /* DVDDemuxGame.cpp */; };
 		68AE5BA51C92412900C4D527 /* AddonCallbacksPeripheral.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 68AE5BA31C92412900C4D527 /* AddonCallbacksPeripheral.cpp */; };
 		68AE5BA61C92412900C4D527 /* AddonCallbacksPeripheral.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 68AE5BA31C92412900C4D527 /* AddonCallbacksPeripheral.cpp */; };
 		68AE5BBD1C9241DF00C4D527 /* DefaultJoystick.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 68AE5BAC1C9241DF00C4D527 /* DefaultJoystick.cpp */; };
@@ -793,6 +833,7 @@
 		DF02BA621A910623006DCA16 /* VideoSyncIos.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DF02BA601A910623006DCA16 /* VideoSyncIos.cpp */; };
 		DF02BA661A91065F006DCA16 /* VideoSyncOsx.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DF02BA641A91065F006DCA16 /* VideoSyncOsx.cpp */; };
 		DF033D381946612400BFC82E /* AEDeviceEnumerationOSX.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DF033D361946612400BFC82E /* AEDeviceEnumerationOSX.cpp */; };
+		DF072534168734ED008DCAAD /* FFmpegVideoDecoder.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DF072532168734ED008DCAAD /* FFmpegVideoDecoder.cpp */; };
 		DF0ABB73183A94A30018445D /* Utf8Utils.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DF0ABB71183A94A30018445D /* Utf8Utils.cpp */; };
 		DF0ABB74183A94A30018445D /* Utf8Utils.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DF0ABB71183A94A30018445D /* Utf8Utils.cpp */; };
 		DF0DF15C13A3ADA7008ED511 /* NFSDirectory.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DF0DF15913A3ADA7008ED511 /* NFSDirectory.cpp */; };
@@ -1023,6 +1064,7 @@
 		DFD717601C0A031B0025D964 /* IOSScreenManager.mm in Sources */ = {isa = PBXBuildFile; fileRef = DFD7174F1C0A031B0025D964 /* IOSScreenManager.mm */; };
 		DFD717611C0A031B0025D964 /* XBMCApplication.m in Sources */ = {isa = PBXBuildFile; fileRef = DFD717511C0A031B0025D964 /* XBMCApplication.m */; };
 		DFD717621C0A031B0025D964 /* XBMCController.mm in Sources */ = {isa = PBXBuildFile; fileRef = DFD717531C0A031B0025D964 /* XBMCController.mm */; };
+		DFD717641C0A03540025D964 /* Info.plist in Resources */ = {isa = PBXBuildFile; fileRef = DFD717631C0A03540025D964 /* Info.plist */; };
 		DFD882E817DD189E001516FE /* StringValidation.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DFD882E517DD189E001516FE /* StringValidation.cpp */; };
 		DFD882E917DD189E001516FE /* StringValidation.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DFD882E517DD189E001516FE /* StringValidation.cpp */; };
 		DFD882F717DD1A5B001516FE /* AddonPythonInvoker.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DFD882F417DD1A5B001516FE /* AddonPythonInvoker.cpp */; };
@@ -2059,6 +2101,7 @@
 		E499148E174E606500741B6D /* GUIWindowVideoNav.cpp in Sources */ = {isa = PBXBuildFile; fileRef = E38E18410D25F9FA00618676 /* GUIWindowVideoNav.cpp */; };
 		E499148F174E606600741B6D /* GUIWindowVideoPlaylist.cpp in Sources */ = {isa = PBXBuildFile; fileRef = E38E18450D25F9FA00618676 /* GUIWindowVideoPlaylist.cpp */; };
 		E4991490174E606600741B6D /* Bookmark.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 7C62F24010505BC7002AD2C1 /* Bookmark.cpp */; };
+		E4991491174E606600741B6D /* FFmpegVideoDecoder.cpp in Sources */ = {isa = PBXBuildFile; fileRef = DF072532168734ED008DCAAD /* FFmpegVideoDecoder.cpp */; };
 		E4991492174E606600741B6D /* GUIViewStateVideo.cpp in Sources */ = {isa = PBXBuildFile; fileRef = E38E17FF0D25F9FA00618676 /* GUIViewStateVideo.cpp */; };
 		E4991493174E606600741B6D /* PlayerController.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 7C87B2CC162CE39600EF897D /* PlayerController.cpp */; };
 		E4991494174E606600741B6D /* Teletext.cpp in Sources */ = {isa = PBXBuildFile; fileRef = F5E55B6E10741340006E788A /* Teletext.cpp */; };
@@ -2737,6 +2780,51 @@
 		5EB3113B1A978B9B00551907 /* CueInfoLoader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CueInfoLoader.h; sourceTree = "<group>"; };
 		5EF800FE1A97892A0035AA4D /* ReplayGain.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ReplayGain.cpp; sourceTree = "<group>"; };
 		5EF800FF1A97892A0035AA4D /* ReplayGain.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ReplayGain.h; sourceTree = "<group>"; };
+		6806595E1C98BFB400811653 /* AddonCallbacksGame.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = AddonCallbacksGame.cpp; path = addons/binary/interfaces/api1/Game/AddonCallbacksGame.cpp; sourceTree = "<group>"; };
+		6806595F1C98BFB400811653 /* AddonCallbacksGame.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AddonCallbacksGame.h; path = addons/binary/interfaces/api1/Game/AddonCallbacksGame.h; sourceTree = "<group>"; };
+		680659621C98BFDB00811653 /* kodi_game_callbacks.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = kodi_game_callbacks.h; path = "kodi-addon-dev-kit/include/kodi/kodi_game_callbacks.h"; sourceTree = "<group>"; };
+		680659631C98BFDB00811653 /* kodi_game_dll.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = kodi_game_dll.h; path = "kodi-addon-dev-kit/include/kodi/kodi_game_dll.h"; sourceTree = "<group>"; };
+		680659641C98BFDB00811653 /* kodi_game_types.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = kodi_game_types.h; path = "kodi-addon-dev-kit/include/kodi/kodi_game_types.h"; sourceTree = "<group>"; };
+		680659681C98C02900811653 /* GameClient.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameClient.cpp; path = games/addons/GameClient.cpp; sourceTree = "<group>"; };
+		680659691C98C02900811653 /* GameClient.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameClient.h; path = games/addons/GameClient.h; sourceTree = "<group>"; };
+		6806596A1C98C02900811653 /* GameClientInput.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameClientInput.cpp; path = games/addons/GameClientInput.cpp; sourceTree = "<group>"; };
+		6806596B1C98C02900811653 /* GameClientInput.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameClientInput.h; path = games/addons/GameClientInput.h; sourceTree = "<group>"; };
+		6806596C1C98C02900811653 /* GameClientProperties.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameClientProperties.cpp; path = games/addons/GameClientProperties.cpp; sourceTree = "<group>"; };
+		6806596D1C98C02900811653 /* GameClientProperties.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameClientProperties.h; path = games/addons/GameClientProperties.h; sourceTree = "<group>"; };
+		680659741C98C04200811653 /* GameFileAutoLauncher.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameFileAutoLauncher.cpp; path = games/GameFileAutoLauncher.cpp; sourceTree = "<group>"; };
+		680659751C98C04200811653 /* GameFileAutoLauncher.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameFileAutoLauncher.h; path = games/GameFileAutoLauncher.h; sourceTree = "<group>"; };
+		680659761C98C04200811653 /* GameManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameManager.cpp; path = games/GameManager.cpp; sourceTree = "<group>"; };
+		680659771C98C04200811653 /* GameManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameManager.h; path = games/GameManager.h; sourceTree = "<group>"; };
+		680659781C98C04200811653 /* GameSettings.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameSettings.cpp; path = games/GameSettings.cpp; sourceTree = "<group>"; };
+		680659791C98C04200811653 /* GameSettings.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameSettings.h; path = games/GameSettings.h; sourceTree = "<group>"; };
+		6806597A1C98C04200811653 /* GameTypes.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameTypes.h; path = games/GameTypes.h; sourceTree = "<group>"; };
+		6806597B1C98C04200811653 /* SerialState.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SerialState.cpp; path = games/SerialState.cpp; sourceTree = "<group>"; };
+		6806597C1C98C04200811653 /* SerialState.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SerialState.h; path = games/SerialState.h; sourceTree = "<group>"; };
+		680659861C98C05700811653 /* GameInfoTag.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameInfoTag.cpp; path = games/tags/GameInfoTag.cpp; sourceTree = "<group>"; };
+		680659871C98C05700811653 /* GameInfoTag.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameInfoTag.h; path = games/tags/GameInfoTag.h; sourceTree = "<group>"; };
+		6806598A1C98C06600811653 /* GUIViewStateWindowGames.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GUIViewStateWindowGames.cpp; path = games/windows/GUIViewStateWindowGames.cpp; sourceTree = "<group>"; };
+		6806598B1C98C06600811653 /* GUIViewStateWindowGames.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GUIViewStateWindowGames.h; path = games/windows/GUIViewStateWindowGames.h; sourceTree = "<group>"; };
+		6806598C1C98C06600811653 /* GUIWindowGames.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GUIWindowGames.cpp; path = games/windows/GUIWindowGames.cpp; sourceTree = "<group>"; };
+		6806598D1C98C06600811653 /* GUIWindowGames.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GUIWindowGames.h; path = games/windows/GUIWindowGames.h; sourceTree = "<group>"; };
+		680659921C98C07500811653 /* PortManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PortManager.cpp; path = games/ports/PortManager.cpp; sourceTree = "<group>"; };
+		680659931C98C07500811653 /* PortManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PortManager.h; path = games/ports/PortManager.h; sourceTree = "<group>"; };
+		680659941C98C07500811653 /* PortMapper.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PortMapper.cpp; path = games/ports/PortMapper.cpp; sourceTree = "<group>"; };
+		680659951C98C07500811653 /* PortMapper.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PortMapper.h; path = games/ports/PortMapper.h; sourceTree = "<group>"; };
+		6806599A1C98C0C200811653 /* InputStreamGame.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = InputStreamGame.cpp; sourceTree = "<group>"; };
+		6806599B1C98C0C200811653 /* InputStreamGame.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = InputStreamGame.h; sourceTree = "<group>"; };
+		6806599E1C98C0E500811653 /* PixelConverter.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PixelConverter.cpp; sourceTree = "<group>"; };
+		6806599F1C98C0E500811653 /* PixelConverter.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PixelConverter.h; sourceTree = "<group>"; };
+		680659A31C98C12800811653 /* IKeyboardHandler.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = IKeyboardHandler.h; path = keyboard/IKeyboardHandler.h; sourceTree = "<group>"; };
+		680659A51C98C13900811653 /* GenericKeyboardJoystick.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GenericKeyboardJoystick.cpp; path = keyboard/generic/GenericKeyboardJoystick.cpp; sourceTree = "<group>"; };
+		680659A61C98C13900811653 /* GenericKeyboardJoystick.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GenericKeyboardJoystick.h; path = keyboard/generic/GenericKeyboardJoystick.h; sourceTree = "<group>"; };
+		680659A71C98C13900811653 /* GenericKeyboardJoystickHandling.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GenericKeyboardJoystickHandling.cpp; path = keyboard/generic/GenericKeyboardJoystickHandling.cpp; sourceTree = "<group>"; };
+		680659A81C98C13900811653 /* GenericKeyboardJoystickHandling.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GenericKeyboardJoystickHandling.h; path = keyboard/generic/GenericKeyboardJoystickHandling.h; sourceTree = "<group>"; };
+		680659AD1C98C15800811653 /* PeripheralBusApplication.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PeripheralBusApplication.cpp; sourceTree = "<group>"; };
+		680659AE1C98C15800811653 /* PeripheralBusApplication.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PeripheralBusApplication.h; sourceTree = "<group>"; };
+		680659B11C98C16C00811653 /* PeripheralJoystickEmulation.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PeripheralJoystickEmulation.cpp; sourceTree = "<group>"; };
+		680659B21C98C16C00811653 /* PeripheralJoystickEmulation.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PeripheralJoystickEmulation.h; sourceTree = "<group>"; };
+		680659B51C98C19F00811653 /* DVDDemuxGame.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = DVDDemuxGame.cpp; sourceTree = "<group>"; };
+		680659B61C98C19F00811653 /* DVDDemuxGame.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DVDDemuxGame.h; sourceTree = "<group>"; };
 		68AE5BA01C923E5300C4D527 /* kodi_vfs_utils.hpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.h; name = kodi_vfs_utils.hpp; path = "kodi-addon-dev-kit/include/kodi/kodi_vfs_utils.hpp"; sourceTree = "<group>"; };
 		68AE5BA31C92412900C4D527 /* AddonCallbacksPeripheral.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = AddonCallbacksPeripheral.cpp; path = addons/binary/interfaces/api1/Peripheral/AddonCallbacksPeripheral.cpp; sourceTree = "<group>"; };
 		68AE5BA41C92412900C4D527 /* AddonCallbacksPeripheral.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AddonCallbacksPeripheral.h; path = addons/binary/interfaces/api1/Peripheral/AddonCallbacksPeripheral.h; sourceTree = "<group>"; };
@@ -3580,6 +3668,8 @@
 		DF02BA651A91065F006DCA16 /* VideoSyncOsx.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = VideoSyncOsx.h; path = videosync/VideoSyncOsx.h; sourceTree = "<group>"; };
 		DF033D361946612400BFC82E /* AEDeviceEnumerationOSX.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = AEDeviceEnumerationOSX.cpp; path = Sinks/osx/AEDeviceEnumerationOSX.cpp; sourceTree = "<group>"; };
 		DF033D371946612400BFC82E /* AEDeviceEnumerationOSX.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AEDeviceEnumerationOSX.h; path = Sinks/osx/AEDeviceEnumerationOSX.h; sourceTree = "<group>"; };
+		DF072532168734ED008DCAAD /* FFmpegVideoDecoder.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = FFmpegVideoDecoder.cpp; sourceTree = "<group>"; };
+		DF072533168734ED008DCAAD /* FFmpegVideoDecoder.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = FFmpegVideoDecoder.h; sourceTree = "<group>"; };
 		DF0ABB71183A94A30018445D /* Utf8Utils.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Utf8Utils.cpp; sourceTree = "<group>"; };
 		DF0ABB72183A94A30018445D /* Utf8Utils.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Utf8Utils.h; sourceTree = "<group>"; };
 		DF0DF15913A3ADA7008ED511 /* NFSDirectory.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = NFSDirectory.cpp; sourceTree = "<group>"; };
@@ -5428,6 +5518,7 @@
 			isa = PBXGroup;
 			children = (
 				68AE5BAB1C92419500C4D527 /* joysticks */,
+				680659A21C98C11000811653 /* keyboard */,
 				E4991332174E5E5C00741B6D /* touch */,
 				18B7C8CB12942546009E7A26 /* ButtonTranslator.cpp */,
 				18B7C8CC12942546009E7A26 /* ButtonTranslator.h */,
@@ -5507,6 +5598,8 @@
 			children = (
 				68AE5BE91C92422C00C4D527 /* PeripheralBusAddon.cpp */,
 				68AE5BEA1C92422C00C4D527 /* PeripheralBusAddon.h */,
+				680659AD1C98C15800811653 /* PeripheralBusApplication.cpp */,
+				680659AE1C98C15800811653 /* PeripheralBusApplication.h */,
 				1DAFDB7A16DFDCA7007F8C68 /* PeripheralBusCEC.cpp */,
 				1DAFDB7B16DFDCA7007F8C68 /* PeripheralBusCEC.h */,
 			);
@@ -5954,6 +6047,8 @@
 				43FAC88812D6364800F67914 /* windows */,
 				7C62F24010505BC7002AD2C1 /* Bookmark.cpp */,
 				7C62F24110505BC7002AD2C1 /* Bookmark.h */,
+				DF072532168734ED008DCAAD /* FFmpegVideoDecoder.cpp */,
+				DF072533168734ED008DCAAD /* FFmpegVideoDecoder.h */,
 				E38E17FF0D25F9FA00618676 /* GUIViewStateVideo.cpp */,
 				E38E18000D25F9FA00618676 /* GUIViewStateVideo.h */,
 				7C87B2CC162CE39600EF897D /* PlayerController.cpp */,
@@ -6083,6 +6178,79 @@
 			path = osx;
 			sourceTree = "<group>";
 		};
+		6806595D1C98BF8600811653 /* Game */ = {
+			isa = PBXGroup;
+			children = (
+				6806595E1C98BFB400811653 /* AddonCallbacksGame.cpp */,
+				6806595F1C98BFB400811653 /* AddonCallbacksGame.h */,
+			);
+			name = Game;
+			sourceTree = "<group>";
+		};
+		680659651C98BFF600811653 /* addons */ = {
+			isa = PBXGroup;
+			children = (
+				680659681C98C02900811653 /* GameClient.cpp */,
+				680659691C98C02900811653 /* GameClient.h */,
+				6806596A1C98C02900811653 /* GameClientInput.cpp */,
+				6806596B1C98C02900811653 /* GameClientInput.h */,
+				6806596C1C98C02900811653 /* GameClientProperties.cpp */,
+				6806596D1C98C02900811653 /* GameClientProperties.h */,
+			);
+			name = addons;
+			sourceTree = "<group>";
+		};
+		680659661C98C00300811653 /* ports */ = {
+			isa = PBXGroup;
+			children = (
+				680659921C98C07500811653 /* PortManager.cpp */,
+				680659931C98C07500811653 /* PortManager.h */,
+				680659941C98C07500811653 /* PortMapper.cpp */,
+				680659951C98C07500811653 /* PortMapper.h */,
+			);
+			name = ports;
+			sourceTree = "<group>";
+		};
+		680659671C98C00900811653 /* windows */ = {
+			isa = PBXGroup;
+			children = (
+				6806598A1C98C06600811653 /* GUIViewStateWindowGames.cpp */,
+				6806598B1C98C06600811653 /* GUIViewStateWindowGames.h */,
+				6806598C1C98C06600811653 /* GUIWindowGames.cpp */,
+				6806598D1C98C06600811653 /* GUIWindowGames.h */,
+			);
+			name = windows;
+			sourceTree = "<group>";
+		};
+		680659851C98C04A00811653 /* tags */ = {
+			isa = PBXGroup;
+			children = (
+				680659861C98C05700811653 /* GameInfoTag.cpp */,
+				680659871C98C05700811653 /* GameInfoTag.h */,
+			);
+			name = tags;
+			sourceTree = "<group>";
+		};
+		680659A21C98C11000811653 /* keyboard */ = {
+			isa = PBXGroup;
+			children = (
+				680659A41C98C12A00811653 /* generic */,
+				680659A31C98C12800811653 /* IKeyboardHandler.h */,
+			);
+			name = keyboard;
+			sourceTree = "<group>";
+		};
+		680659A41C98C12A00811653 /* generic */ = {
+			isa = PBXGroup;
+			children = (
+				680659A51C98C13900811653 /* GenericKeyboardJoystick.cpp */,
+				680659A61C98C13900811653 /* GenericKeyboardJoystick.h */,
+				680659A71C98C13900811653 /* GenericKeyboardJoystickHandling.cpp */,
+				680659A81C98C13900811653 /* GenericKeyboardJoystickHandling.h */,
+			);
+			name = generic;
+			sourceTree = "<group>";
+		};
 		68AE5BA21C92410300C4D527 /* Peripheral */ = {
 			isa = PBXGroup;
 			children = (
@@ -6150,7 +6318,20 @@
 		68AE5BF91C92431F00C4D527 /* games */ = {
 			isa = PBXGroup;
 			children = (
+				680659651C98BFF600811653 /* addons */,
 				68AE5BFA1C92433900C4D527 /* controllers */,
+				680659661C98C00300811653 /* ports */,
+				680659851C98C04A00811653 /* tags */,
+				680659671C98C00900811653 /* windows */,
+				680659741C98C04200811653 /* GameFileAutoLauncher.cpp */,
+				680659751C98C04200811653 /* GameFileAutoLauncher.h */,
+				680659761C98C04200811653 /* GameManager.cpp */,
+				680659771C98C04200811653 /* GameManager.h */,
+				680659781C98C04200811653 /* GameSettings.cpp */,
+				680659791C98C04200811653 /* GameSettings.h */,
+				6806597A1C98C04200811653 /* GameTypes.h */,
+				6806597B1C98C04200811653 /* SerialState.cpp */,
+				6806597C1C98C04200811653 /* SerialState.h */,
 			);
 			name = games;
 			sourceTree = "<group>";
@@ -7980,6 +8161,8 @@
 				E4991590174E6ABE00741B6D /* DVDVideoCodecVideoToolBox.h */,
 				E38E15410D25F9F900618676 /* DVDVideoPPFFmpeg.cpp */,
 				E38E15420D25F9F900618676 /* DVDVideoPPFFmpeg.h */,
+				6806599E1C98C0E500811653 /* PixelConverter.cpp */,
+				6806599F1C98C0E500811653 /* PixelConverter.h */,
 				551C3A43175A12010051AAAD /* VDA.cpp */,
 				551C3A44175A12010051AAAD /* VDA.h */,
 			);
@@ -7989,11 +8172,8 @@
 		E38E15480D25F9F900618676 /* DVDDemuxers */ = {
 			isa = PBXGroup;
 			children = (
-				7CA220061C921F74000FA3CD /* DemuxMultiSource.h */,
 				7CA220051C921F74000FA3CD /* DemuxMultiSource.cpp */,
-				7C4CED9F1C5E681E00BAD6CE /* DVDDemuxPacket.h */,
-				7CFC08361C5BA7D0000E5E73 /* DVDDemuxClient.cpp */,
-				7CFC08371C5BA7D0000E5E73 /* DVDDemuxClient.h */,
+				7CA220061C921F74000FA3CD /* DemuxMultiSource.h */,
 				E38E15490D25F9F900618676 /* DVDDemux.cpp */,
 				E38E154A0D25F9F900618676 /* DVDDemux.h */,
 				AE89ACA41621DAB800E17DBC /* DVDDemuxBXA.cpp */,
@@ -8002,8 +8182,13 @@
 				DF4BF01C1A4EF3410053AC56 /* DVDDemuxCC.h */,
 				DF52566B1732C1890094A464 /* DVDDemuxCDDA.cpp */,
 				DF52566C1732C1890094A464 /* DVDDemuxCDDA.h */,
+				7CFC08361C5BA7D0000E5E73 /* DVDDemuxClient.cpp */,
+				7CFC08371C5BA7D0000E5E73 /* DVDDemuxClient.h */,
 				E38E25C20D263DE200618676 /* DVDDemuxFFmpeg.cpp */,
 				E38E154C0D25F9F900618676 /* DVDDemuxFFmpeg.h */,
+				680659B51C98C19F00811653 /* DVDDemuxGame.cpp */,
+				680659B61C98C19F00811653 /* DVDDemuxGame.h */,
+				7C4CED9F1C5E681E00BAD6CE /* DVDDemuxPacket.h */,
 				E38E154F0D25F9F900618676 /* DVDDemuxUtils.cpp */,
 				E38E15500D25F9F900618676 /* DVDDemuxUtils.h */,
 				E33206370D5070AA00435CE3 /* DVDDemuxVobsub.cpp */,
@@ -8015,8 +8200,6 @@
 		E38E15570D25F9FA00618676 /* DVDInputStreams */ = {
 			isa = PBXGroup;
 			children = (
-				7C4B64A51C86F712000E1F74 /* InputStreamAddon.cpp */,
-				7C4B64A61C86F712000E1F74 /* InputStreamAddon.h */,
 				E38E15670D25F9FA00618676 /* dvdnav */,
 				E38E15580D25F9FA00618676 /* DllDvdNav.h */,
 				E38E15590D25F9FA00618676 /* DVDFactoryInputStream.cpp */,
@@ -8039,6 +8222,10 @@
 				815EE6340E17F1DC009FBE3C /* DVDInputStreamRTMP.h */,
 				E38E15740D25F9FA00618676 /* DVDStateSerializer.cpp */,
 				E38E15750D25F9FA00618676 /* DVDStateSerializer.h */,
+				7C4B64A51C86F712000E1F74 /* InputStreamAddon.cpp */,
+				7C4B64A61C86F712000E1F74 /* InputStreamAddon.h */,
+				6806599A1C98C0C200811653 /* InputStreamGame.cpp */,
+				6806599B1C98C0C200811653 /* InputStreamGame.h */,
 				80204F0F1C91CD3600E8C88B /* InputStreamMultiSource.cpp */,
 				80204F101C91CD3600E8C88B /* InputStreamMultiSource.h */,
 				80204F111C91CD3600E8C88B /* InputStreamMultiStreams.h */,
@@ -8988,6 +9175,9 @@
 				EDE8C70F1C7F618500A86ECC /* kodi_audiodec_dll.h */,
 				EDE8C7101C7F618500A86ECC /* kodi_audiodec_types.h */,
 				EDE8C7111C7F618500A86ECC /* kodi_audioengine_types.h */,
+				680659621C98BFDB00811653 /* kodi_game_callbacks.h */,
+				680659631C98BFDB00811653 /* kodi_game_dll.h */,
+				680659641C98BFDB00811653 /* kodi_game_types.h */,
 				7CEE107B1C970BB800E0D426 /* kodi_inputstream_dll.h */,
 				7CEE107C1C970BB800E0D426 /* kodi_inputstream_types.h */,
 				68AE5BA71C92414B00C4D527 /* kodi_peripheral_callbacks.h */,
@@ -9047,6 +9237,7 @@
 				EDED2E851C878D3F000F5E80 /* AudioDSP */,
 				EDED2E831C878D04000F5E80 /* AudioEngine */,
 				EDED2E821C878CF6000F5E80 /* Codec */,
+				6806595D1C98BF8600811653 /* Game */,
 				EDED2E801C878CB4000F5E80 /* GUI */,
 				76F4C37B1C8E927A00A1E64B /* InputStream */,
 				68AE5BA21C92410300C4D527 /* Peripheral */,
@@ -9288,6 +9479,8 @@
 				1D638127161E211E003603ED /* PeripheralImon.h */,
 				68AE5BED1C92424300C4D527 /* PeripheralJoystick.cpp */,
 				68AE5BEE1C92424300C4D527 /* PeripheralJoystick.h */,
+				680659B11C98C16C00811653 /* PeripheralJoystickEmulation.cpp */,
+				680659B21C98C16C00811653 /* PeripheralJoystickEmulation.h */,
 				F5E10526140AA38000175026 /* PeripheralNIC.cpp */,
 				F5E10527140AA38000175026 /* PeripheralNIC.h */,
 				F5E10528140AA38000175026 /* PeripheralNyxboard.cpp */,
@@ -9439,6 +9632,7 @@
 				DFD717561C0A031B0025D964 /* Default-568h@2x.png in Resources */,
 				7CCDA1E4192753E30074CF51 /* RdrConnectionManagerSCPD.xml in Resources */,
 				7CCDA1EF192753E30074CF51 /* RenderingControlSCPD.xml in Resources */,
+				DFD717641C0A03540025D964 /* Info.plist in Resources */,
 				7CCDA1F1192753E30074CF51 /* RenderingControlSCPD_Full.xml in Resources */,
 				DFD717581C0A031B0025D964 /* Default-736h@3x.png in Resources */,
 				391416BF1B4A3EFA00BBF0AA /* guiinfo in Resources */,
@@ -9717,6 +9911,7 @@
 				E38E20280D25F9FD00618676 /* IFile.cpp in Sources */,
 				E38E20290D25F9FD00618676 /* iso9660.cpp in Sources */,
 				68AE5BEF1C92424300C4D527 /* PeripheralJoystick.cpp in Sources */,
+				680659A91C98C13900811653 /* GenericKeyboardJoystick.cpp in Sources */,
 				39B4F3701B96F845009B2D88 /* RepositoryUpdater.cpp in Sources */,
 				E38E202A0D25F9FD00618676 /* ISO9660Directory.cpp in Sources */,
 				E38E20330D25F9FD00618676 /* MultiPathDirectory.cpp in Sources */,
@@ -9746,6 +9941,7 @@
 				E38E204F0D25F9FD00618676 /* PlaylistDirectory.cpp in Sources */,
 				E38E20500D25F9FD00618676 /* PlaylistFileDirectory.cpp in Sources */,
 				68AE5C1B1C92438E00C4D527 /* GUIControllerButton.cpp in Sources */,
+				680659721C98C02900811653 /* GameClientProperties.cpp in Sources */,
 				E38E20510D25F9FD00618676 /* PluginDirectory.cpp in Sources */,
 				7CF3194B1BD2C65500A44A41 /* MusicInfoTagLoaderFFmpeg.cpp in Sources */,
 				E38E20520D25F9FD00618676 /* RarDirectory.cpp in Sources */,
@@ -9809,6 +10005,7 @@
 				DF91E9401C0A29530011084D /* main.cpp in Sources */,
 				DF396ED31C42A25F00214C1A /* DictionaryUtils.mm in Sources */,
 				E38E20A30D25F9FD00618676 /* GUIDialogYesNo.cpp in Sources */,
+				680659AF1C98C15800811653 /* PeripheralBusApplication.cpp in Sources */,
 				E38E20A40D25F9FD00618676 /* GUILargeTextureManager.cpp in Sources */,
 				E38E20A50D25F9FD00618676 /* GUIMediaWindow.cpp in Sources */,
 				E38E20A60D25F9FD00618676 /* GUIPassword.cpp in Sources */,
@@ -9950,6 +10147,7 @@
 				E38E22F10D25F9FE00618676 /* Splash.cpp in Sources */,
 				E38E22F20D25F9FE00618676 /* Stopwatch.cpp in Sources */,
 				E38E22F30D25F9FE00618676 /* SystemInfo.cpp in Sources */,
+				680659901C98C06600811653 /* GUIWindowGames.cpp in Sources */,
 				E38E22F40D25F9FE00618676 /* Thread.cpp in Sources */,
 				E38E22F70D25F9FE00618676 /* UdpClient.cpp in Sources */,
 				DF29BCFA1B5D911800904347 /* GUIViewStateEventLog.cpp in Sources */,
@@ -9958,6 +10156,7 @@
 				E38E22FC0D25F9FE00618676 /* VideoInfoScanner.cpp in Sources */,
 				7CCA95C81BC6E6F90091D308 /* Resolution.cpp in Sources */,
 				E38E22FD0D25F9FE00618676 /* VideoInfoTag.cpp in Sources */,
+				680659AB1C98C13900811653 /* GenericKeyboardJoystickHandling.cpp in Sources */,
 				E38E23040D25F9FE00618676 /* XBApplicationEx.cpp in Sources */,
 				E38E25780D263BF600618676 /* unpack.cpp in Sources */,
 				E38E257C0D263C4400618676 /* rar.cpp in Sources */,
@@ -9965,6 +10164,7 @@
 				68AE5BA51C92412900C4D527 /* AddonCallbacksPeripheral.cpp in Sources */,
 				E38E25C30D263DE200618676 /* DVDDemuxFFmpeg.cpp in Sources */,
 				E3A4780A0D29029A00F3C3A6 /* GUIDialogCache.cpp in Sources */,
+				680659B71C98C19F00811653 /* DVDDemuxGame.cpp in Sources */,
 				395C29ED1A98A16300EBC7AD /* HTTPPythonInvoker.cpp in Sources */,
 				E3A4781A0D29032C00F3C3A6 /* GUIDialogAccessPoints.cpp in Sources */,
 				2A7B2BDC1BD6F16600044BCD /* PVRSettings.cpp in Sources */,
@@ -10058,6 +10258,7 @@
 				43348AAE1077486D00F859CF /* PlayerCoreFactory.cpp in Sources */,
 				7C973CF21B5037EF0002A874 /* ActiveAEDSPAddon.cpp in Sources */,
 				43348AAF1077486D00F859CF /* PlayerSelectionRule.cpp in Sources */,
+				6806598E1C98C06600811653 /* GUIViewStateWindowGames.cpp in Sources */,
 				7CAA20511079C8160096DE39 /* BaseRenderer.cpp in Sources */,
 				55D3604E1826CAB900DA66D2 /* OverlayRendererGUI.cpp in Sources */,
 				F5E56BA61082A675006E788A /* PosixMountProvider.cpp in Sources */,
@@ -10120,6 +10321,7 @@
 				18B7C7B11294222E009E7A26 /* GUIBaseContainer.cpp in Sources */,
 				18B7C7B21294222E009E7A26 /* GUIBorderedImage.cpp in Sources */,
 				18B7C7B31294222E009E7A26 /* GUIButtonControl.cpp in Sources */,
+				680659701C98C02900811653 /* GameClientInput.cpp in Sources */,
 				18B7C7B51294222E009E7A26 /* GUICheckMarkControl.cpp in Sources */,
 				18B7C7B61294222E009E7A26 /* GUIColorManager.cpp in Sources */,
 				DFD717391C09FEC60025D964 /* DarwinUtils.mm in Sources */,
@@ -10208,6 +10410,7 @@
 				18B7C8E912942603009E7A26 /* Crc32.cpp in Sources */,
 				18B7C8EE12942613009E7A26 /* URIUtils.cpp in Sources */,
 				18B7C8F31294261F009E7A26 /* StringUtils.cpp in Sources */,
+				6806597F1C98C04200811653 /* GameManager.cpp in Sources */,
 				5EB3113C1A978B9B00551907 /* CueInfoLoader.cpp in Sources */,
 				18B7C8FB12942718009E7A26 /* GUIDialogAddonSettings.cpp in Sources */,
 				18B7C90012942761009E7A26 /* GUIDialogAudioSubtitleSettings.cpp in Sources */,
@@ -10237,6 +10440,8 @@
 				F5AE409C13415D9E0004BD79 /* AudioLibrary.cpp in Sources */,
 				F5AE409F13415D9E0004BD79 /* FileItemHandler.cpp in Sources */,
 				F5AE40A013415D9E0004BD79 /* FileOperations.cpp in Sources */,
+				6806597D1C98C04200811653 /* GameFileAutoLauncher.cpp in Sources */,
+				6806596E1C98C02900811653 /* GameClient.cpp in Sources */,
 				F5AE40A113415D9E0004BD79 /* JSONRPC.cpp in Sources */,
 				F5AE40A413415D9E0004BD79 /* PlayerOperations.cpp in Sources */,
 				F5AE40A513415D9E0004BD79 /* PlaylistOperations.cpp in Sources */,
@@ -10257,6 +10462,7 @@
 				F558F27F13ABD57400631E12 /* DirtyRegionTracker.cpp in Sources */,
 				F558F29613ABD7DF00631E12 /* GUIWindowDebugInfo.cpp in Sources */,
 				DF0DF15C13A3ADA7008ED511 /* NFSDirectory.cpp in Sources */,
+				680659A01C98C0E500811653 /* PixelConverter.cpp in Sources */,
 				68AE5C211C92438E00C4D527 /* GUIScalarFeatureButton.cpp in Sources */,
 				7C89619213B6A16F003631FE /* GUIWindowScreensaverDim.cpp in Sources */,
 				18ECC96213CF178D00A9ED6C /* StreamUtils.cpp in Sources */,
@@ -10267,6 +10473,7 @@
 				DFAB049813F8376700B70BFB /* InertialScrollingHandler.cpp in Sources */,
 				DF3488E713FD958F0026A711 /* GUIAction.cpp in Sources */,
 				DF34892A13FD9C780026A711 /* AirPlayServer.cpp in Sources */,
+				680659981C98C07500811653 /* PortMapper.cpp in Sources */,
 				DF34898213FDAAF60026A711 /* HttpParser.cpp in Sources */,
 				18968DC814155D7C005BA742 /* ApplicationOperations.cpp in Sources */,
 				DF0E4AD41AD5986F00A75430 /* GUIDialogPVRRadioRDSInfo.cpp in Sources */,
@@ -10360,6 +10567,7 @@
 				C84828C6156CFCD8005A996F /* PVRChannelGroups.cpp in Sources */,
 				C84828C7156CFCD8005A996F /* PVRChannelGroupsContainer.cpp in Sources */,
 				C84828C8156CFCD8005A996F /* GUIDialogPVRChannelManager.cpp in Sources */,
+				680659B31C98C16C00811653 /* PeripheralJoystickEmulation.cpp in Sources */,
 				C84828C9156CFCD8005A996F /* GUIDialogPVRChannelsOSD.cpp in Sources */,
 				C84828CC156CFCD8005A996F /* GUIDialogPVRGroupManager.cpp in Sources */,
 				DF54F8031B6580C8000FCBA4 /* ContextMenuAddon.cpp in Sources */,
@@ -10380,6 +10588,7 @@
 				C84828DE156CFCD8005A996F /* GUIWindowPVRBase.cpp in Sources */,
 				C84828DF156CFCD8005A996F /* GUIWindowPVRChannels.cpp in Sources */,
 				C84828E1156CFCD8005A996F /* GUIWindowPVRGuide.cpp in Sources */,
+				6806599C1C98C0C200811653 /* InputStreamGame.cpp in Sources */,
 				C84828E2156CFCD8005A996F /* GUIWindowPVRRecordings.cpp in Sources */,
 				C84828E3156CFCD8005A996F /* GUIWindowPVRSearch.cpp in Sources */,
 				C84828E4156CFCD8005A996F /* GUIWindowPVRTimers.cpp in Sources */,
@@ -10394,6 +10603,7 @@
 				C84828FE156CFDC3005A996F /* GUIDialogExtendedProgressBar.cpp in Sources */,
 				C8482901156CFE4B005A996F /* Observer.cpp in Sources */,
 				DFC6F4C11AFF7E300039A7FA /* rfft.cpp in Sources */,
+				680659881C98C05700811653 /* GameInfoTag.cpp in Sources */,
 				7CD4F7EC1C60DBC10015214B /* VideoFileItemListModifier.cpp in Sources */,
 				C8482909156CFF24005A996F /* PVRDirectory.cpp in Sources */,
 				C8482910156CFFA0005A996F /* DVDInputStreamPVRManager.cpp in Sources */,
@@ -10480,6 +10690,7 @@
 				7C7CEAF1165629530059C9EB /* AELimiter.cpp in Sources */,
 				DFB02DEA16629DBA00F37752 /* PyContext.cpp in Sources */,
 				68AE5C1F1C92438E00C4D527 /* GUIGameController.cpp in Sources */,
+				DF072534168734ED008DCAAD /* FFmpegVideoDecoder.cpp in Sources */,
 				7C8E02221BA35D0B0072E8B2 /* Builtins.cpp in Sources */,
 				395F6DE21A81FACF0088CC74 /* HTTPImageTransformationHandler.cpp in Sources */,
 				DF64FE3D16C07AAA00D028FB /* GUIViewControl.cpp in Sources */,
@@ -10503,6 +10714,7 @@
 				DF32466219E931A8005E8CFB /* ActiveAEResampleFFMPEG.cpp in Sources */,
 				DF89901D1709BB2D00B35C21 /* MediaSourceSettings.cpp in Sources */,
 				DF89901E1709BB2D00B35C21 /* SkinSettings.cpp in Sources */,
+				680659961C98C07500811653 /* PortManager.cpp in Sources */,
 				DF8990211709BB5400B35C21 /* ViewStateSettings.cpp in Sources */,
 				395C29D51A98A11C00EBC7AD /* WsgiErrorStream.cpp in Sources */,
 				DF28EDA2170E1A11005FA9D2 /* GUIDialogLockSettings.cpp in Sources */,
@@ -10579,6 +10791,7 @@
 				AE32174218313ADF0003FAFC /* XSLTUtils.cpp in Sources */,
 				7C15DCBC1892481400FCE564 /* InfoBool.cpp in Sources */,
 				F5CC228B1814F7E9006B5E91 /* AESinkDARWINOSX.cpp in Sources */,
+				680659811C98C04200811653 /* GameSettings.cpp in Sources */,
 				F5CC22EB1814FF3B006B5E91 /* ActiveAE.cpp in Sources */,
 				F5CC22EC1814FF3B006B5E91 /* ActiveAEBuffer.cpp in Sources */,
 				F5CC22EE1814FF3B006B5E91 /* ActiveAESink.cpp in Sources */,
@@ -10716,6 +10929,7 @@
 				7CCDACA719275D1F0074CF51 /* NptStdcDebug.cpp in Sources */,
 				7CCDACB019275D1F0074CF51 /* NptStdcEnvironment.cpp in Sources */,
 				DF4A3BB21B4B0FC100F9CDC0 /* ApplicationMessenger.cpp in Sources */,
+				680659831C98C04200811653 /* SerialState.cpp in Sources */,
 				7CCDACC119275D790074CF51 /* NptAppleAutoreleasePool.mm in Sources */,
 				7CCDACCA19275D790074CF51 /* NptAppleLogConfig.mm in Sources */,
 				7CAA469019427AED00008885 /* PosixDirectory.cpp in Sources */,
@@ -10728,6 +10942,7 @@
 				7CF80DC919710DC2003B2B34 /* KeyboardLayout.cpp in Sources */,
 				B179BD6B1AD8EA7B00EA8D49 /* InputCodingTableBaiduPY.cpp in Sources */,
 				DFD7173B1C09FEC60025D964 /* OSXGNUReplacements.c in Sources */,
+				680659601C98BFB400811653 /* AddonCallbacksGame.cpp in Sources */,
 				B179BD6E1AD8EA7B00EA8D49 /* InputCodingTableBasePY.cpp in Sources */,
 				B179BD711AD8EA7B00EA8D49 /* InputCodingTableFactory.cpp in Sources */,
 			);
@@ -10742,6 +10957,7 @@
 				DF1D2DF41B6E85EE002BB9DB /* XbtManager.cpp in Sources */,
 				E499114F174E5CC300741B6D /* archive.cpp in Sources */,
 				68AE5BF01C92424400C4D527 /* PeripheralJoystick.cpp in Sources */,
+				680659711C98C02900811653 /* GameClientInput.cpp in Sources */,
 				E4991150174E5CC300741B6D /* arcread.cpp in Sources */,
 				E4991151174E5CC300741B6D /* cmddata.cpp in Sources */,
 				E4991152174E5CC300741B6D /* consio.cpp in Sources */,
@@ -10754,6 +10970,7 @@
 				E4991158174E5CC300741B6D /* extract.cpp in Sources */,
 				68AE5BCF1C9241F800C4D527 /* ButtonMapping.cpp in Sources */,
 				E4991159174E5CC300741B6D /* filcreat.cpp in Sources */,
+				6806598F1C98C06600811653 /* GUIViewStateWindowGames.cpp in Sources */,
 				E499115A174E5CC300741B6D /* file.cpp in Sources */,
 				E499115B174E5CC300741B6D /* filefn.cpp in Sources */,
 				E499115C174E5CC300741B6D /* filestr.cpp in Sources */,
@@ -10800,6 +11017,7 @@
 				E4991185174E5CE000741B6D /* GUIViewStateAddonBrowser.cpp in Sources */,
 				E4991186174E5CE000741B6D /* GUIWindowAddonBrowser.cpp in Sources */,
 				E4991187174E5CE000741B6D /* PluginSource.cpp in Sources */,
+				680659821C98C04200811653 /* GameSettings.cpp in Sources */,
 				E4991188174E5CE000741B6D /* Repository.cpp in Sources */,
 				E4991189174E5CE000741B6D /* Scraper.cpp in Sources */,
 				E499118A174E5CE000741B6D /* ScreenSaver.cpp in Sources */,
@@ -10868,6 +11086,7 @@
 				DF396ED21C42A25F00214C1A /* DarwinNSUserDefaults.mm in Sources */,
 				E49911DF174E5D3700741B6D /* DVDInputStreamFFmpeg.cpp in Sources */,
 				E49911E0174E5D3700741B6D /* DVDInputStreamFile.cpp in Sources */,
+				680659B81C98C19F00811653 /* DVDDemuxGame.cpp in Sources */,
 				E49911E3174E5D3700741B6D /* DVDInputStreamMemory.cpp in Sources */,
 				F597B05C18A804E0005AADAE /* DVDVideoCodec.cpp in Sources */,
 				E49911E4174E5D3700741B6D /* DVDInputStreamNavigator.cpp in Sources */,
@@ -10919,6 +11138,7 @@
 				E4991220174E5D5A00741B6D /* BaseRenderer.cpp in Sources */,
 				E4991222174E5D5A00741B6D /* OverlayRenderer.cpp in Sources */,
 				E4991223174E5D5A00741B6D /* OverlayRendererGL.cpp in Sources */,
+				680659611C98BFB400811653 /* AddonCallbacksGame.cpp in Sources */,
 				E4991224174E5D5A00741B6D /* OverlayRendererUtil.cpp in Sources */,
 				E4991225174E5D5A00741B6D /* RenderCapture.cpp in Sources */,
 				E4991226174E5D5A00741B6D /* RenderManager.cpp in Sources */,
@@ -11042,8 +11262,10 @@
 				E4991294174E5D9900741B6D /* MusicSearchDirectory.cpp in Sources */,
 				9A999F1E1C67B77600E4E0D5 /* AddonBuilder.cpp in Sources */,
 				E4991298174E5D9900741B6D /* NFSDirectory.cpp in Sources */,
+				680659A11C98C0E500811653 /* PixelConverter.cpp in Sources */,
 				E4991299174E5D9900741B6D /* NFSFile.cpp in Sources */,
 				E499129A174E5D9900741B6D /* NptXbmcFile.cpp in Sources */,
+				680659841C98C04200811653 /* SerialState.cpp in Sources */,
 				E499129D174E5D9900741B6D /* PipeFile.cpp in Sources */,
 				E499129E174E5D9900741B6D /* PipesManager.cpp in Sources */,
 				E499129F174E5D9900741B6D /* PlaylistDirectory.cpp in Sources */,
@@ -11106,13 +11328,16 @@
 				68AE5BE01C92421800C4D527 /* AddonButtonMap.cpp in Sources */,
 				E49912D6174E5DA000741B6D /* ZeroconfDirectory.cpp in Sources */,
 				E49912D7174E5DA000741B6D /* ZipDirectory.cpp in Sources */,
+				680659B01C98C15800811653 /* PeripheralBusApplication.cpp in Sources */,
 				E49912D8174E5DA000741B6D /* ZipFile.cpp in Sources */,
 				E49912D9174E5DA000741B6D /* ZipManager.cpp in Sources */,
 				E49912DC174E5DAD00741B6D /* D3DResource.cpp in Sources */,
 				E49912DD174E5DAD00741B6D /* DDSImage.cpp in Sources */,
 				E49912DE174E5DAD00741B6D /* DirectXGraphics.cpp in Sources */,
 				E49912DF174E5DAD00741B6D /* DirtyRegionSolvers.cpp in Sources */,
+				680659801C98C04200811653 /* GameManager.cpp in Sources */,
 				E49912E0174E5DAD00741B6D /* DirtyRegionTracker.cpp in Sources */,
+				680659911C98C06600811653 /* GUIWindowGames.cpp in Sources */,
 				E49912E1174E5DAD00741B6D /* FrameBufferObject.cpp in Sources */,
 				E49912E2174E5DAD00741B6D /* GraphicContext.cpp in Sources */,
 				E49912E3174E5DAD00741B6D /* GUIAction.cpp in Sources */,
@@ -11120,12 +11345,14 @@
 				E49912E5174E5DAD00741B6D /* GUIBaseContainer.cpp in Sources */,
 				E49912E6174E5DAD00741B6D /* GUIBorderedImage.cpp in Sources */,
 				E49912E7174E5DAD00741B6D /* GUIButtonControl.cpp in Sources */,
+				6806597E1C98C04200811653 /* GameFileAutoLauncher.cpp in Sources */,
 				E49912E8174E5DAD00741B6D /* GUICheckMarkControl.cpp in Sources */,
 				E49912E9174E5DAD00741B6D /* GUIColorManager.cpp in Sources */,
 				76AEFB3F1C8F79DC00EF2EC0 /* AddonCallbacksPVR.cpp in Sources */,
 				E49912EA174E5DAD00741B6D /* GUIControl.cpp in Sources */,
 				E49912EB174E5DAD00741B6D /* GUIControlFactory.cpp in Sources */,
 				E49912EC174E5DAD00741B6D /* GUIControlGroup.cpp in Sources */,
+				680659AA1C98C13900811653 /* GenericKeyboardJoystick.cpp in Sources */,
 				395C29C61A98A0E100EBC7AD /* ILanguageInvoker.cpp in Sources */,
 				E49912ED174E5DAD00741B6D /* GUIControlGroupList.cpp in Sources */,
 				E49912EE174E5DAD00741B6D /* GUIControlProfiler.cpp in Sources */,
@@ -11178,7 +11405,9 @@
 				E4991315174E5DAD00741B6D /* GUITextBox.cpp in Sources */,
 				E4991316174E5DAD00741B6D /* GUITextLayout.cpp in Sources */,
 				E4991317174E5DAD00741B6D /* GUITexture.cpp in Sources */,
+				680659731C98C02900811653 /* GameClientProperties.cpp in Sources */,
 				395C2A121A9F072400EBC7AD /* ResourceDirectory.cpp in Sources */,
+				680659991C98C07500811653 /* PortMapper.cpp in Sources */,
 				E4991318174E5DAD00741B6D /* GUITextureD3D.cpp in Sources */,
 				E4991319174E5DAD00741B6D /* GUITextureGL.cpp in Sources */,
 				E499131A174E5DAD00741B6D /* GUITextureGLES.cpp in Sources */,
@@ -11416,6 +11645,7 @@
 				68AE5C1A1C92438E00C4D527 /* GUIAnalogStickButton.cpp in Sources */,
 				DFD7173A1C09FEC60025D964 /* DarwinUtils.mm in Sources */,
 				E4991415174E5FF000741B6D /* RenderSystemGLES.cpp in Sources */,
+				680659AC1C98C13900811653 /* GenericKeyboardJoystickHandling.cpp in Sources */,
 				E4991416174E602700741B6D /* RenderSystem.cpp in Sources */,
 				E4991417174E603C00741B6D /* GUIControlSettings.cpp in Sources */,
 				E4991418174E603C00741B6D /* GUIDialogContentSettings.cpp in Sources */,
@@ -11464,6 +11694,7 @@
 				E4991448174E605900741B6D /* CPUInfo.cpp in Sources */,
 				E4991449174E605900741B6D /* Crc32.cpp in Sources */,
 				E499144A174E605900741B6D /* CryptThreading.cpp in Sources */,
+				6806596F1C98C02900811653 /* GameClient.cpp in Sources */,
 				E499144B174E605900741B6D /* DatabaseUtils.cpp in Sources */,
 				E499144F174E605900741B6D /* Environment.cpp in Sources */,
 				E4991450174E605900741B6D /* Fanart.cpp in Sources */,
@@ -11535,6 +11766,7 @@
 				E499148F174E606600741B6D /* GUIWindowVideoPlaylist.cpp in Sources */,
 				7C1870631CA1664D00114E45 /* PVRClient.cpp in Sources */,
 				E4991490174E606600741B6D /* Bookmark.cpp in Sources */,
+				E4991491174E606600741B6D /* FFmpegVideoDecoder.cpp in Sources */,
 				E4991492174E606600741B6D /* GUIViewStateVideo.cpp in Sources */,
 				E4991493174E606600741B6D /* PlayerController.cpp in Sources */,
 				E4991494174E606600741B6D /* Teletext.cpp in Sources */,
@@ -11551,6 +11783,7 @@
 				76AEFB3E1C8F79D900EF2EC0 /* AddonCallbacksInputStream.cpp in Sources */,
 				E499149D174E606E00741B6D /* GUIViewState.cpp in Sources */,
 				E499149E174E606E00741B6D /* ViewDatabase.cpp in Sources */,
+				680659891C98C05700811653 /* GameInfoTag.cpp in Sources */,
 				E499149F174E606E00741B6D /* ViewStateSettings.cpp in Sources */,
 				E49914A0174E606E00741B6D /* WinEventsSDL.cpp in Sources */,
 				E49914A1174E606E00741B6D /* WinSystem.cpp in Sources */,
@@ -11671,6 +11904,7 @@
 				DFD882E817DD189E001516FE /* StringValidation.cpp in Sources */,
 				F500E35717F3412C004FC217 /* WinEvents.cpp in Sources */,
 				7C2612721825B6340086E04D /* DatabaseQuery.cpp in Sources */,
+				680659971C98C07500811653 /* PortManager.cpp in Sources */,
 				7C920CFA181669FF00DA1477 /* TextureOperations.cpp in Sources */,
 				DFEF0BAD180ADE6400AEAED1 /* FileItemListModification.cpp in Sources */,
 				DFE4BE061C661C5F0048EB03 /* AnnounceReceiver.mm in Sources */,
@@ -11722,6 +11956,7 @@
 				7CCDA0DC192753E30074CF51 /* PltAction.cpp in Sources */,
 				7CCDA0E5192753E30074CF51 /* PltArgument.cpp in Sources */,
 				7CCDA0EE192753E30074CF51 /* PltConstants.cpp in Sources */,
+				680659B41C98C16C00811653 /* PeripheralJoystickEmulation.cpp in Sources */,
 				7CCA95C21BC6E6670091D308 /* RendererVTB.cpp in Sources */,
 				7CCDA0F7192753E30074CF51 /* PltCtrlPoint.cpp in Sources */,
 				7CCDA100192753E30074CF51 /* PltCtrlPointTask.cpp in Sources */,
@@ -11838,6 +12073,7 @@
 				7C908895196358A8003D0619 /* auto_buffer.cpp in Sources */,
 				7CF34DA01930264A00D543C5 /* AudioEncoder.cpp in Sources */,
 				395C29F71A98B44B00EBC7AD /* AddonModuleXbmcwsgi.cpp in Sources */,
+				6806599D1C98C0C200811653 /* InputStreamGame.cpp in Sources */,
 				7CF80DCA19710DC2003B2B34 /* KeyboardLayout.cpp in Sources */,
 				B179BD6C1AD8EA7B00EA8D49 /* InputCodingTableBaiduPY.cpp in Sources */,
 				B179BD6F1AD8EA7B00EA8D49 /* InputCodingTableBasePY.cpp in Sources */,
diff --git a/Makefile.in b/Makefile.in
index 972e052..35d3243 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -30,6 +30,7 @@ DIRECTORY_ARCHIVES=$(VideoPlayer_ARCHIVES) \
                    xbmc/addons/binary/interfaces/api1/AudioDSP/addon-callbacks-audiodsp.a \
                    xbmc/addons/binary/interfaces/api1/AudioEngine/addon-callbacks-audioengine.a \
                    xbmc/addons/binary/interfaces/api1/Codec/addon-callbacks-codec.a \
+                   xbmc/addons/binary/interfaces/api1/Game/addon-callbacks-game.a \
                    xbmc/addons/binary/interfaces/api1/GUI/addon-callbacks-gui.a \
                    xbmc/addons/binary/interfaces/api1/InputStream/addon-callbacks-inputstream.a \
                    xbmc/addons/binary/interfaces/api1/Peripheral/addon-callbacks-peripheral.a \
@@ -54,9 +55,14 @@ DIRECTORY_ARCHIVES=$(VideoPlayer_ARCHIVES) \
                    xbmc/filesystem/MusicDatabaseDirectory/musicdatabasedirectory.a \
                    xbmc/filesystem/VideoDatabaseDirectory/videodatabasedirectory.a \
                    xbmc/filesystem/filesystem.a \
+                   xbmc/games/addons/gameaddons.a \
                    xbmc/games/controllers/controllers.a \
                    xbmc/games/controllers/guicontrols/controllerguicontrols.a \
                    xbmc/games/controllers/windows/controllerwindows.a \
+                   xbmc/games/games.a \
+                   xbmc/games/ports/gameports.a \
+                   xbmc/games/tags/gameinfotags.a \
+                   xbmc/games/windows/gamewindows.a \
                    xbmc/guilib/guilib.a \
                    xbmc/input/input.a \
                    xbmc/interfaces/builtins/builtins.a \
@@ -145,8 +151,6 @@ DIRECTORY_ARCHIVES += xbmc/network/mdns/mdns.a
 endif
 
 ifeq ($(findstring osx,@ARCH@),osx)
-DIRECTORY_ARCHIVES += xbmc/input/joysticks/input_joysticks.a
-DIRECTORY_ARCHIVES += xbmc/input/joysticks/generic/input_joysticks_generic.a
 DIRECTORY_ARCHIVES += xbmc/network/osx/network.a
 DIRECTORY_ARCHIVES += xbmc/network/linux/network_linux.a
 DIRECTORY_ARCHIVES += xbmc/powermanagement/osx/powermanagement.a
@@ -162,6 +166,7 @@ INSTALL_FILTER += .*repository\.pvr-osx.*\.xbmc\.org.*
 ifeq (@USE_ANDROID@,1)
 DIRECTORY_ARCHIVES += xbmc/input/joysticks/input_joysticks.a
 DIRECTORY_ARCHIVES += xbmc/input/joysticks/generic/input_joysticks_generic.a
+DIRECTORY_ARCHIVES += xbmc/input/keyboard/generic/input_keyboard_generic.a
 DIRECTORY_ARCHIVES += xbmc/input/linux/input_linux.a
 DIRECTORY_ARCHIVES += xbmc/input/touch/input_touch.a
 DIRECTORY_ARCHIVES += xbmc/input/touch/generic/input_touch_generic.a
@@ -172,6 +177,7 @@ DIRECTORY_ARCHIVES += xbmc/windowing/X11/windowing_X11.a
 else
 DIRECTORY_ARCHIVES += xbmc/input/joysticks/input_joysticks.a
 DIRECTORY_ARCHIVES += xbmc/input/joysticks/generic/input_joysticks_generic.a
+DIRECTORY_ARCHIVES += xbmc/input/keyboard/generic/input_keyboard_generic.a
 DIRECTORY_ARCHIVES += xbmc/input/linux/input_linux.a
 DIRECTORY_ARCHIVES += xbmc/input/touch/input_touch.a
 DIRECTORY_ARCHIVES += xbmc/input/touch/generic/input_touch_generic.a
@@ -216,6 +222,7 @@ LIBADDON_DIRS=\
 	lib/addons/library.kodi.guilib \
 	lib/addons/library.kodi.inputstream \
 	lib/addons/library.kodi.peripheral \
+	lib/addons/library.kodi.game \
 
 ESTUARY_MEDIA=addons/skin.estuary/media
 SKIN_DIRS=$(ESTUARY_MEDIA)
@@ -336,6 +343,7 @@ libaddon: exports
 	$(MAKE) -C lib/addons/library.kodi.adsp
 	$(MAKE) -C lib/addons/library.kodi.audioengine
 	$(MAKE) -C lib/addons/library.xbmc.codec
+	$(MAKE) -C lib/addons/library.kodi.game
 	$(MAKE) -C lib/addons/library.kodi.guilib
 	$(MAKE) -C lib/addons/library.kodi.peripheral
 	$(MAKE) -C lib/addons/library.xbmc.pvr
diff --git a/addons/game.controller.dreamcast/addon.xml b/addons/game.controller.dreamcast/addon.xml
new file mode 100644
index 0000000..abc9619
--- /dev/null
+++ b/addons/game.controller.dreamcast/addon.xml
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
+<addon id="game.controller.dreamcast"
+        name="Dreamcast Controller"
+        version="1.0.1"
+        provider-name="garbear">
+    <requires>
+    </requires>
+    <extension point="kodi.game.controller" library="layout.xml"/>
+    <extension point="xbmc.addon.metadata">
+        <summary>Dreamcast controller</summary>
+        <description>The Dreamcast Controller is the primary user interface for the Sega Dreamcast. It is a logical progression from the 3D Control Pad for the Sega Saturn and is supported by every Dreamcast game.</description>
+        <disclaimer></disclaimer>
+        <platform>all</platform>
+        <nofanart>true</nofanart>
+    </extension>
+</addon>
diff --git a/addons/game.controller.dreamcast/icon.png b/addons/game.controller.dreamcast/icon.png
new file mode 100644
index 0000000..36baf12
Binary files /dev/null and b/addons/game.controller.dreamcast/icon.png differ
diff --git a/addons/game.controller.dreamcast/layout.png b/addons/game.controller.dreamcast/layout.png
new file mode 100644
index 0000000..dc14471
Binary files /dev/null and b/addons/game.controller.dreamcast/layout.png differ
diff --git a/addons/game.controller.dreamcast/layout.xml b/addons/game.controller.dreamcast/layout.xml
new file mode 100644
index 0000000..ce156a8
--- /dev/null
+++ b/addons/game.controller.dreamcast/layout.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
+<layout name="Dreamcast" label="30000" image="layout.png">
+	<face>
+		<button name="a" type="digital" label="30001"/>
+		<button name="b" type="digital" label="30002"/>
+		<button name="x" type="digital" label="30003"/>
+		<button name="y" type="digital" label="30004"/>
+		<button name="start" type="digital" label="30005"/>
+		<button name="up" type="digital" label="30006" direction="up"/>
+		<button name="down" type="digital" label="30007" direction="down"/>
+		<button name="right" type="digital" label="30008" direction="right"/>
+		<button name="left" type="digital" label="30009" direction="left"/>
+	</face>
+	<triggers>
+		<button name="lefttrigger" type="digital" label="30010"/>
+		<button name="righttrigger" type="digital" label="30011"/>
+	</triggers>
+	<analogsticks>
+		<analogstick name="analogstick" label="30012"/>
+	</analogsticks>
+</layout>
diff --git a/addons/game.controller.dreamcast/resources/language/resource.language.en_gb/strings.po b/addons/game.controller.dreamcast/resources/language/resource.language.en_gb/strings.po
new file mode 100644
index 0000000..c274f46
--- /dev/null
+++ b/addons/game.controller.dreamcast/resources/language/resource.language.en_gb/strings.po
@@ -0,0 +1,69 @@
+# XBMC Media Center language file
+# Addon Name: Dreamcast controller
+# Addon id: gameclient.controller.dreamcast
+# Addon Provider: Libretro Team
+msgid ""
+msgstr ""
+"Project-Id-Version: Libretro Clients\n"
+"Report-Msgid-Bugs-To: alanwww1@xbmc.org\n"
+"POT-Creation-Date: 2014-05-30 17:00+8\n"
+"PO-Revision-Date: 2014-05-30 17:00+8\n"
+"Last-Translator: XBMC Translation Team\n"
+"Language-Team: English (http://www.transifex.com/projects/p/xbmc-addons/language/en/)\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Language: en\n"
+"Plural-Forms: nplurals=2; plural=(n != 1);\n"
+
+msgctxt "#30000"
+msgid "Dreamcast"
+msgstr ""
+
+msgctxt "#30001"
+msgid "A"
+msgstr ""
+
+msgctxt "#30002"
+msgid "B"
+msgstr ""
+
+msgctxt "#30003"
+msgid "X"
+msgstr ""
+
+msgctxt "#30004"
+msgid "Y"
+msgstr ""
+
+msgctxt "#30005"
+msgid "Start"
+msgstr ""
+
+msgctxt "#30006"
+msgid "Up"
+msgstr ""
+
+msgctxt "#30007"
+msgid "Down"
+msgstr ""
+
+msgctxt "#30008"
+msgid "Right"
+msgstr ""
+
+msgctxt "#30009"
+msgid "Left"
+msgstr ""
+
+msgctxt "#30010"
+msgid "Left Trigger"
+msgstr ""
+
+msgctxt "#30011"
+msgid "Right Trigger"
+msgstr ""
+
+msgctxt "#30012"
+msgid "Analog Stick"
+msgstr ""
diff --git a/addons/game.controller.gba/addon.xml b/addons/game.controller.gba/addon.xml
new file mode 100644
index 0000000..f661113
--- /dev/null
+++ b/addons/game.controller.gba/addon.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
+<addon id="game.controller.gba"
+        name="Game Boy Advance"
+        version="1.0.1"
+        provider-name="garbear">
+    <requires>
+    </requires>
+    <extension point="kodi.game.controller" library="layout.xml"/>
+    <extension point="xbmc.addon.metadata">
+        <summary>Game Boy Advance</summary>
+        <description>Game Boy Advance is a 32-bit handheld video game console developed, manufactured and marketed by Nintendo.
+
+Layout credit: ThaFake (thafake.deviantart.com)</description>
+        <disclaimer></disclaimer>
+        <platform>all</platform>
+        <nofanart>true</nofanart>
+    </extension>
+</addon>
diff --git a/addons/game.controller.gba/icon.png b/addons/game.controller.gba/icon.png
new file mode 100644
index 0000000..f9bb922
Binary files /dev/null and b/addons/game.controller.gba/icon.png differ
diff --git a/addons/game.controller.gba/layout.png b/addons/game.controller.gba/layout.png
new file mode 100644
index 0000000..337c492
Binary files /dev/null and b/addons/game.controller.gba/layout.png differ
diff --git a/addons/game.controller.gba/layout.xml b/addons/game.controller.gba/layout.xml
new file mode 100644
index 0000000..c2a874d
--- /dev/null
+++ b/addons/game.controller.gba/layout.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
+<layout name="GBA" label="30000" image="layout.png">
+  <face>
+    <button name="a" type="digital" label="30001"/>
+    <button name="b" type="digital" label="30002"/>
+    <button name="start" type="digital" label="30003"/>
+    <button name="select" type="digital" label="30004"/>
+    <button name="up" type="digital" label="30005" direction="up"/>
+    <button name="down" type="digital" label="30006" direction="down"/>
+    <button name="right" type="digital" label="30007" direction="right"/>
+    <button name="left" type="digital" label="30008" direction="left"/>
+  </face>
+  <shoulder>
+    <button name="leftbumper" type="digital" label="30009"/>
+    <button name="rightbumper" type="digital" label="30010"/>
+  </shoulder>
+</layout>
diff --git a/addons/game.controller.gba/resources/language/resource.language.en_gb/strings.po b/addons/game.controller.gba/resources/language/resource.language.en_gb/strings.po
new file mode 100644
index 0000000..3b4c2df
--- /dev/null
+++ b/addons/game.controller.gba/resources/language/resource.language.en_gb/strings.po
@@ -0,0 +1,61 @@
+# XBMC Media Center language file
+# Addon Name: GBA
+# Addon id: game.controller.gba
+# Addon Provider: Team-Kodi
+msgid ""
+msgstr ""
+"Project-Id-Version: Libretro Clients\n"
+"Report-Msgid-Bugs-To: alanwww1@xbmc.org\n"
+"POT-Creation-Date: 2014-05-30 17:00+8\n"
+"PO-Revision-Date: 2014-05-30 17:00+8\n"
+"Last-Translator: XBMC Translation Team\n"
+"Language-Team: English (http://www.transifex.com/projects/p/xbmc-addons/language/en/)\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Language: en\n"
+"Plural-Forms: nplurals=2; plural=(n != 1);\n"
+
+msgctxt "#30000"
+msgid "Game Boy Advance"
+msgstr ""
+
+msgctxt "#30001"
+msgid "A"
+msgstr ""
+
+msgctxt "#30002"
+msgid "B"
+msgstr ""
+
+msgctxt "#30003"
+msgid "Start"
+msgstr ""
+
+msgctxt "#30004"
+msgid "Select"
+msgstr ""
+
+msgctxt "#30005"
+msgid "Up"
+msgstr ""
+
+msgctxt "#30006"
+msgid "Down"
+msgstr ""
+
+msgctxt "#30007"
+msgid "Right"
+msgstr ""
+
+msgctxt "#30008"
+msgid "Left"
+msgstr ""
+
+msgctxt "#30009"
+msgid "Left Bumper"
+msgstr ""
+
+msgctxt "#30010"
+msgid "Right Bumper"
+msgstr ""
diff --git a/addons/game.controller.genesis/addon.xml b/addons/game.controller.genesis/addon.xml
new file mode 100644
index 0000000..862d41c
--- /dev/null
+++ b/addons/game.controller.genesis/addon.xml
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
+<addon id="game.controller.genesis"
+        name="Sega Genesis Controller"
+        version="1.0.1"
+        provider-name="garbear">
+    <requires>
+    </requires>
+    <extension point="kodi.game.controller" library="layout.xml"/>
+    <extension point="xbmc.addon.metadata">
+        <summary>Sega Genesis controller</summary>
+        <description>The original Genesis controller had a directional pad, three main buttons and a start button. Sega later released a six-button version in 1993 with three additional face buttons.</description>
+        <disclaimer></disclaimer>
+        <platform>all</platform>
+        <nofanart>true</nofanart>
+    </extension>
+</addon>
diff --git a/addons/game.controller.genesis/icon.png b/addons/game.controller.genesis/icon.png
new file mode 100644
index 0000000..bcd48d5
Binary files /dev/null and b/addons/game.controller.genesis/icon.png differ
diff --git a/addons/game.controller.genesis/layout.png b/addons/game.controller.genesis/layout.png
new file mode 100644
index 0000000..abbaa44
Binary files /dev/null and b/addons/game.controller.genesis/layout.png differ
diff --git a/addons/game.controller.genesis/layout.xml b/addons/game.controller.genesis/layout.xml
new file mode 100644
index 0000000..1f06fe8
--- /dev/null
+++ b/addons/game.controller.genesis/layout.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
+<layout name="Genesis" label="30000" image="layout.png">
+  <face>
+    <button name="a" type="digital" label="30001"/>
+    <button name="b" type="digital" label="30002"/>
+    <button name="c" type="digital" label="30003"/>
+    <button name="x" type="digital" label="30004"/>
+    <button name="y" type="digital" label="30005"/>
+    <button name="z" type="digital" label="30006"/>
+    <button name="start" type="digital" label="30007"/>
+    <button name="mode" type="digital" label="30008"/>
+    <button name="up" type="digital" label="30009" direction="up"/>
+    <button name="down" type="digital" label="30010" direction="down"/>
+    <button name="right" type="digital" label="30011" direction="right"/>
+    <button name="left" type="digital" label="30012" direction="left"/>
+  </face>
+</layout>
diff --git a/addons/game.controller.genesis/resources/language/resource.language.en_gb/strings.po b/addons/game.controller.genesis/resources/language/resource.language.en_gb/strings.po
new file mode 100644
index 0000000..21b0136
--- /dev/null
+++ b/addons/game.controller.genesis/resources/language/resource.language.en_gb/strings.po
@@ -0,0 +1,69 @@
+# XBMC Media Center language file
+# Addon Name: Sega Genesis Controller
+# Addon id: game.controller.genesis
+# Addon Provider: Team-Kodi
+msgid ""
+msgstr ""
+"Project-Id-Version: Libretro Clients\n"
+"Report-Msgid-Bugs-To: alanwww1@xbmc.org\n"
+"POT-Creation-Date: 2014-05-30 17:00+8\n"
+"PO-Revision-Date: 2014-05-30 17:00+8\n"
+"Last-Translator: XBMC Translation Team\n"
+"Language-Team: English (http://www.transifex.com/projects/p/xbmc-addons/language/en/)\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Language: en\n"
+"Plural-Forms: nplurals=2; plural=(n != 1);\n"
+
+msgctxt "#30000"
+msgid "Sega Genesis"
+msgstr ""
+
+msgctxt "#30001"
+msgid "A"
+msgstr ""
+
+msgctxt "#30002"
+msgid "B"
+msgstr ""
+
+msgctxt "#30003"
+msgid "C"
+msgstr ""
+
+msgctxt "#30004"
+msgid "X"
+msgstr ""
+
+msgctxt "#30005"
+msgid "Y"
+msgstr ""
+
+msgctxt "#30006"
+msgid "Z"
+msgstr ""
+
+msgctxt "#30007"
+msgid "Start"
+msgstr ""
+
+msgctxt "#30008"
+msgid "Mode"
+msgstr ""
+
+msgctxt "#30009"
+msgid "Up"
+msgstr ""
+
+msgctxt "#30010"
+msgid "Down"
+msgstr ""
+
+msgctxt "#30011"
+msgid "Right"
+msgstr ""
+
+msgctxt "#30012"
+msgid "Left"
+msgstr ""
diff --git a/addons/game.controller.n64/addon.xml b/addons/game.controller.n64/addon.xml
new file mode 100644
index 0000000..0ec70cf
--- /dev/null
+++ b/addons/game.controller.n64/addon.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
+<addon id="game.controller.n64"
+        name="N64 Controller"
+        version="1.0.1"
+        provider-name="garbear">
+    <requires>
+    </requires>
+    <extension point="kodi.game.controller" library="layout.xml"/>
+    <extension point="xbmc.addon.metadata">
+        <summary>Nintendo 64 controller</summary>
+        <description>The Nintendo 64 controller, released in 1996, features ten buttons, a digital control stick and a directional pad, all laid out in an "M" shape.
+
+Layout credit: Andrew Moore</description>
+        <disclaimer></disclaimer>
+        <platform>all</platform>
+        <nofanart>true</nofanart>
+    </extension>
+</addon>
diff --git a/addons/game.controller.n64/icon.png b/addons/game.controller.n64/icon.png
new file mode 100644
index 0000000..88a4970
Binary files /dev/null and b/addons/game.controller.n64/icon.png differ
diff --git a/addons/game.controller.n64/layout.png b/addons/game.controller.n64/layout.png
new file mode 100644
index 0000000..a249d73
Binary files /dev/null and b/addons/game.controller.n64/layout.png differ
diff --git a/addons/game.controller.n64/layout.xml b/addons/game.controller.n64/layout.xml
new file mode 100644
index 0000000..d87cec0
--- /dev/null
+++ b/addons/game.controller.n64/layout.xml
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
+<layout name="N64" label="30000" image="layout.png">
+	<face>
+		<button name="a" type="digital" label="30001"/>
+		<button name="b" type="digital" label="30002"/>
+		<button name="start" type="digital" label="30003"/>
+		<button name="cup" type="digital" label="30004"/>
+		<button name="cdown" type="digital" label="30005"/>
+		<button name="cright" type="digital" label="30006"/>
+		<button name="cleft" type="digital" label="30007"/>
+		<button name="up" type="digital" label="30008" direction="up"/>
+		<button name="down" type="digital" label="30009" direction="down"/>
+		<button name="right" type="digital" label="30010" direction="right"/>
+		<button name="left" type="digital" label="30011" direction="left"/>
+	</face>
+	<shoulder>
+		<button name="leftbumper" type="digital" label="30012"/>
+		<button name="rightbumper" type="digital" label="30013"/>
+	</shoulder>
+	<triggers>
+		<button name="z" type="digital" label="30014"/>
+	</triggers>
+	<analogsticks>
+		<analogstick name="analogstick" label="30015"/>
+	</analogsticks>
+</layout>
diff --git a/addons/game.controller.n64/resources/language/resource.language.en_gb/strings.po b/addons/game.controller.n64/resources/language/resource.language.en_gb/strings.po
new file mode 100644
index 0000000..2d3a663
--- /dev/null
+++ b/addons/game.controller.n64/resources/language/resource.language.en_gb/strings.po
@@ -0,0 +1,81 @@
+# XBMC Media Center language file
+# Addon Name: N64 controller
+# Addon id: gameclient.controller.n64
+# Addon Provider: Libretro Team
+msgid ""
+msgstr ""
+"Project-Id-Version: Libretro Clients\n"
+"Report-Msgid-Bugs-To: alanwww1@xbmc.org\n"
+"POT-Creation-Date: 2014-05-30 17:00+8\n"
+"PO-Revision-Date: 2014-05-30 17:00+8\n"
+"Last-Translator: XBMC Translation Team\n"
+"Language-Team: English (http://www.transifex.com/projects/p/xbmc-addons/language/en/)\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Language: en\n"
+"Plural-Forms: nplurals=2; plural=(n != 1);\n"
+
+msgctxt "#30000"
+msgid "Nintendo 64"
+msgstr ""
+
+msgctxt "#30001"
+msgid "A"
+msgstr ""
+
+msgctxt "#30002"
+msgid "B"
+msgstr ""
+
+msgctxt "#30003"
+msgid "Start"
+msgstr ""
+
+msgctxt "#30004"
+msgid "C-Up"
+msgstr ""
+
+msgctxt "#30005"
+msgid "C-Down"
+msgstr ""
+
+msgctxt "#30006"
+msgid "C-Right"
+msgstr ""
+
+msgctxt "#30007"
+msgid "C-Left"
+msgstr ""
+
+msgctxt "#30008"
+msgid "Up"
+msgstr ""
+
+msgctxt "#30009"
+msgid "Down"
+msgstr ""
+
+msgctxt "#30010"
+msgid "Right"
+msgstr ""
+
+msgctxt "#30011"
+msgid "Left"
+msgstr ""
+
+msgctxt "#30012"
+msgid "Left Bumper"
+msgstr ""
+
+msgctxt "#30013"
+msgid "Right Bumper"
+msgstr ""
+
+msgctxt "#30014"
+msgid "Z"
+msgstr ""
+
+msgctxt "#30015"
+msgid "Analog Stick"
+msgstr ""
diff --git a/addons/game.controller.nes/addon.xml b/addons/game.controller.nes/addon.xml
new file mode 100644
index 0000000..b02fbd2
--- /dev/null
+++ b/addons/game.controller.nes/addon.xml
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
+<addon id="game.controller.nes"
+        name="NES Controller"
+        version="1.0.1"
+        provider-name="garbear">
+    <requires>
+    </requires>
+    <extension point="kodi.game.controller" library="layout.xml"/>
+    <extension point="xbmc.addon.metadata">
+        <summary>NES controller</summary>
+        <description>The game controller used for both the NES and the Famicom features a simple four button layout and a cross-shaped joypad.</description>
+        <disclaimer></disclaimer>
+        <platform>all</platform>
+        <nofanart>true</nofanart>
+    </extension>
+</addon>
diff --git a/addons/game.controller.nes/button-costmap.png b/addons/game.controller.nes/button-costmap.png
new file mode 100644
index 0000000..9ffc4bc
Binary files /dev/null and b/addons/game.controller.nes/button-costmap.png differ
diff --git a/addons/game.controller.nes/icon.png b/addons/game.controller.nes/icon.png
new file mode 100644
index 0000000..4778fed
Binary files /dev/null and b/addons/game.controller.nes/icon.png differ
diff --git a/addons/game.controller.nes/layout.png b/addons/game.controller.nes/layout.png
new file mode 100644
index 0000000..dc7fdb9
Binary files /dev/null and b/addons/game.controller.nes/layout.png differ
diff --git a/addons/game.controller.nes/layout.xml b/addons/game.controller.nes/layout.xml
new file mode 100644
index 0000000..4660f9e
--- /dev/null
+++ b/addons/game.controller.nes/layout.xml
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
+<layout name="NES" label="30000" image="layout.png" costmap="button-costmap.png" width="558" height="262">
+	<face>
+		<button name="a" type="digital" label="30001" geometry="circle" x="466" y="164" radius="25"/>
+		<button name="b" type="digital" label="30002" geometry="circle" x="400" y="164" radius="25"/>
+		<button name="start" type="digital" label="30003" geometry="rectangle" x1="287" y1="175" x2="335" y2="189"/>
+		<button name="select" type="digital" label="30004" geometry="rectangle" x1="223" y1="175" x2="271" y2="189"/>
+		<button name="up" type="digital" label="30005" geometry="rectangle" x1="101" y1="92" x2="141" y2="128"/>
+		<button name="down" type="digital" label="30006" geometry="rectangle" x1="101" y1="160" x2="141" y2="194"/>
+		<button name="right" type="digital" label="30007" geometry="rectangle" x1="139" y1="126" x2="172" y2="162"/>
+		<button name="left" type="digital" label="30008" geometry="rectangle" x1="70" y1="126" x2="103" y2="162"/>
+	</face>
+</layout>
diff --git a/addons/game.controller.nes/resources/language/resource.language.en_gb/strings.po b/addons/game.controller.nes/resources/language/resource.language.en_gb/strings.po
new file mode 100644
index 0000000..290bda1
--- /dev/null
+++ b/addons/game.controller.nes/resources/language/resource.language.en_gb/strings.po
@@ -0,0 +1,53 @@
+# XBMC Media Center language file
+# Addon Name: NES Controller
+# Addon id: game.controller.nes
+# Addon Provider: Team-Kodi
+msgid ""
+msgstr ""
+"Project-Id-Version: Libretro Clients\n"
+"Report-Msgid-Bugs-To: alanwww1@xbmc.org\n"
+"POT-Creation-Date: 2014-05-30 17:00+8\n"
+"PO-Revision-Date: 2014-05-30 17:00+8\n"
+"Last-Translator: XBMC Translation Team\n"
+"Language-Team: English (http://www.transifex.com/projects/p/xbmc-addons/language/en/)\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Language: en\n"
+"Plural-Forms: nplurals=2; plural=(n != 1);\n"
+
+msgctxt "#30000"
+msgid "NES"
+msgstr ""
+
+msgctxt "#30001"
+msgid "A"
+msgstr ""
+
+msgctxt "#30002"
+msgid "B"
+msgstr ""
+
+msgctxt "#30003"
+msgid "Start"
+msgstr ""
+
+msgctxt "#30004"
+msgid "Select"
+msgstr ""
+
+msgctxt "#30005"
+msgid "Up"
+msgstr ""
+
+msgctxt "#30006"
+msgid "Down"
+msgstr ""
+
+msgctxt "#30007"
+msgid "Right"
+msgstr ""
+
+msgctxt "#30008"
+msgid "Left"
+msgstr ""
diff --git a/addons/game.controller.ps/addon.xml b/addons/game.controller.ps/addon.xml
new file mode 100644
index 0000000..be1377f
--- /dev/null
+++ b/addons/game.controller.ps/addon.xml
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
+<addon id="game.controller.ps"
+        name="PS Controller"
+        version="1.0.1"
+        provider-name="garbear">
+    <requires>
+    </requires>
+    <extension point="kodi.game.controller" library="layout.xml"/>
+    <extension point="xbmc.addon.metadata">
+        <summary>PS controller</summary>
+        <description>The PlayStation Controller was a gamepad for the PlayStation. It was released by Sony Computer Entertainment in 1994.</description>
+        <disclaimer></disclaimer>
+        <platform>all</platform>
+        <nofanart>true</nofanart>
+    </extension>
+</addon>
diff --git a/addons/game.controller.ps/icon.png b/addons/game.controller.ps/icon.png
new file mode 100644
index 0000000..1ebe42e
Binary files /dev/null and b/addons/game.controller.ps/icon.png differ
diff --git a/addons/game.controller.ps/layout.png b/addons/game.controller.ps/layout.png
new file mode 100644
index 0000000..419feee
Binary files /dev/null and b/addons/game.controller.ps/layout.png differ
diff --git a/addons/game.controller.ps/layout.xml b/addons/game.controller.ps/layout.xml
new file mode 100644
index 0000000..0561eae
--- /dev/null
+++ b/addons/game.controller.ps/layout.xml
@@ -0,0 +1,29 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
+<layout name="PS" label="30000" image="layout.png">
+	<face>
+		<button name="cross" type="digital" label="30001"/>
+		<button name="circle" type="digital" label="30002"/>
+		<button name="square" type="digital" label="30003"/>
+		<button name="triangle" type="digital" label="30004"/>
+		<button name="start" type="digital" label="30005"/>
+		<button name="select" type="digital" label="30006"/>
+		<button name="up" type="digital" label="30007" direction="up"/>
+		<button name="down" type="digital" label="30008" direction="down"/>
+		<button name="right" type="digital" label="30009" direction="right"/>
+		<button name="left" type="digital" label="30010" direction="left"/>
+		<button name="l3" type="digital" label="30011"/>
+		<button name="r3" type="digital" label="30012"/>
+	</face>
+	<shoulder>
+		<button name="leftbumper" type="digital" label="30013"/>
+		<button name="rightbumper" type="digital" label="30014"/>
+	</shoulder>
+	<triggers>
+		<button name="lefttrigger" type="digital" label="30015"/>
+		<button name="righttrigger" type="digital" label="30016"/>
+	</triggers>
+	<analogsticks>
+		<analogstick name="leftstick" label="30011"/>
+		<analogstick name="rightstick" label="30012"/>
+	</analogsticks>
+</layout>
diff --git a/addons/game.controller.ps/resources/language/resource.language.en_gb/strings.po b/addons/game.controller.ps/resources/language/resource.language.en_gb/strings.po
new file mode 100644
index 0000000..670a99b
--- /dev/null
+++ b/addons/game.controller.ps/resources/language/resource.language.en_gb/strings.po
@@ -0,0 +1,85 @@
+# XBMC Media Center language file
+# Addon Name: PS Controller
+# Addon id: game.controller.ps
+# Addon Provider: Team-Kodi
+msgid ""
+msgstr ""
+"Project-Id-Version: Libretro Clients\n"
+"Report-Msgid-Bugs-To: alanwww1@xbmc.org\n"
+"POT-Creation-Date: 2014-05-30 17:00+8\n"
+"PO-Revision-Date: 2014-05-30 17:00+8\n"
+"Last-Translator: XBMC Translation Team\n"
+"Language-Team: English (http://www.transifex.com/projects/p/xbmc-addons/language/en/)\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Language: en\n"
+"Plural-Forms: nplurals=2; plural=(n != 1);\n"
+
+msgctxt "#30000"
+msgid "PlayStation"
+msgstr ""
+
+msgctxt "#30001"
+msgid "Cross"
+msgstr ""
+
+msgctxt "#30002"
+msgid "Circle"
+msgstr ""
+
+msgctxt "#30003"
+msgid "Square"
+msgstr ""
+
+msgctxt "#30004"
+msgid "Triangle"
+msgstr ""
+
+msgctxt "#30005"
+msgid "Start"
+msgstr ""
+
+msgctxt "#30006"
+msgid "Select"
+msgstr ""
+
+msgctxt "#30007"
+msgid "Up"
+msgstr ""
+
+msgctxt "#30008"
+msgid "Down"
+msgstr ""
+
+msgctxt "#30009"
+msgid "Right"
+msgstr ""
+
+msgctxt "#30010"
+msgid "Left"
+msgstr ""
+
+msgctxt "#30011"
+msgid "Left Stick"
+msgstr ""
+
+msgctxt "#30012"
+msgid "Right Stick"
+msgstr ""
+
+msgctxt "#30013"
+msgid "L1"
+msgstr ""
+
+msgctxt "#30014"
+msgid "R1"
+msgstr ""
+
+msgctxt "#30015"
+msgid "L2"
+msgstr ""
+
+msgctxt "#30016"
+msgid "R2"
+msgstr ""
diff --git a/addons/game.controller.snes/addon.xml b/addons/game.controller.snes/addon.xml
new file mode 100644
index 0000000..25a1097
--- /dev/null
+++ b/addons/game.controller.snes/addon.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
+<addon id="game.controller.snes"
+        name="SNES Controller"
+        version="1.0.1"
+        provider-name="garbear">
+    <requires>
+    </requires>
+    <extension point="kodi.game.controller" library="layout.xml"/>
+    <extension point="xbmc.addon.metadata">
+        <summary>SNES controller</summary>
+        <description>The SNES controller adds two additional face buttons (X and Y) to the NES iteration, as well as two shoulder buttons.
+
+layout.png credit: Alphathon (alphathon.deviantart.com)</description>
+        <disclaimer></disclaimer>
+        <platform>all</platform>
+        <nofanart>true</nofanart>
+    </extension>
+</addon>
diff --git a/addons/game.controller.snes/icon.png b/addons/game.controller.snes/icon.png
new file mode 100644
index 0000000..22c48df
Binary files /dev/null and b/addons/game.controller.snes/icon.png differ
diff --git a/addons/game.controller.snes/layout.png b/addons/game.controller.snes/layout.png
new file mode 100644
index 0000000..a6f0062
Binary files /dev/null and b/addons/game.controller.snes/layout.png differ
diff --git a/addons/game.controller.snes/layout.xml b/addons/game.controller.snes/layout.xml
new file mode 100644
index 0000000..4b1d4c7
--- /dev/null
+++ b/addons/game.controller.snes/layout.xml
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
+<layout name="SNES" label="30000" image="layout.png">
+  <face>
+    <button name="a" type="digital" label="30001"/>
+    <button name="b" type="digital" label="30002"/>
+    <button name="x" type="digital" label="30003"/>
+    <button name="y" type="digital" label="30004"/>
+    <button name="start" type="digital" label="30005"/>
+    <button name="select" type="digital" label="30006"/>
+    <button name="up" type="digital" label="30007" direction="up"/>
+    <button name="down" type="digital" label="30008" direction="down"/>
+    <button name="right" type="digital" label="30009" direction="right"/>
+    <button name="left" type="digital" label="30010" direction="left"/>
+  </face>
+  <shoulder>
+    <button name="leftbumper" type="digital" label="30011"/>
+    <button name="rightbumper" type="digital" label="30012"/>
+  </shoulder>
+</layout>
diff --git a/addons/game.controller.snes/resources/language/resource.language.en_gb/strings.po b/addons/game.controller.snes/resources/language/resource.language.en_gb/strings.po
new file mode 100644
index 0000000..7d454bf
--- /dev/null
+++ b/addons/game.controller.snes/resources/language/resource.language.en_gb/strings.po
@@ -0,0 +1,69 @@
+# XBMC Media Center language file
+# Addon Name: SNES Controller
+# Addon id: game.controller.snes
+# Addon Provider: Team-Kodi
+msgid ""
+msgstr ""
+"Project-Id-Version: Libretro Clients\n"
+"Report-Msgid-Bugs-To: alanwww1@xbmc.org\n"
+"POT-Creation-Date: 2014-05-30 17:00+8\n"
+"PO-Revision-Date: 2014-05-30 17:00+8\n"
+"Last-Translator: XBMC Translation Team\n"
+"Language-Team: English (http://www.transifex.com/projects/p/xbmc-addons/language/en/)\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=UTF-8\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Language: en\n"
+"Plural-Forms: nplurals=2; plural=(n != 1);\n"
+
+msgctxt "#30000"
+msgid "Super Nintendo"
+msgstr ""
+
+msgctxt "#30001"
+msgid "A"
+msgstr ""
+
+msgctxt "#30002"
+msgid "B"
+msgstr ""
+
+msgctxt "#30003"
+msgid "X"
+msgstr ""
+
+msgctxt "#30004"
+msgid "Y"
+msgstr ""
+
+msgctxt "#30005"
+msgid "Start"
+msgstr ""
+
+msgctxt "#30006"
+msgid "Select"
+msgstr ""
+
+msgctxt "#30007"
+msgid "Up"
+msgstr ""
+
+msgctxt "#30008"
+msgid "Down"
+msgstr ""
+
+msgctxt "#30009"
+msgid "Right"
+msgstr ""
+
+msgctxt "#30010"
+msgid "Left"
+msgstr ""
+
+msgctxt "#30011"
+msgid "Left Bumper"
+msgstr ""
+
+msgctxt "#30012"
+msgid "Right Bumper"
+msgstr ""
diff --git a/addons/kodi.game/addon.xml b/addons/kodi.game/addon.xml
index 44f2ca5..6846baa 100644
--- a/addons/kodi.game/addon.xml
+++ b/addons/kodi.game/addon.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<addon id="kodi.game" version="1.0.14" provider-name="Team-Kodi">
-	<backwards-compatibility abi="1.0.14"/>
+<addon id="kodi.game" version="1.0.15" provider-name="Team-Kodi">
+	<backwards-compatibility abi="1.0.15"/>
 	<requires>
 		<import addon="xbmc.core" version="0.1.0"/>
 	</requires>
diff --git a/addons/kodi.inputstream/addon.xml b/addons/kodi.inputstream/addon.xml
index 155a900..092ab54 100644
--- a/addons/kodi.inputstream/addon.xml
+++ b/addons/kodi.inputstream/addon.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<addon id="kodi.inputstream" version="1.0.4" provider-name="Team Kodi">
-  <backwards-compatibility abi="1.0.4"/>
+<addon id="kodi.inputstream" version="1.0.3" provider-name="Team Kodi">
+  <backwards-compatibility abi="1.0.3"/>
   <requires>
     <import addon="xbmc.core" version="0.1.0"/>
   </requires>
diff --git a/addons/library.kodi.game/.gitignore b/addons/library.kodi.game/.gitignore
new file mode 100644
index 0000000..76bedae
--- /dev/null
+++ b/addons/library.kodi.game/.gitignore
@@ -0,0 +1,5 @@
+# Ignore everything in this directory
+*
+# Except this file
+!.gitignore
+
diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index 2153e2a..2ca88cb 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -5101,12 +5101,7 @@ msgctxt "#12013"
 msgid "Install date"
 msgstr ""
 
-#: xbmc/addons/GUIViewStateAddonBrowser.cpp
-msgctxt "#12014"
-msgid "Last updated"
-msgstr ""
-
-#empty strings from id 12015 to 12020
+#empty strings from id 12014 to 12020
 
 #. Label of various controls for starting playback from the beginning
 #: xbmc/Autorun.cpp
@@ -7503,6 +7498,7 @@ msgctxt "#15015"
 msgid "Remove"
 msgstr ""
 
+#: system/settings/settings.xml
 #: xbmc/settings/dialogs/GUIDialogAudioDSPSettings.cpp
 msgctxt "#15016"
 msgid "Games"
@@ -7633,7 +7629,15 @@ msgctxt "#15047"
 msgid "Audio DSP settings"
 msgstr ""
 
-#empty strings from id 15048 to 15049
+#: xbmc/cores/AudioEngine/DSPAddons/ActiveAEDSP.cpp
+msgctxt "#15048"
+msgid "No audio DSP add-on enabled"
+msgstr ""
+
+#: xbmc/cores/AudioEngine/DSPAddons/ActiveAEDSP.cpp
+msgctxt "#15049"
+msgid "The audio DSP manager has been enabled without any enabled DSP add-on. Enable at least one add-on in order to use the DSP functionality."
+msgstr ""
 
 #. Name of a list with amount of entries behind on GUI
 msgctxt "#15050"
@@ -7769,6 +7773,7 @@ msgid "Post-process"
 msgstr ""
 
 #. Audio DSP process chain indication
+#: system/settings.xml
 #: xbmc/settings/dialogs/GUIDialogAudioDSPSettings.cpp
 msgctxt "#15087"
 msgid "Input"
@@ -9757,7 +9762,17 @@ msgctxt "#19272"
 msgid "You need a tuner, backend software, and an add-on for the backend to be able to use PVR. Please visit http://kodi.wiki/view/PVR to learn more."
 msgstr ""
 
-#empty strings from id 19273 to 19274
+#. Header on DialogOK
+#: xbmc/cores/AudioEngine/DSPAddons/ActiveAEDSP.cpp
+msgctxt "#19273"
+msgid "No audio DSP add-ons could be found"
+msgstr ""
+
+#. DialogOK for no installed ADSP add-on available
+#: xbmc/cores/AudioEngine/DSPAddons/ActiveAEDSP.cpp
+msgctxt "#19274"
+msgid "You need an add-on installed to be able to use audio digital signal processing (DSP)."
+msgstr ""
 
 #: xbmc/pvr/timers/PVRTimerInfoTag.cpp
 msgctxt "#19275"
@@ -10941,7 +10956,12 @@ msgctxt "#20126"
 msgid "Log off"
 msgstr ""
 
-#empty string from id 20127 to 20128
+#empty string with id 20127
+
+#: xbmc/windows/GUIWindowFileManager.cpp
+msgctxt "#20128"
+msgid "Go to root"
+msgstr ""
 
 #: xbmc/video/dialogs/GUIDialogVideoSettings.cpp
 msgctxt "#20129"
@@ -13410,11 +13430,7 @@ msgctxt "#24003"
 msgid "Add-on information"
 msgstr ""
 
-#. Name of menu in the add-on browser
-#: xbmc/filesystem/AddonsDirectory.cpp
-msgctxt "#24004"
-msgid "Recently updated"
-msgstr ""
+#empty string with id 24004
 
 #: xbmc/addons/Addon.cpp
 msgctxt "#24005"
@@ -14786,49 +14802,7 @@ msgctxt "#29987"
 msgid "Send present traffic messages around and can be handled from add-ons (nothing inside Kodi)"
 msgstr ""
 
-#. Music role category
-#: system/library/music/musicroles/Arrangers.xml
-msgctxt "#29988"
-msgid "Arrangers"
-msgstr ""
-
-#. Music role category
-#: system/library/music/musicroles/Composers.xml
-msgctxt "#29989"
-msgid "Composers"
-msgstr ""
-
-#. Music role category
-#: system/library/music/musicroles/Conductors.xml
-msgctxt "#29990"
-msgid "Conductors"
-msgstr ""
-
-#. Music role category
-#: system/library/music/musicroles/DJ.xml
-msgctxt "#29991"
-msgid "DJ Mixers"
-msgstr ""
-
-#. Music role category
-#: system/library/music/musicroles/Lyricists.xml
-msgctxt "#29992"
-msgid "Lyricists"
-msgstr ""
-
-#. Music role category
-#: system/library/music/musicroles/Orchestras.xml
-msgctxt "#29993"
-msgid "Orchestras"
-msgstr ""
-
-#. Roles from music contributor
-#: system/library/music/musicroles/index.xml
-msgctxt "#29994"
-msgid "Roles"
-msgstr ""
-
-#empty strings from id 29995 to 33000
+#empty strings from id 29988 to 33000
 #strings 30000 thru 30999 reserved for plug-ins and plug-in settings
 #strings 31000 thru 31999 reserved for skins
 #strings 32000 thru 32999 reserved for scripts
@@ -15514,7 +15488,7 @@ msgstr ""
 #empty strings from id 35011 to 35048
 
 #. Name of game add-ons category
-#: xbmc/filesystem/AddonsDirectory.cpp
+#: xbmc/addons/Addon.cpp
 msgctxt "#35049"
 msgid "Game add-ons"
 msgstr ""
@@ -15589,7 +15563,53 @@ msgctxt "#35064"
 msgid "Pair your controllers with the various input devices of different game systems."
 msgstr ""
 
-#empty strings from id 35065 to 35089
+#: system/settings/settings.xml
+msgctxt "#35065"
+msgid "%i"
+msgstr ""
+
+#: system/settings/settings.xml
+msgctxt "#35066"
+msgid "Number of emulated controllers"
+msgstr ""
+
+#: system/settings/settings.xml
+msgctxt "#35067"
+msgid "Emulated controllers let you control additional players using the keyboard. This is intended for devices that use keyboard drivers, but you can also see how many people fit around a keyboard!"
+msgstr ""
+
+#: system/settings/settings.xml
+msgctxt "#35067"
+msgid "Configure input for game add-ons."
+msgstr ""
+
+#: system/settings/settings.xml
+msgctxt "#35069"
+msgid "Configure keyboard player 1"
+msgstr ""
+
+#: system/settings/settings.xml
+msgctxt "#35070"
+msgid "Configure keyboard player 2"
+msgstr ""
+
+#: system/settings/settings.xml
+msgctxt "#35071"
+msgid "Configure keyboard player 3"
+msgstr ""
+
+#: system/settings/settings.xml
+msgctxt "#35072"
+msgid "Configure keyboard player 4"
+msgstr ""
+
+#. Name of the emulated controller in the list of peripherals
+#: xbmc/peripherals/bus/virtual/PeripheralBusApplication.cpp
+msgctxt "#35073"
+msgid "Emulated controller"
+msgstr ""
+
+#empty strings from id 35074 to 35089
 
 #. Button prompt without timeout. %s - button name
 #: xbmc/games/controllers/guicontrols/GUIScalarFeatureButton.cpp
@@ -15663,7 +15683,63 @@ msgctxt "#35102"
 msgid "Disable joystick when this device is present"
 msgstr ""
 
-#empty strings from id 35103 to 35504
+#empty strings from id 35103 to 35199
+
+#: system/settings/settings.xml
+msgctxt "#35200"
+msgid "ALL YOUR BASE ARE BELONG[CR]TO US"
+msgstr ""
+
+#: system/settings/settings.xml
+msgctxt "#35201"
+msgid "Configure input for game add-ons."
+msgstr ""
+
+#. Description of settings category "Games -> General" with label #16000
+#: system/settings/settings.xml
+msgctxt "#35202"
+msgid "No info available yet."
+msgstr ""
+
+#: system/settings/settings.xml
+msgctxt "#35203"
+msgid "Enable rewind if supported"
+msgstr ""
+
+#: system/settings/settings.xml
+msgctxt "#35204"
+msgid "Enable real-time rewinding during game play, if supported. Press rewind or manually seek backwards using the seek bar."
+msgstr ""
+
+#: system/settings/settings.xml
+msgctxt "#35205"
+msgid "Maximum rewind time"
+msgstr ""
+
+#: system/settings/settings.xml
+msgctxt "#35206"
+msgid "Maximum time possible to rewind, if supported. Large rewind histories can use a lot of RAM."
+msgstr ""
+
+#. Description of add-on category for emulators
+#: xbmc/filesystem/AddonsDirectory.cpp
+msgctxt "#35207"
+msgid "Emulators"
+msgstr ""
+
+#. Description of add-on category for standalone games
+#: xbmc/filesystem/AddonsDirectory.cpp
+msgctxt "#35208"
+msgid "Standalone games"
+msgstr ""
+
+#. Description of add-on category for game providers
+#: xbmc/filesystem/AddonsDirectory.cpp
+msgctxt "#35209"
+msgid "Game providers"
+msgstr ""
+
+#empty strings from id 35210 to 35504
 
 #. connection state "host unreachable"
 #: xbmc/addons/AddonCallbacksPVR.cpp
@@ -18696,32 +18772,32 @@ msgstr ""
 #. Remixer of the song (if present)
 msgctxt "#38036"
 msgid "Remixer"
-msgstr ""
+msgstr "" 
 
 #. Arranger of the song (if present)
 msgctxt "#38037"
 msgid "Arranger"
-msgstr ""
+msgstr "" 
 
 #. Engineer of the song (if present)
 msgctxt "#38038"
 msgid "Engineer"
-msgstr ""
+msgstr "" 
 
 #. Producer of the song (if present)
 msgctxt "#38039"
 msgid "Producer"
-msgstr ""
+msgstr "" 
 
 #. DJMixer of the song (if present)
 msgctxt "#38040"
 msgid "DJMixer"
-msgstr ""
+msgstr "" 
 
 #. Mixer of the song (if present)
 msgctxt "#38041"
 msgid "Mixer"
-msgstr ""
+msgstr "" 
 
 #. Missing artist name
 #: music/MusicDatabase.cpp
diff --git a/addons/skin.estouchy/addon.xml b/addons/skin.estouchy/addon.xml
index 951750d..9249d78 100644
--- a/addons/skin.estouchy/addon.xml
+++ b/addons/skin.estouchy/addon.xml
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<addon id="skin.estouchy" version="1.0.7" name="Estouchy" provider-name="Team Kodi">
+<addon id="skin.estouchy" version="1.0.6" name="Estouchy" provider-name="Team Kodi">
 	<requires>
 		<import addon="xbmc.gui" version="5.11.0"/>
 	</requires>
@@ -21,13 +21,9 @@
 		<summary lang="nl_NL">Skin voor aanraakscherm apparaten</summary>
 		<summary lang="pt_BR">Skin para dispositivos com telas de toque</summary>
 		<summary lang="sk_SK">Grafick vzhad pre zariadenia s dotykovm displejom</summary>
-		<summary lang="sr_RS">       </summary>
-		<summary lang="sr_RS@latin">Maska za ureaje sa ekranom osetljivim na dodir</summary>
 		<summary lang="sv_SE">Skin fr enheter med touchskrm</summary>
 		<summary lang="tr_TR">Dokunmatik ekranl aygtlar iin d grnm</summary>
-		<summary lang="zh_CN"></summary>
 		<description lang="cs_CZ">Skin navren pro zazen s dotykovou obrazovkou, jako jsou tablety a smartphony.</description>
-		<description lang="de_DE">Dieses Skin wurde fr die Benutzung mit Touchscreen-Gerten wie Tablets und Handys entworfen</description>
 		<description lang="en_GB">Skin designed to be used on touchscreen devices like tablets and smartphones</description>
 		<description lang="en_US">Skin designed to be used on touchscreen devices like tablets and smartphones</description>
 		<description lang="fr_FR">Habillage conu pour les appareils  cran tactile comme les tablettes et les tlphones</description>
@@ -38,10 +34,7 @@
 		<description lang="nl_NL">Skin ontworpen voor gebruik bij aanraakscherm apparaten zoals tablets en smartphones</description>
 		<description lang="pt_BR">Skin concebida para ser usada em dispositivos com telas de toque como tablets e smartphones</description>
 		<description lang="sk_SK">Grafick vzhad uren pre pouitie na dotykovch zariadeniach ako s tablety alebo mobiln telefny</description>
-		<description lang="sr_RS">                   </description>
-		<description lang="sr_RS@latin">Maska dizajnirana da bi bila koriena na ureajima sa ekranima osetljivim na dodir kao to su tableti i pametni telefoni</description>
 		<description lang="tr_TR">Bu d grnm tabletler ve akll telefonlar gibi dokunmatik ekranl aygtlarda kullanlmak zere tasarland</description>
-		<description lang="zh_CN"></description>
 		<platform>all</platform>
 		<license>Creative Commons Attribution-Share Alike 3.0 United States</license>
 		<forum>http://forum.kodi.tv/forumdisplay.php?fid=261</forum>
diff --git a/addons/skin.estouchy/changelog.txt b/addons/skin.estouchy/changelog.txt
index 9a84aa6..c3333dd 100644
--- a/addons/skin.estouchy/changelog.txt
+++ b/addons/skin.estouchy/changelog.txt
@@ -1,6 +1,3 @@
-V1.0.7
-- Updated language files from Transifex
-
 V1.0.6
 - Updated language files from Transifex
 
diff --git a/addons/skin.estouchy/language/resource.language.de_de/strings.po b/addons/skin.estouchy/language/resource.language.de_de/strings.po
index 18788a9..70a4422 100644
--- a/addons/skin.estouchy/language/resource.language.de_de/strings.po
+++ b/addons/skin.estouchy/language/resource.language.de_de/strings.po
@@ -44,10 +44,6 @@ msgctxt "#31009"
 msgid "Working..."
 msgstr "Verarbeitung..."
 
-msgctxt "#31011"
-msgid "Recent"
-msgstr "Krzlich"
-
 msgctxt "#31013"
 msgid "Movies"
 msgstr "Filme"
@@ -180,10 +176,6 @@ msgctxt "#31401"
 msgid "Manage your video library  Set video playback options  Change video listing options  Set subtitle fonts"
 msgstr "Verwalten Sie Ihre Videobibliothek - Videowiedergabeoptionen festlegen - Videoauflistungsoptionen ndern - Untertitelschriftarten festlegen"
 
-msgctxt "#31402"
-msgid "Manage your music library  Set music playback options  Change music listing options  Setup song submission"
-msgstr "Verwalte deine Musikbibliothek  Wiedergabe konfigurieren  Musik-Listen einrichten  Lieder einreichen "
-
 msgctxt "#31403"
 msgid "Set picture listing options  Configure slideshows"
 msgstr "Bildauflistungsoptionen festlegen - Bildvorfhrungen konfigurieren"
@@ -200,10 +192,6 @@ msgctxt "#31406"
 msgid "Setup and calibrate displays  Configure audio output  Setup remote controls  Set power saving options  Enable debugging  Setup master lock"
 msgstr "Bildschirm einrichten und kalibrieren - Audioausgabe konfigurieren - Fernbedienungen einrichten - Energiesparoptionen festlegen - Fehlersuche aktivieren - Hauptsperre einrichten"
 
-msgctxt "#31407"
-msgid "Manage your installed add-ons  Browse for and install add-ons from kodi.tv  Modify add-on settings"
-msgstr "Verwalte deine installierten Addons  Suche und installiere Addons von kodi.tv  ndere die Einstellungen der Addons "
-
 msgctxt "#31421"
 msgid "Select your Kodi user Profile[CR]to login and continue"
 msgstr "Whlen Sie Ihr Kodi-Benutzerprofil[CR]zum Anmelden und Fortfahren aus"
@@ -283,23 +271,3 @@ msgstr "Verborgene anzeigen"
 msgctxt "#31565"
 msgid "Show deleted"
 msgstr "Gelschte anzeigen"
-
-msgctxt "#31900"
-msgid "First Run"
-msgstr "Erster Start"
-
-msgctxt "#31901"
-msgid "There are two things to know about navigating Estouchy"
-msgstr "Zwei Dinge ber das Navigieren mit Estouchy"
-
-msgctxt "#31902"
-msgid "The Kodi logo functions as a 'HOME' button. Whenever you touch it, you will be taken back to the home screen."
-msgstr "Das Kodi-Logo fungiert als 'Home'-Knopf. Das Drcken bringt dich zurck zum Hauptbildschirm."
-
-msgctxt "#31903"
-msgid "When you are playing audio or video, the item title will appear at the top of the screen. Touching it will take you to the fullscreen visualization or video window."
-msgstr "Whrend Musik oder ein Video spielt, erscheint der Titel am oberen Bildschirmrand. Das Tippen des Titels aktiviert die Vollbild-Wiedergabe."
-
-msgctxt "#31904"
-msgid "Now Playing Title..."
-msgstr "Laufender Titel..."
diff --git a/addons/skin.estouchy/language/resource.language.sr_rs/strings.po b/addons/skin.estouchy/language/resource.language.sr_rs/strings.po
index 1563332..753f913 100644
--- a/addons/skin.estouchy/language/resource.language.sr_rs/strings.po
+++ b/addons/skin.estouchy/language/resource.language.sr_rs/strings.po
@@ -16,38 +16,14 @@ msgstr ""
 "Language: sr_RS\n"
 "Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
 
-msgctxt "#31002"
-msgid "Audio Settings"
-msgstr " "
-
-msgctxt "#31003"
-msgid "IP"
-msgstr "IP"
-
-msgctxt "#31004"
-msgid "Caps[CR]Lock"
-msgstr "[CR]"
-
-msgctxt "#31005"
-msgid "Visualization Options"
-msgstr " "
-
 msgctxt "#31006"
 msgid "Visualization Presets"
-msgstr "  "
-
-msgctxt "#31007"
-msgid "Context Menu"
-msgstr " "
+msgstr " "
 
 msgctxt "#31009"
 msgid "Working..."
 msgstr "..."
 
-msgctxt "#31011"
-msgid "Recent"
-msgstr ""
-
 msgctxt "#31013"
 msgid "Movies"
 msgstr ""
@@ -64,18 +40,10 @@ msgctxt "#31024"
 msgid "Page"
 msgstr ""
 
-msgctxt "#31030"
-msgid "Info List"
-msgstr " "
-
 msgctxt "#31038"
 msgid "Login"
 msgstr ""
 
-msgctxt "#31039"
-msgid "Updated:"
-msgstr ":"
-
 msgctxt "#31044"
 msgid "FAST FORWARD"
 msgstr " "
@@ -86,27 +54,27 @@ msgstr " "
 
 msgctxt "#31049"
 msgid "End Time"
-msgstr " "
+msgstr " "
 
 msgctxt "#31050"
 msgid "Sort: Ascending"
-msgstr ": "
+msgstr " "
 
 msgctxt "#31051"
 msgid "Sort: Descending"
-msgstr ": "
+msgstr " "
 
 msgctxt "#31055"
 msgid "Open playlist"
-msgstr "   "
+msgstr "   "
 
 msgctxt "#31056"
 msgid "Save playlist"
-msgstr "   "
+msgstr "   "
 
 msgctxt "#31057"
 msgid "Close playlist"
-msgstr "   "
+msgstr "   "
 
 msgctxt "#31058"
 msgid "System music files"
@@ -114,7 +82,7 @@ msgstr "  "
 
 msgctxt "#31059"
 msgid "Current playlist"
-msgstr "   "
+msgstr "   "
 
 msgctxt "#31200"
 msgid "Back"
@@ -130,11 +98,11 @@ msgstr ""
 
 msgctxt "#31300"
 msgid "Current Temp"
-msgstr " T"
+msgstr " "
 
 msgctxt "#31301"
 msgid "Last Updated"
-msgstr " A"
+msgstr " "
 
 msgctxt "#31303"
 msgid "Data provider"
@@ -142,27 +110,19 @@ msgstr " "
 
 msgctxt "#31309"
 msgid "Memory Used:"
-msgstr " M:"
+msgstr " :"
 
 msgctxt "#31320"
 msgid "Last Logged In"
-msgstr " "
+msgstr " "
 
 msgctxt "#31322"
 msgid "Aired"
 msgstr ""
 
-msgctxt "#31355"
-msgid "Video Menu"
-msgstr " "
-
 msgctxt "#31356"
 msgid "Download Subtitles"
-msgstr " "
-
-msgctxt "#31358"
-msgid "Teletext"
-msgstr ""
+msgstr " "
 
 msgctxt "#31390"
 msgid "Skin default"
@@ -172,134 +132,22 @@ msgctxt "#31391"
 msgid "Arial based"
 msgstr "  Arial-"
 
-msgctxt "#31400"
-msgid "Change the skin  Set language and region  Change file listing options  Set up a screensaver"
-msgstr "       -     -   "
-
-msgctxt "#31401"
-msgid "Manage your video library  Set video playback options  Change video listing options  Set subtitle fonts"
-msgstr "         -     -   "
-
-msgctxt "#31402"
-msgid "Manage your music library  Set music playback options  Change music listing options  Setup song submission"
-msgstr "         -     -   "
-
-msgctxt "#31403"
-msgid "Set picture listing options  Configure slideshows"
-msgstr "       "
-
-msgctxt "#31404"
-msgid "Set three cities to collect weather information"
-msgstr "        "
-
-msgctxt "#31405"
-msgid "Setup control of Kodi via UPnP and HTTP  Configure file sharing  Set internet access options"
-msgstr "  Kodi  UPnP  HTTP     -    "
-
-msgctxt "#31406"
-msgid "Setup and calibrate displays  Configure audio output  Setup remote controls  Set power saving options  Enable debugging  Setup master lock"
-msgstr "        -    -     -       "
-
-msgctxt "#31407"
-msgid "Manage your installed add-ons  Browse for and install add-ons from kodi.tv  Modify add-on settings"
-msgstr "            kodi.tv -    "
-
 msgctxt "#31421"
 msgid "Select your Kodi user Profile[CR]to login and continue"
-msgstr "    [CR] ,    "
-
-msgctxt "#31500"
-msgid "Home Menu Catagory Buttons"
-msgstr "   "
-
-msgctxt "#31501"
-msgid "Home Page Add-on Quick Links"
-msgstr "     "
-
-msgctxt "#31502"
-msgid "Miscellaneous Options"
-msgstr " "
-
-msgctxt "#31550"
-msgid "Home Screen Weather Info and button"
-msgstr "      "
-
-msgctxt "#31551"
-msgid "Add-on Shortcut"
-msgstr "  "
-
-msgctxt "#31552"
-msgid "SYNC"
-msgstr "SYNC"
-
-msgctxt "#31553"
-msgid "Use Custom Background"
-msgstr "  "
-
-msgctxt "#31554"
-msgid "Background:"
-msgstr ":"
-
-msgctxt "#31555"
-msgid "Configure TV settings  Change full screen info  Manage EPG data settings"
-msgstr "   -         "
+msgstr "  Kodi [CR]  ,    "
 
 msgctxt "#31556"
 msgid "Live TV"
 msgstr " "
 
-msgctxt "#31557"
-msgid "Hide video background"
-msgstr "  "
-
-msgctxt "#31558"
-msgid "Hide visualization background"
-msgstr "   "
-
-msgctxt "#31559"
-msgid "Channel settings"
-msgstr " "
-
-msgctxt "#31560"
-msgid "Available groups"
-msgstr " "
-
 msgctxt "#31561"
 msgid "Add Group"
-msgstr " "
+msgstr " "
 
 msgctxt "#31562"
 msgid "Rename Group"
-msgstr " "
+msgstr " "
 
 msgctxt "#31563"
 msgid "Delete Group"
-msgstr " "
-
-msgctxt "#31564"
-msgid "Show hidden"
-msgstr " "
-
-msgctxt "#31565"
-msgid "Show deleted"
-msgstr " "
-
-msgctxt "#31900"
-msgid "First Run"
-msgstr " "
-
-msgctxt "#31901"
-msgid "There are two things to know about navigating Estouchy"
-msgstr "         Estouchy"
-
-msgctxt "#31902"
-msgid "The Kodi logo functions as a 'HOME' button. Whenever you touch it, you will be taken back to the home screen."
-msgstr "Kodi    '' .    ,     ."
-
-msgctxt "#31903"
-msgid "When you are playing audio or video, the item title will appear at the top of the screen. Touching it will take you to the fullscreen visualization or video window."
-msgstr "    ,        .             ."
-
-msgctxt "#31904"
-msgid "Now Playing Title..."
-msgstr "  ..."
+msgstr " "
diff --git a/addons/skin.estouchy/language/resource.language.sr_rs@latin/strings.po b/addons/skin.estouchy/language/resource.language.sr_rs@latin/strings.po
index ee723e9..62124e1 100644
--- a/addons/skin.estouchy/language/resource.language.sr_rs@latin/strings.po
+++ b/addons/skin.estouchy/language/resource.language.sr_rs@latin/strings.po
@@ -16,38 +16,14 @@ msgstr ""
 "Language: sr_RS@latin\n"
 "Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
 
-msgctxt "#31002"
-msgid "Audio Settings"
-msgstr "Audio Podeavanja"
-
-msgctxt "#31003"
-msgid "IP"
-msgstr "IP"
-
-msgctxt "#31004"
-msgid "Caps[CR]Lock"
-msgstr "Veliina[CR]Slova"
-
-msgctxt "#31005"
-msgid "Visualization Options"
-msgstr "Opcije Vizuelizacije"
-
 msgctxt "#31006"
 msgid "Visualization Presets"
-msgstr "Unapred Zadate Vizualizacije"
-
-msgctxt "#31007"
-msgid "Context Menu"
-msgstr "Meni Opcija"
+msgstr "Postojee vizualizacije"
 
 msgctxt "#31009"
 msgid "Working..."
 msgstr "Obrada..."
 
-msgctxt "#31011"
-msgid "Recent"
-msgstr "Skoranje"
-
 msgctxt "#31013"
 msgid "Movies"
 msgstr "Filmovi"
@@ -64,18 +40,10 @@ msgctxt "#31024"
 msgid "Page"
 msgstr "Strana"
 
-msgctxt "#31030"
-msgid "Info List"
-msgstr "Lista Informacija"
-
 msgctxt "#31038"
 msgid "Login"
 msgstr "Prijava"
 
-msgctxt "#31039"
-msgid "Updated:"
-msgstr "Aurirano:"
-
 msgctxt "#31044"
 msgid "FAST FORWARD"
 msgstr "PREMOTAVANjE UNAPRED"
@@ -98,15 +66,15 @@ msgstr "Sloi: Silazno"
 
 msgctxt "#31055"
 msgid "Open playlist"
-msgstr "Otvori listu za reprodukciju"
+msgstr "Otvori spisak za reprodukciju"
 
 msgctxt "#31056"
 msgid "Save playlist"
-msgstr "Sauvaj listu za reprodukciju"
+msgstr "Sauvaj spisak za reprodukciju"
 
 msgctxt "#31057"
 msgid "Close playlist"
-msgstr "Zatvori listu za reprodukciju"
+msgstr "Zatvori spisak za reprodukciju"
 
 msgctxt "#31058"
 msgid "System music files"
@@ -114,7 +82,7 @@ msgstr "Sistemske muzike datoteke"
 
 msgctxt "#31059"
 msgid "Current playlist"
-msgstr "Trenutna lista za reprodukciju"
+msgstr "Trenutni spisak za reprodukciju"
 
 msgctxt "#31200"
 msgid "Back"
@@ -152,13 +120,9 @@ msgctxt "#31322"
 msgid "Aired"
 msgstr "Emitovano"
 
-msgctxt "#31355"
-msgid "Video Menu"
-msgstr "Video Meni"
-
 msgctxt "#31356"
 msgid "Download Subtitles"
-msgstr "Preuzmi Titlove"
+msgstr "Preuzmi titlove"
 
 msgctxt "#31358"
 msgid "Teletext"
@@ -172,94 +136,14 @@ msgctxt "#31391"
 msgid "Arial based"
 msgstr "Zasnovano na Arialu"
 
-msgctxt "#31400"
-msgid "Change the skin  Set language and region  Change file listing options  Set up a screensaver"
-msgstr "Promenite masku  Postavite jezik i regiju - Promenite opcije izlistavanja datoteka - Postavite uvara ekrana"
-
-msgctxt "#31401"
-msgid "Manage your video library  Set video playback options  Change video listing options  Set subtitle fonts"
-msgstr "Upravljajte vaom video bibliotekom  Postavite opcije video reprodukcije - Promenite opcije izlistavanja filmova - Postavite slova titlova"
-
-msgctxt "#31402"
-msgid "Manage your music library  Set music playback options  Change music listing options  Setup song submission"
-msgstr "Upravljajte vaom muzikom bibliotekom  Postavite opcije reprodukcije muzike - Promenite opcije izlistavanja muzike - Postavite slanje pesama"
-
-msgctxt "#31403"
-msgid "Set picture listing options  Configure slideshows"
-msgstr "Postavite opcije izlistavanja slika  Podesite reprodukciju slajdova"
-
-msgctxt "#31404"
-msgid "Set three cities to collect weather information"
-msgstr "Postavite tri grada za prikupljanje informacija o vremenskim prilikama"
-
-msgctxt "#31405"
-msgid "Setup control of Kodi via UPnP and HTTP  Configure file sharing  Set internet access options"
-msgstr "Podesite kontrolu Kodi putem UPnP i HTTP  Podesite deljenje datoteka - Postavite opcije internet pristupa"
-
-msgctxt "#31406"
-msgid "Setup and calibrate displays  Configure audio output  Setup remote controls  Set power saving options  Enable debugging  Setup master lock"
-msgstr "Podesite i kalibriite ekrane  Podesite zvuni izlaz - Podesite daljinsko upravljanje - Postavite opcije utede energije - Omoguite evidenciju greaka  Podesite glavnu lozinku"
-
-msgctxt "#31407"
-msgid "Manage your installed add-ons  Browse for and install add-ons from kodi.tv  Modify add-on settings"
-msgstr "Upravljajte vaim instaliranim dodatnim programima  Potraite i instalirajte dodatne programe sa kodi.tv - Podesite podeavanja dodatnih programa"
-
 msgctxt "#31421"
 msgid "Select your Kodi user Profile[CR]to login and continue"
-msgstr "Izaberite va Kodi korisniki Profil[CR]za prijavu, a potom nastavite dalje"
-
-msgctxt "#31500"
-msgid "Home Menu Catagory Buttons"
-msgstr "Tasteri Kategorije Glavnog Menija"
-
-msgctxt "#31501"
-msgid "Home Page Add-on Quick Links"
-msgstr "Brzi Linkovi Dodatnih Programa Glavnog Ekrana"
-
-msgctxt "#31502"
-msgid "Miscellaneous Options"
-msgstr "Razne Opcije"
-
-msgctxt "#31550"
-msgid "Home Screen Weather Info and button"
-msgstr "Informacije Vremenske Prognoze Glavnog Ekrana i taster"
-
-msgctxt "#31551"
-msgid "Add-on Shortcut"
-msgstr "Preica Dodatnog Programa"
-
-msgctxt "#31552"
-msgid "SYNC"
-msgstr "SYNC"
-
-msgctxt "#31553"
-msgid "Use Custom Background"
-msgstr "Koristi Prilagoenu Pozadinu"
-
-msgctxt "#31554"
-msgid "Background:"
-msgstr "Pozadina:"
-
-msgctxt "#31555"
-msgid "Configure TV settings  Change full screen info  Manage EPG data settings"
-msgstr "Podesite TV podeavanja - Promenite informacije celog ekrana  Upravljajte podeavanjima EPG podataka"
+msgstr "Izaberite va Kodi korisniki[CR]profil za prijavu, a potom nastavite dalje"
 
 msgctxt "#31556"
 msgid "Live TV"
 msgstr " "
 
-msgctxt "#31557"
-msgid "Hide video background"
-msgstr "Sakrij video pozadinu"
-
-msgctxt "#31558"
-msgid "Hide visualization background"
-msgstr "Sakrij vizuelizaciju u pozadini"
-
-msgctxt "#31559"
-msgid "Channel settings"
-msgstr "Podeavanja kanala"
-
 msgctxt "#31560"
 msgid "Available groups"
 msgstr "Dostupne grupe"
@@ -270,36 +154,8 @@ msgstr "Dodaj grupu"
 
 msgctxt "#31562"
 msgid "Rename Group"
-msgstr "Preimenuj Grupu"
+msgstr " "
 
 msgctxt "#31563"
 msgid "Delete Group"
-msgstr "Obrii Grupu"
-
-msgctxt "#31564"
-msgid "Show hidden"
-msgstr "Prikai skriveno"
-
-msgctxt "#31565"
-msgid "Show deleted"
-msgstr "Prikai izbrisano"
-
-msgctxt "#31900"
-msgid "First Run"
-msgstr "Prvo pokretanje"
-
-msgctxt "#31901"
-msgid "There are two things to know about navigating Estouchy"
-msgstr "Postoje dve stvari koje treba znati o navigaciji u Estouchy"
-
-msgctxt "#31902"
-msgid "The Kodi logo functions as a 'HOME' button. Whenever you touch it, you will be taken back to the home screen."
-msgstr "Kodi logo funkcionie kao 'GLAVNI' taster. Kad god ga dodirnete, biete odvedeni na glavni ekran."
-
-msgctxt "#31903"
-msgid "When you are playing audio or video, the item title will appear at the top of the screen. Touching it will take you to the fullscreen visualization or video window."
-msgstr "Kada putate audio ili video, naziv stavke e se pojaviti na vrhu ekrana. Ako ga dodirnete odvee vas do vizuelizacije preko celog ekrana ili video prozora."
-
-msgctxt "#31904"
-msgid "Now Playing Title..."
-msgstr "Naziv Sada Puteno..."
+msgstr " "
diff --git a/addons/skin.estouchy/language/resource.language.tr_tr/strings.po b/addons/skin.estouchy/language/resource.language.tr_tr/strings.po
index a800012..1a13569 100644
--- a/addons/skin.estouchy/language/resource.language.tr_tr/strings.po
+++ b/addons/skin.estouchy/language/resource.language.tr_tr/strings.po
@@ -44,10 +44,6 @@ msgctxt "#31009"
 msgid "Working..."
 msgstr "alyor..."
 
-msgctxt "#31011"
-msgid "Recent"
-msgstr "En Son"
-
 msgctxt "#31013"
 msgid "Movies"
 msgstr "Filmler"
@@ -72,10 +68,6 @@ msgctxt "#31038"
 msgid "Login"
 msgstr "Giri"
 
-msgctxt "#31039"
-msgid "Updated:"
-msgstr "Gncellendi"
-
 msgctxt "#31044"
 msgid "FAST FORWARD"
 msgstr "LER SAR"
@@ -230,7 +222,7 @@ msgstr "Eklenti Ksayolu"
 
 msgctxt "#31552"
 msgid "SYNC"
-msgstr "SYNC"
+msgstr "ETLEME"
 
 msgctxt "#31553"
 msgid "Use Custom Background"
@@ -276,30 +268,6 @@ msgctxt "#31563"
 msgid "Delete Group"
 msgstr "Grubu Sil"
 
-msgctxt "#31564"
-msgid "Show hidden"
-msgstr "Gizlileri gster"
-
-msgctxt "#31565"
-msgid "Show deleted"
-msgstr "Silinenleri gster"
-
 msgctxt "#31900"
 msgid "First Run"
 msgstr "lk altrma"
-
-msgctxt "#31901"
-msgid "There are two things to know about navigating Estouchy"
-msgstr "Estouchy'de gezinme hakknda bilmeniz gereken iki ey vardr."
-
-msgctxt "#31902"
-msgid "The Kodi logo functions as a 'HOME' button. Whenever you touch it, you will be taken back to the home screen."
-msgstr "Kodi logosu 'Giri Sayfas' dmesi olarak ilev grr. Logoya dokunduunuz zaman giri ekranna geri gidersiniz."
-
-msgctxt "#31903"
-msgid "When you are playing audio or video, the item title will appear at the top of the screen. Touching it will take you to the fullscreen visualization or video window."
-msgstr "Ses veya video oynatlrken, oynatlan enin bal ekrann st ksmnda grnr. Buna dokunmak sizi tam ekran grsel eye veya video penceresine gtrecektir."
-
-msgctxt "#31904"
-msgid "Now Playing Title..."
-msgstr "imdi Oynatlan enin Bal..."
diff --git a/addons/skin.estouchy/language/resource.language.zh_cn/strings.po b/addons/skin.estouchy/language/resource.language.zh_cn/strings.po
index 2a166df..a27ec8a 100644
--- a/addons/skin.estouchy/language/resource.language.zh_cn/strings.po
+++ b/addons/skin.estouchy/language/resource.language.zh_cn/strings.po
@@ -44,10 +44,6 @@ msgctxt "#31009"
 msgid "Working..."
 msgstr "..."
 
-msgctxt "#31011"
-msgid "Recent"
-msgstr ""
-
 msgctxt "#31013"
 msgid "Movies"
 msgstr ""
@@ -72,10 +68,6 @@ msgctxt "#31038"
 msgid "Login"
 msgstr ""
 
-msgctxt "#31039"
-msgid "Updated:"
-msgstr ""
-
 msgctxt "#31044"
 msgid "FAST FORWARD"
 msgstr ""
@@ -160,10 +152,6 @@ msgctxt "#31356"
 msgid "Download Subtitles"
 msgstr ""
 
-msgctxt "#31358"
-msgid "Teletext"
-msgstr ""
-
 msgctxt "#31390"
 msgid "Skin default"
 msgstr ""
@@ -180,10 +168,6 @@ msgctxt "#31401"
 msgid "Manage your video library  Set video playback options  Change video listing options  Set subtitle fonts"
 msgstr "      "
 
-msgctxt "#31402"
-msgid "Manage your music library  Set music playback options  Change music listing options  Setup song submission"
-msgstr "       "
-
 msgctxt "#31403"
 msgid "Set picture listing options  Configure slideshows"
 msgstr "  "
@@ -200,10 +184,6 @@ msgctxt "#31406"
 msgid "Setup and calibrate displays  Configure audio output  Setup remote controls  Set power saving options  Enable debugging  Setup master lock"
 msgstr "          "
 
-msgctxt "#31407"
-msgid "Manage your installed add-ons  Browse for and install add-ons from kodi.tv  Modify add-on settings"
-msgstr "   kodi.tv   "
-
 msgctxt "#31421"
 msgid "Select your Kodi user Profile[CR]to login and continue"
 msgstr "[CR]"
@@ -283,23 +263,3 @@ msgstr ""
 msgctxt "#31565"
 msgid "Show deleted"
 msgstr ""
-
-msgctxt "#31900"
-msgid "First Run"
-msgstr ""
-
-msgctxt "#31901"
-msgid "There are two things to know about navigating Estouchy"
-msgstr " Estouchy "
-
-msgctxt "#31902"
-msgid "The Kodi logo functions as a 'HOME' button. Whenever you touch it, you will be taken back to the home screen."
-msgstr "Kodi Logo "
-
-msgctxt "#31903"
-msgid "When you are playing audio or video, the item title will appear at the top of the screen. Touching it will take you to the fullscreen visualization or video window."
-msgstr ""
-
-msgctxt "#31904"
-msgid "Now Playing Title..."
-msgstr "..."
diff --git a/addons/skin.estouchy/xml/AddonBrowser.xml b/addons/skin.estouchy/xml/AddonBrowser.xml
index 4d92cdf..ac0fb16 100644
--- a/addons/skin.estouchy/xml/AddonBrowser.xml
+++ b/addons/skin.estouchy/xml/AddonBrowser.xml
@@ -23,30 +23,30 @@
 		</control>
 		<control type="group">
 			<include>Window_OpenClose_Animation_Zoom</include>
-			<include content="Thumbnail" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 50 -->
+			<include name="Thumbnail" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 50 -->
 				<param name="panel-width" value="1530"/>
 				<param name="layout-width" value="306"/>
 			</include>
-			<include content="Thumbnail" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 50 -->
+			<include name="Thumbnail" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 50 -->
 				<param name="panel-width" value="1090"/>
 				<param name="layout-width" value="363"/>
 			</include>
-			<include content="List" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 500 -->
+			<include name="List" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 500 -->
 				<param name="panel-width" value="1530"/>
 				<param name="label-width" value="1230"/>
 				<param name="label2-posx" value="1360r"/>
 			</include>
-			<include content="List" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 500 -->
+			<include name="List" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 500 -->
 				<param name="panel-width" value="1090"/>
 				<param name="label-width" value="790"/>
 				<param name="label2-posx" value="920r"/>
 			</include>
-			<include content="Wide" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 550 -->
+			<include name="Wide" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 550 -->
 				<param name="panel-width" value="1530"/>
 				<param name="textbox-width-movies" value="1350"/>
 				<param name="textbox-width-episodes" value="1250"/>
 			</include>
-			<include content="Wide" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 550 -->
+			<include name="Wide" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 550 -->
 				<param name="panel-width" value="1090"/>
 				<param name="textbox-width-movies" value="910"/>
 				<param name="textbox-width-episodes" value="810"/>
@@ -54,7 +54,7 @@
 		</control>
 		<include>ScrollBarCommons</include>
 		<include>BottomMenu</include>
-		<include content="PopupMenu">
+		<include name="PopupMenu">
 			<param name="panel-posy">80</param>
 			<param name="panel-height">480</param>
 		</include>
diff --git a/addons/skin.estouchy/xml/EventLog.xml b/addons/skin.estouchy/xml/EventLog.xml
index c71569c..de55f23 100644
--- a/addons/skin.estouchy/xml/EventLog.xml
+++ b/addons/skin.estouchy/xml/EventLog.xml
@@ -16,12 +16,12 @@
 		</control>
 		<control type="group">
 			<include>Window_OpenClose_Animation_Zoom</include>
-			<include content="List" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 50 -->
+			<include name="List" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 50 -->
 				<param name="panel-width" value="1530"/>
 				<param name="label-width" value="1240"/>
 				<param name="label2-posx" value="1360r"/>
 			</include>
-			<include content="List" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 50 -->
+			<include name="List" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 50 -->
 				<param name="panel-width" value="1090"/>
 				<param name="label-width" value="800"/>
 				<param name="label2-posx" value="920r"/>
@@ -29,7 +29,7 @@
 		</control>
 		<include>ScrollBarCommons</include>
 		<include>BottomMenu</include>
-		<include content="PopupMenu">
+		<include name="PopupMenu">
 			<param name="panel-posy">240</param>
 			<param name="panel-height">360</param>
 		</include>
diff --git a/addons/skin.estouchy/xml/IncludesPlayerControls.xml b/addons/skin.estouchy/xml/IncludesPlayerControls.xml
index 089709a..27b53fc 100644
--- a/addons/skin.estouchy/xml/IncludesPlayerControls.xml
+++ b/addons/skin.estouchy/xml/IncludesPlayerControls.xml
@@ -345,7 +345,7 @@
 			</control>
 		</control>
 		<include>BottomMenu</include>
-		<include content="PopupMenu">
+		<include name="PopupMenu">
 			<param name="panel-posy">0</param>
 			<param name="panel-height">560</param>
 		</include>
diff --git a/addons/skin.estouchy/xml/MyMusicNav.xml b/addons/skin.estouchy/xml/MyMusicNav.xml
index 14ef567..0214150 100644
--- a/addons/skin.estouchy/xml/MyMusicNav.xml
+++ b/addons/skin.estouchy/xml/MyMusicNav.xml
@@ -16,30 +16,30 @@
 		</control>
 		<control type="group">
 			<include>Window_OpenClose_Animation_Zoom</include>
-			<include content="Thumbnail" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 50 -->
+			<include name="Thumbnail" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 50 -->
 				<param name="panel-width" value="1530"/>
 				<param name="layout-width" value="306"/>
 			</include>
-			<include content="Thumbnail" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 50 -->
+			<include name="Thumbnail" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 50 -->
 				<param name="panel-width" value="1090"/>
 				<param name="layout-width" value="363"/>
 			</include>
-			<include content="List" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 500 -->
+			<include name="List" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 500 -->
 				<param name="panel-width" value="1530"/>
 				<param name="label-width" value="1230"/>
 				<param name="label2-posx" value="1360r"/>
 			</include>
-			<include content="List" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 500 -->
+			<include name="List" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 500 -->
 				<param name="panel-width" value="1090"/>
 				<param name="label-width" value="790"/>
 				<param name="label2-posx" value="920r"/>
 			</include>
-			<include content="Wide" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 550 -->
+			<include name="Wide" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 550 -->
 				<param name="panel-width" value="1530"/>
 				<param name="textbox-width-movies" value="1350"/>
 				<param name="textbox-width-episodes" value="1250"/>
 			</include>
-			<include content="Wide" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 550 -->
+			<include name="Wide" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 550 -->
 				<param name="panel-width" value="1090"/>
 				<param name="textbox-width-movies" value="910"/>
 				<param name="textbox-width-episodes" value="810"/>
@@ -47,7 +47,7 @@
 		</control>
 		<include>ScrollBarCommons</include>
 		<include>BottomMenu</include>
-		<include content="PopupMenu">
+		<include name="PopupMenu">
 			<param name="panel-posy">80</param>
 			<param name="panel-height">480</param>
 		</include>
diff --git a/addons/skin.estouchy/xml/MyMusicPlaylistEditor.xml b/addons/skin.estouchy/xml/MyMusicPlaylistEditor.xml
index 8ea3a09..d0eb03b 100644
--- a/addons/skin.estouchy/xml/MyMusicPlaylistEditor.xml
+++ b/addons/skin.estouchy/xml/MyMusicPlaylistEditor.xml
@@ -294,7 +294,7 @@
 				</item>
 			</content>
 		</control>
-		<include content="PopupMenu">
+		<include name="PopupMenu">
 			<param name="panel-posy">320</param>
 			<param name="panel-height">240</param>
 		</include>
diff --git a/addons/skin.estouchy/xml/MyPVRChannels.xml b/addons/skin.estouchy/xml/MyPVRChannels.xml
index 1197c29..8de142e 100644
--- a/addons/skin.estouchy/xml/MyPVRChannels.xml
+++ b/addons/skin.estouchy/xml/MyPVRChannels.xml
@@ -19,34 +19,34 @@
 		</control>
 		<control type="group">
 			<include>Window_OpenClose_Animation_Zoom</include>
-			<include content="PVRBack" condition="String.IsEqual(Skin.AspectRatio,16:9)">
+			<include name="PVRBack" condition="String.IsEqual(Skin.AspectRatio,16:9)">
 				<param name="panel-width" value="1530"/>
 			</include>
-			<include content="PVRBack" condition="String.IsEqual(Skin.AspectRatio,4:3)">
+			<include name="PVRBack" condition="String.IsEqual(Skin.AspectRatio,4:3)">
 				<param name="panel-width" value="1090"/>
 			</include>
-			<include content="PVRList" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 50 -->
+			<include name="PVRList" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 50 -->
 				<param name="panel-id" value="50"/>
 				<param name="panel-width" value="1530"/>
 				<param name="label-width" value="1400"/>
 			</include>
-			<include content="PVRList" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 50 -->
+			<include name="PVRList" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 50 -->
 				<param name="panel-id" value="50"/>
 				<param name="panel-width" value="1090"/>
 				<param name="label-width" value="960"/>
 			</include>
-			<include content="PVRInfo" condition="String.IsEqual(Skin.AspectRatio,16:9)">
+			<include name="PVRInfo" condition="String.IsEqual(Skin.AspectRatio,16:9)">
 				<param name="panel-width" value="1530"/>
 				<param name="textbox-width" value="1160"/>
 			</include>
-			<include content="PVRInfo" condition="String.IsEqual(Skin.AspectRatio,4:3)">
+			<include name="PVRInfo" condition="String.IsEqual(Skin.AspectRatio,4:3)">
 				<param name="panel-width" value="1090"/>
 				<param name="textbox-width" value="720"/>
 			</include>
 		</control>
 		<include>ScrollBarCommons</include>
 		<include>BottomMenu</include>
-		<include content="PopupMenu">
+		<include name="PopupMenu">
 			<param name="panel-posy">-80</param>
 			<param name="panel-height">640</param>
 		</include>
diff --git a/addons/skin.estouchy/xml/MyPVRGuide.xml b/addons/skin.estouchy/xml/MyPVRGuide.xml
index 7a0716d..b2d773d 100644
--- a/addons/skin.estouchy/xml/MyPVRGuide.xml
+++ b/addons/skin.estouchy/xml/MyPVRGuide.xml
@@ -22,60 +22,60 @@
 		</control>
 		<control type="group">
 			<include>Window_OpenClose_Animation_Zoom</include>
-			<include content="PVREPG" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 10 -->
+			<include name="PVREPG" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 10 -->
 				<param name="panel-width" value="1530"/>
 			</include>
-			<include content="PVREPG" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 10 -->
+			<include name="PVREPG" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 10 -->
 				<param name="panel-width" value="1090"/>
 			</include>
-			<include content="PVRBack" condition="String.IsEqual(Skin.AspectRatio,16:9)">
+			<include name="PVRBack" condition="String.IsEqual(Skin.AspectRatio,16:9)">
 				<param name="panel-width" value="1530"/>
 			</include>
-			<include content="PVRBack" condition="String.IsEqual(Skin.AspectRatio,4:3)">
+			<include name="PVRBack" condition="String.IsEqual(Skin.AspectRatio,4:3)">
 				<param name="panel-width" value="1090"/>
 			</include>
-			<include content="PVRList" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 11 -->
+			<include name="PVRList" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 11 -->
 				<param name="panel-id" value="11"/>
 				<param name="panel-width" value="1530"/>
 				<param name="label-width" value="1400"/>
 			</include>
-			<include content="PVRList" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 11 -->
+			<include name="PVRList" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 11 -->
 				<param name="panel-id" value="11"/>
 				<param name="panel-width" value="1090"/>
 				<param name="label-width" value="960"/>
 			</include>
-			<include content="PVRList" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 12 -->
+			<include name="PVRList" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 12 -->
 				<param name="panel-id" value="12"/>
 				<param name="panel-width" value="1530"/>
 				<param name="label-width" value="1400"/>
 			</include>
-			<include content="PVRList" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 12 -->
+			<include name="PVRList" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 12 -->
 				<param name="panel-id" value="12"/>
 				<param name="panel-width" value="1090"/>
 				<param name="label-width" value="960"/>
 			</include>
-			<include content="PVRList" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 13 -->
+			<include name="PVRList" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 13 -->
 				<param name="panel-id" value="13"/>
 				<param name="panel-width" value="1530"/>
 				<param name="label-width" value="1400"/>
 			</include>
-			<include content="PVRList" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 13 -->
+			<include name="PVRList" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 13 -->
 				<param name="panel-id" value="13"/>
 				<param name="panel-width" value="1090"/>
 				<param name="label-width" value="960"/>
 			</include>
-			<include content="PVRInfo" condition="String.IsEqual(Skin.AspectRatio,16:9)">
+			<include name="PVRInfo" condition="String.IsEqual(Skin.AspectRatio,16:9)">
 				<param name="panel-width" value="1530"/>
 				<param name="textbox-width" value="1160"/>
 			</include>
-			<include content="PVRInfo" condition="String.IsEqual(Skin.AspectRatio,4:3)">
+			<include name="PVRInfo" condition="String.IsEqual(Skin.AspectRatio,4:3)">
 				<param name="panel-width" value="1090"/>
 				<param name="textbox-width" value="720"/>
 			</include>
 		</control>
 		<include>ScrollBarCommons</include>
 		<include>BottomMenu</include>
-		<include content="PopupMenu">
+		<include name="PopupMenu">
 			<param name="panel-posy">0</param>
 			<param name="panel-height">560</param>
 		</include>
diff --git a/addons/skin.estouchy/xml/MyPVRRecordings.xml b/addons/skin.estouchy/xml/MyPVRRecordings.xml
index 0fb7904..56d1f3b 100644
--- a/addons/skin.estouchy/xml/MyPVRRecordings.xml
+++ b/addons/skin.estouchy/xml/MyPVRRecordings.xml
@@ -16,34 +16,34 @@
 		</control>
 		<control type="group">
 			<include>Window_OpenClose_Animation_Zoom</include>
-			<include content="PVRBack" condition="String.IsEqual(Skin.AspectRatio,16:9)">
+			<include name="PVRBack" condition="String.IsEqual(Skin.AspectRatio,16:9)">
 				<param name="panel-width" value="1530"/>
 			</include>
-			<include content="PVRBack" condition="String.IsEqual(Skin.AspectRatio,4:3)">
+			<include name="PVRBack" condition="String.IsEqual(Skin.AspectRatio,4:3)">
 				<param name="panel-width" value="1090"/>
 			</include>
-			<include content="PVRList" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 50 -->
+			<include name="PVRList" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 50 -->
 				<param name="panel-id" value="50"/>
 				<param name="panel-width" value="1530"/>
 				<param name="label-width" value="1400"/>
 			</include>
-			<include content="PVRList" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 50 -->
+			<include name="PVRList" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 50 -->
 				<param name="panel-id" value="50"/>
 				<param name="panel-width" value="1090"/>
 				<param name="label-width" value="960"/>
 			</include>
-			<include content="PVRInfo" condition="String.IsEqual(Skin.AspectRatio,16:9)">
+			<include name="PVRInfo" condition="String.IsEqual(Skin.AspectRatio,16:9)">
 				<param name="panel-width" value="1530"/>
 				<param name="textbox-width" value="1160"/>
 			</include>
-			<include content="PVRInfo" condition="String.IsEqual(Skin.AspectRatio,4:3)">
+			<include name="PVRInfo" condition="String.IsEqual(Skin.AspectRatio,4:3)">
 				<param name="panel-width" value="1090"/>
 				<param name="textbox-width" value="720"/>
 			</include>
 		</control>
 		<include>ScrollBarCommons</include>
 		<include>BottomMenu</include>
-		<include content="PopupMenu">
+		<include name="PopupMenu">
 			<param name="panel-posy">-80</param>
 			<param name="panel-height">640</param>
 		</include>
diff --git a/addons/skin.estouchy/xml/MyPVRSearch.xml b/addons/skin.estouchy/xml/MyPVRSearch.xml
index 5c79247..0099964 100644
--- a/addons/skin.estouchy/xml/MyPVRSearch.xml
+++ b/addons/skin.estouchy/xml/MyPVRSearch.xml
@@ -16,34 +16,34 @@
 		</control>
 		<control type="group">
 			<include>Window_OpenClose_Animation_Zoom</include>
-			<include content="PVRBack" condition="String.IsEqual(Skin.AspectRatio,16:9)">
+			<include name="PVRBack" condition="String.IsEqual(Skin.AspectRatio,16:9)">
 				<param name="panel-width" value="1530"/>
 			</include>
-			<include content="PVRBack" condition="String.IsEqual(Skin.AspectRatio,4:3)">
+			<include name="PVRBack" condition="String.IsEqual(Skin.AspectRatio,4:3)">
 				<param name="panel-width" value="1090"/>
 			</include>
-			<include content="PVRList" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 50 -->
+			<include name="PVRList" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 50 -->
 				<param name="panel-id" value="50"/>
 				<param name="panel-width" value="1530"/>
 				<param name="label-width" value="1400"/>
 			</include>
-			<include content="PVRList" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 50 -->
+			<include name="PVRList" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 50 -->
 				<param name="panel-id" value="50"/>
 				<param name="panel-width" value="1090"/>
 				<param name="label-width" value="960"/>
 			</include>
-			<include content="PVRInfo" condition="String.IsEqual(Skin.AspectRatio,16:9)">
+			<include name="PVRInfo" condition="String.IsEqual(Skin.AspectRatio,16:9)">
 				<param name="panel-width" value="1530"/>
 				<param name="textbox-width" value="1160"/>
 			</include>
-			<include content="PVRInfo" condition="String.IsEqual(Skin.AspectRatio,4:3)">
+			<include name="PVRInfo" condition="String.IsEqual(Skin.AspectRatio,4:3)">
 				<param name="panel-width" value="1090"/>
 				<param name="textbox-width" value="720"/>
 			</include>
 		</control>
 		<include>ScrollBarCommons</include>
 		<include>BottomMenu</include>
-		<include content="PopupMenu">
+		<include name="PopupMenu">
 			<param name="panel-posy">0</param>
 			<param name="panel-height">560</param>
 		</include>
diff --git a/addons/skin.estouchy/xml/MyPVRTimers.xml b/addons/skin.estouchy/xml/MyPVRTimers.xml
index b4279f0..8f26622 100644
--- a/addons/skin.estouchy/xml/MyPVRTimers.xml
+++ b/addons/skin.estouchy/xml/MyPVRTimers.xml
@@ -16,34 +16,34 @@
 		</control>
 		<control type="group">
 			<include>Window_OpenClose_Animation_Zoom</include>
-			<include content="PVRBack" condition="String.IsEqual(Skin.AspectRatio,16:9)">
+			<include name="PVRBack" condition="String.IsEqual(Skin.AspectRatio,16:9)">
 				<param name="panel-width" value="1530"/>
 			</include>
-			<include content="PVRBack" condition="String.IsEqual(Skin.AspectRatio,4:3)">
+			<include name="PVRBack" condition="String.IsEqual(Skin.AspectRatio,4:3)">
 				<param name="panel-width" value="1090"/>
 			</include>
-			<include content="PVRList" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 50 -->
+			<include name="PVRList" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 50 -->
 				<param name="panel-id" value="50"/>
 				<param name="panel-width" value="1530"/>
 				<param name="label-width" value="1400"/>
 			</include>
-			<include content="PVRList" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 50 -->
+			<include name="PVRList" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 50 -->
 				<param name="panel-id" value="50"/>
 				<param name="panel-width" value="1090"/>
 				<param name="label-width" value="960"/>
 			</include>
-			<include content="PVRInfo" condition="String.IsEqual(Skin.AspectRatio,16:9)">
+			<include name="PVRInfo" condition="String.IsEqual(Skin.AspectRatio,16:9)">
 				<param name="panel-width" value="1530"/>
 				<param name="textbox-width" value="1160"/>
 			</include>
-			<include content="PVRInfo" condition="String.IsEqual(Skin.AspectRatio,4:3)">
+			<include name="PVRInfo" condition="String.IsEqual(Skin.AspectRatio,4:3)">
 				<param name="panel-width" value="1090"/>
 				<param name="textbox-width" value="720"/>
 			</include>
 		</control>
 		<include>ScrollBarCommons</include>
 		<include>BottomMenu</include>
-		<include content="PopupMenu">
+		<include name="PopupMenu">
 			<param name="panel-posy">0</param>
 			<param name="panel-height">560</param>
 		</include>
diff --git a/addons/skin.estouchy/xml/MyPics.xml b/addons/skin.estouchy/xml/MyPics.xml
index 997c70e..05d2cad 100644
--- a/addons/skin.estouchy/xml/MyPics.xml
+++ b/addons/skin.estouchy/xml/MyPics.xml
@@ -16,20 +16,20 @@
 		</control>
 		<control type="group">
 			<include>Window_OpenClose_Animation_Zoom</include>
-			<include content="Thumbnail" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 50 -->
+			<include name="Thumbnail" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 50 -->
 				<param name="panel-width" value="1530"/>
 				<param name="layout-width" value="306"/>
 			</include>
-			<include content="Thumbnail" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 50 -->
+			<include name="Thumbnail" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 50 -->
 				<param name="panel-width" value="1090"/>
 				<param name="layout-width" value="363"/>
 			</include>
-			<include content="List" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 500 -->
+			<include name="List" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 500 -->
 				<param name="panel-width" value="1530"/>
 				<param name="label-width" value="1230"/>
 				<param name="label2-posx" value="1360r"/>
 			</include>
-			<include content="List" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 500 -->
+			<include name="List" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 500 -->
 				<param name="panel-width" value="1090"/>
 				<param name="label-width" value="790"/>
 				<param name="label2-posx" value="920r"/>
@@ -37,7 +37,7 @@
 		</control>
 		<include>ScrollBarCommons</include>
 		<include>BottomMenu</include>
-		<include content="PopupMenu">
+		<include name="PopupMenu">
 			<param name="panel-posy">160</param>
 			<param name="panel-height">400</param>
 		</include>
diff --git a/addons/skin.estouchy/xml/MyPlaylist.xml b/addons/skin.estouchy/xml/MyPlaylist.xml
index d33c33b..ad8df98 100644
--- a/addons/skin.estouchy/xml/MyPlaylist.xml
+++ b/addons/skin.estouchy/xml/MyPlaylist.xml
@@ -15,37 +15,37 @@
 		</control>
 		<control type="group">
 			<include>Window_OpenClose_Animation_Zoom</include>
-			<include content="Thumbnail" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 50 -->
+			<include name="Thumbnail" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 50 -->
 				<param name="panel-width" value="1530"/>
 				<param name="layout-width" value="306"/>
 			</include>
-			<include content="Thumbnail" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 50 -->
+			<include name="Thumbnail" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 50 -->
 				<param name="panel-width" value="1090"/>
 				<param name="layout-width" value="363"/>
 			</include>
-			<include content="List" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 500 -->
+			<include name="List" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 500 -->
 				<param name="panel-width" value="1530"/>
 				<param name="label-width" value="1230"/>
 				<param name="label2-posx" value="1360r"/>
 			</include>
-			<include content="List" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 500 -->
+			<include name="List" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 500 -->
 				<param name="panel-width" value="1090"/>
 				<param name="label-width" value="790"/>
 				<param name="label2-posx" value="920r"/>
 			</include>
-			<include content="Wide" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 550 -->
+			<include name="Wide" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 550 -->
 				<param name="panel-width" value="1530"/>
 				<param name="textbox-width-movies" value="1350"/>
 				<param name="textbox-width-episodes" value="1250"/>
 			</include>
-			<include content="Wide" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 550 -->
+			<include name="Wide" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 550 -->
 				<param name="panel-width" value="1090"/>
 				<param name="textbox-width-movies" value="910"/>
 				<param name="textbox-width-episodes" value="810"/>
 			</include>
 		</control>
 		<include>BottomMenu</include>
-		<include content="PopupMenu">
+		<include name="PopupMenu">
 			<param name="panel-posy">240</param>
 			<param name="panel-height">320</param>
 		</include>
diff --git a/addons/skin.estouchy/xml/MyPrograms.xml b/addons/skin.estouchy/xml/MyPrograms.xml
index 37da43f..5861b11 100644
--- a/addons/skin.estouchy/xml/MyPrograms.xml
+++ b/addons/skin.estouchy/xml/MyPrograms.xml
@@ -16,30 +16,30 @@
 		</control>
 		<control type="group">
 			<include>Window_OpenClose_Animation_Zoom</include>
-			<include content="Thumbnail" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 50 -->
+			<include name="Thumbnail" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 50 -->
 				<param name="panel-width" value="1530"/>
 				<param name="layout-width" value="306"/>
 			</include>
-			<include content="Thumbnail" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 50 -->
+			<include name="Thumbnail" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 50 -->
 				<param name="panel-width" value="1090"/>
 				<param name="layout-width" value="363"/>
 			</include>
-			<include content="List" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 500 -->
+			<include name="List" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 500 -->
 				<param name="panel-width" value="1530"/>
 				<param name="label-width" value="1230"/>
 				<param name="label2-posx" value="1360r"/>
 			</include>
-			<include content="List" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 500 -->
+			<include name="List" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 500 -->
 				<param name="panel-width" value="1090"/>
 				<param name="label-width" value="790"/>
 				<param name="label2-posx" value="920r"/>
 			</include>
-			<include content="Wide" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 550 -->
+			<include name="Wide" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 550 -->
 				<param name="panel-width" value="1530"/>
 				<param name="textbox-width-movies" value="1350"/>
 				<param name="textbox-width-episodes" value="1250"/>
 			</include>
-			<include content="Wide" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 550 -->
+			<include name="Wide" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 550 -->
 				<param name="panel-width" value="1090"/>
 				<param name="textbox-width-movies" value="910"/>
 				<param name="textbox-width-episodes" value="810"/>
@@ -47,7 +47,7 @@
 		</control>
 		<include>ScrollBarCommons</include>
 		<include>BottomMenu</include>
-		<include content="PopupMenu">
+		<include name="PopupMenu">
 			<param name="panel-posy">400</param>
 			<param name="panel-height">160</param>
 		</include>
diff --git a/addons/skin.estouchy/xml/MyVideoNav.xml b/addons/skin.estouchy/xml/MyVideoNav.xml
index 73f799d..d171986 100644
--- a/addons/skin.estouchy/xml/MyVideoNav.xml
+++ b/addons/skin.estouchy/xml/MyVideoNav.xml
@@ -16,30 +16,30 @@
 		</control>
 		<control type="group">
 			<include>Window_OpenClose_Animation_Zoom</include>
-			<include content="Thumbnail" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 50 -->
+			<include name="Thumbnail" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 50 -->
 				<param name="panel-width" value="1530"/>
 				<param name="layout-width" value="306"/>
 			</include>
-			<include content="Thumbnail" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 50 -->
+			<include name="Thumbnail" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 50 -->
 				<param name="panel-width" value="1090"/>
 				<param name="layout-width" value="363"/>
 			</include>
-			<include content="List" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 500 -->
+			<include name="List" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 500 -->
 				<param name="panel-width" value="1530"/>
 				<param name="label-width" value="1230"/>
 				<param name="label2-posx" value="1360r"/>
 			</include>
-			<include content="List" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 500 -->
+			<include name="List" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 500 -->
 				<param name="panel-width" value="1090"/>
 				<param name="label-width" value="790"/>
 				<param name="label2-posx" value="920r"/>
 			</include>
-			<include content="Wide" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 550 -->
+			<include name="Wide" condition="String.IsEqual(Skin.AspectRatio,16:9)"> <!-- view id = 550 -->
 				<param name="panel-width" value="1530"/>
 				<param name="textbox-width-movies" value="1350"/>
 				<param name="textbox-width-episodes" value="1250"/>
 			</include>
-			<include content="Wide" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 550 -->
+			<include name="Wide" condition="String.IsEqual(Skin.AspectRatio,4:3)"> <!-- view id = 550 -->
 				<param name="panel-width" value="1090"/>
 				<param name="textbox-width-movies" value="910"/>
 				<param name="textbox-width-episodes" value="810"/>
@@ -47,7 +47,7 @@
 		</control>
 		<include>ScrollBarCommons</include>
 		<include>BottomMenu</include>
-		<include content="PopupMenu">
+		<include name="PopupMenu">
 			<param name="panel-posy">0</param>
 			<param name="panel-height">560</param>
 		</include>
diff --git a/addons/skin.estouchy/xml/SettingsCategory.xml b/addons/skin.estouchy/xml/SettingsCategory.xml
index b2e3247..96b19c9 100644
--- a/addons/skin.estouchy/xml/SettingsCategory.xml
+++ b/addons/skin.estouchy/xml/SettingsCategory.xml
@@ -182,7 +182,7 @@
 			<font>-</font>
 			<visible>false</visible>
 		</control>
-		<include content="PopupMenu">
+		<include name="PopupMenu">
 			<param name="panel-posy">400</param>
 			<param name="panel-height">160</param>
 		</include>
diff --git a/appveyor.yml b/appveyor.yml
index af6b01d..1934d5f 100644
--- a/appveyor.yml
+++ b/appveyor.yml
@@ -1,4 +1,4 @@
-os: Visual Studio 2015
+os: Visual Studio 2013
 
 shallow_clone: true
 
@@ -24,7 +24,7 @@ build_script:
   - ps: $ErrorActionPreference= 'silentlycontinue'
   
   # Setup Visual Studio compiler environment 
-  - call "%VS140COMNTOOLS%..\..\VC\bin\vcvars32.bat"
+  - call "%VS120COMNTOOLS%..\..\VC\bin\vcvars32.bat"
   
   #
   # Build Kodi
@@ -41,7 +41,7 @@ build_script:
         # Download precompiled mingw32 libraries
         # To run make-mingwlibs.bat on AppVeyor takes too long, 
         # we must use precompiled libs to speed up build
-        bash -c "curl http://repo.msys2.org/mingw/i686/mingw-w64-i686-ffmpeg-3.0-1-any.pkg.tar.xz | tar xJv"
+        bash -c "curl http://repo.msys2.org/mingw/i686/mingw-w64-i686-ffmpeg-2.8.5-2-any.pkg.tar.xz | tar xJv"
         bash -c "curl http://repo.msys2.org/mingw/i686/mingw-w64-i686-libdvdcss-1.4.0-1-any.pkg.tar.xz | tar xJv"
         bash -c "curl http://repo.msys2.org/mingw/i686/mingw-w64-i686-libdvdnav-5.0.3-1-any.pkg.tar.xz | tar xJv"
         bash -c "curl http://repo.msys2.org/mingw/i686/mingw-w64-i686-libdvdread-5.0.3-1-any.pkg.tar.xz | tar xJv"
diff --git a/configure.ac b/configure.ac
index c4e83a2..4473bdb 100644
--- a/configure.ac
+++ b/configure.ac
@@ -965,6 +965,7 @@ fi
 AC_CHECK_HEADER([ass/ass.h],, AC_MSG_ERROR($missing_library))
 AC_CHECK_HEADER([ogg/ogg.h],,        AC_MSG_ERROR($missing_library))
 AC_CHECK_HEADER([vorbis/vorbisfile.h],, AC_MSG_ERROR($missing_library))
+PKG_CHECK_MODULES([LIBDCADEC], [dcadec],, AC_MSG_ERROR([libdcadec not found]))
 
 PKG_CHECK_MODULES([LIBCURL], [libcurl],, AC_MSG_ERROR([libcurl not found]))
 XB_FIND_SONAME([CURL], [curl])
@@ -1590,6 +1591,7 @@ if test "${USE_STATIC_FFMPEG}" = "1"; then
   FFMPEG_LIBDIR=${pkg_cfg_prefix}$(PKG_CONFIG_SYSROOT_DIR="" ${PKG_CONFIG} --static --variable=libdir libavcodec)
   GNUTLS_ALL_LIBS=$(${PKG_CONFIG} --static --libs-only-l --silence-errors gnutls)
   VORBISENC_ALL_LIBS=$(${PKG_CONFIG} --static --libs-only-l --silence-errors vorbisenc)
+  DCADEC_ALL_LIBS=$(${PKG_CONFIG} --static --libs-only-l --silence-errors dcadec)
 
   # check if static libs are available
   for ff_lib in ${ff_libs}; do
@@ -2200,6 +2202,7 @@ OUTPUT_FILES="Makefile \
     lib/addons/library.kodi.adsp/Makefile \
     lib/addons/library.kodi.audioengine/Makefile \
     lib/addons/library.xbmc.codec/Makefile \
+    lib/addons/library.kodi.game/Makefile \
     lib/addons/library.kodi.guilib/Makefile \
     lib/addons/library.kodi.peripheral/Makefile \
     lib/addons/library.xbmc.pvr/Makefile \
diff --git a/docs/README.linux b/docs/README.linux
index 0d68ce6..9c5cccf 100644
--- a/docs/README.linux
+++ b/docs/README.linux
@@ -44,7 +44,7 @@ that are used to build Kodi packages on Debian/Ubuntu (with all supported
 external libraries enabled).
 
 Build-Depends: autoconf, automake, autopoint, autotools-dev, cmake, curl,
-  default-jre, gawk, gperf, libao-dev, libasound2-dev,
+  dcadec-dev, default-jre, gawk, gperf, libao-dev, libasound2-dev,
   libass-dev (>= 0.9.8), libavahi-client-dev, libavahi-common-dev, libbluetooth-dev,
   libbluray-dev (>= 0.7.0), libbz2-dev, libcap-dev,
   libcdio-dev, libcec-dev, libcurl4-openssl-dev | libcurl4-gnutls-dev | libcurl-dev,
diff --git a/docs/README.ubuntu b/docs/README.ubuntu
index 42343b6..e0a2fcd 100644
--- a/docs/README.ubuntu
+++ b/docs/README.ubuntu
@@ -81,7 +81,7 @@ Tip: For those with multiple computers at home is to try out distcc
 -----------------------------------------------------------------------------
 
 For Ubuntu (all versions >= 7.04):
-    $ sudo apt-get install automake bison build-essential cmake curl cvs \
+    $ sudo apt-get install automake bison build-essential cmake curl cvs dcadec-dev \
       default-jre fp-compiler gawk gdc gettext git-core gperf libasound2-dev libass-dev \
       libbz2-dev libcap-dev libcdio-dev libcurl3 \
       libcurl4-openssl-dev libdbus-1-dev libfontconfig-dev libegl1-mesa-dev libfreetype6-dev \
diff --git a/lib/addons/library.kodi.game/Makefile.in b/lib/addons/library.kodi.game/Makefile.in
new file mode 100644
index 0000000..3644126
--- /dev/null
+++ b/lib/addons/library.kodi.game/Makefile.in
@@ -0,0 +1,29 @@
+ARCH=@ARCH@
+INCLUDES=-I. -I../../../xbmc/addons/include
+DEFINES+=
+CXXFLAGS=-fPIC
+LIBNAME=libKODI_game
+OBJS=$(LIBNAME).o
+
+ifeq ($(findstring osx,$(ARCH)), osx)
+LIB_SHARED=../../../addons/library.kodi.game/$(LIBNAME)-$(ARCH).dylib
+else
+LIB_SHARED=../../../addons/library.kodi.game/$(LIBNAME)-$(ARCH).so
+endif
+
+all: $(LIB_SHARED)
+
+$(LIB_SHARED): $(OBJS)
+ifeq ($(findstring osx,$(ARCH)), osx)
+	$(CXX) $(CXXFLAGS) $(LDFLAGS) -dynamiclib -o $@ $(OBJS)
+else
+	$(CXX) $(CFLAGS) $(LDFLAGS) -shared -g -o $(LIB_SHARED) $(OBJS)
+endif
+
+CLEAN_FILES = \
+	$(LIB_SHARED) \
+
+DISTCLEAN_FILES= \
+	Makefile \
+
+include ../../../Makefile.include
diff --git a/lib/addons/library.kodi.game/libKODI_game.cpp b/lib/addons/library.kodi.game/libKODI_game.cpp
new file mode 100644
index 0000000..f82b322
--- /dev/null
+++ b/lib/addons/library.kodi.game/libKODI_game.cpp
@@ -0,0 +1,157 @@
+/*
+ *      Copyright (C) 2014-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "addons/binary/interfaces/AddonInterfaces.h"
+#include "addons/kodi-addon-dev-kit/include/kodi/kodi_game_types.h"
+
+#include <stdio.h>
+
+#ifdef _WIN32
+  #include <windows.h>
+  #define DLLEXPORT __declspec(dllexport)
+#else
+  #define DLLEXPORT
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+DLLEXPORT CB_GameLib* GAME_register_me(AddonCB* frontend)
+{
+  CB_GameLib* cb = NULL;
+  if (!frontend)
+    fprintf(stderr, "ERROR: GAME_register_frontend is called with NULL handle!!!\n");
+  else
+  {
+    cb = frontend->GameLib_RegisterMe(frontend->addonData);
+    if (!cb)
+      fprintf(stderr, "ERROR: GAME_register_frontend can't get callback table from frontend!!!\n");
+  }
+  return cb;
+}
+
+DLLEXPORT void GAME_unregister_me(AddonCB* frontend, CB_GameLib* cb)
+{
+  if (frontend == NULL || cb == NULL)
+    return;
+  return frontend->GameLib_UnRegisterMe(frontend->addonData, cb);
+}
+
+DLLEXPORT void GAME_close_game(AddonCB* frontend, CB_GameLib* cb)
+{
+  if (frontend == NULL || cb == NULL)
+    return;
+  return cb->CloseGame(frontend->addonData);
+}
+
+DLLEXPORT int GAME_open_video_stream(AddonCB* frontend, CB_GameLib* cb, GAME_VIDEO_FORMAT format, unsigned int width, unsigned int height)
+{
+  if (frontend == NULL || cb == NULL)
+    return -1;
+
+  return cb->OpenVideoStream(frontend->addonData, format, width, height);
+}
+
+DLLEXPORT void GAME_add_video_data(AddonCB* frontend, CB_GameLib* cb, const uint8_t* data, unsigned int size)
+{
+  if (frontend == NULL || cb == NULL)
+    return;
+
+  return cb->AddVideoData(frontend->addonData, data, size);
+}
+
+DLLEXPORT void GAME_close_video_stream(AddonCB* frontend, CB_GameLib* cb)
+{
+  if (frontend == NULL || cb == NULL)
+    return;
+
+  return cb->CloseVideoStream(frontend->addonData);
+}
+
+DLLEXPORT int GAME_open_audio_stream(AddonCB* frontend, CB_GameLib* cb, GAME_AUDIO_FORMAT format, unsigned int samplerate, GAME_AUDIO_CHANNEL_LAYOUT channels)
+{
+  if (frontend == NULL || cb == NULL)
+    return -1;
+
+  return cb->OpenAudioStream(frontend->addonData, format, samplerate, channels);
+}
+
+DLLEXPORT void GAME_add_audio_data(AddonCB* frontend, CB_GameLib* cb, const uint8_t* data, unsigned int size)
+{
+  if (frontend == NULL || cb == NULL)
+    return;
+
+  return cb->AddAudioData(frontend->addonData, data, size);
+}
+
+DLLEXPORT void GAME_close_audio_stream(AddonCB* frontend, CB_GameLib* cb)
+{
+  if (frontend == NULL || cb == NULL)
+    return;
+
+  return cb->CloseAudioStream(frontend->addonData);
+}
+
+DLLEXPORT void GAME_hw_set_info(AddonCB* frontend, CB_GameLib* cb, game_hw_info* hw_info)
+{
+  if (frontend == NULL || cb == NULL)
+    return;
+  return cb->HwSetInfo(frontend->addonData, hw_info);
+}
+
+DLLEXPORT uintptr_t GAME_hw_get_current_framebuffer(AddonCB* frontend, CB_GameLib* cb)
+{
+  if (frontend == NULL || cb == NULL)
+    return 0;
+  return cb->HwGetCurrentFramebuffer(frontend->addonData);
+}
+
+DLLEXPORT game_proc_address_t GAME_hw_get_proc_address(AddonCB* frontend, CB_GameLib* cb, const char* sym)
+{
+  if (frontend == NULL || cb == NULL)
+    return NULL;
+  return cb->HwGetProcAddress(frontend->addonData, sym);
+}
+
+DLLEXPORT bool GAME_open_port(AddonCB* frontend, CB_GameLib* cb, unsigned int port)
+{
+  if (frontend == NULL || cb == NULL)
+    return false;
+  return cb->OpenPort(frontend->addonData, port);
+}
+
+DLLEXPORT void GAME_close_port(AddonCB* frontend, CB_GameLib* cb, unsigned int port)
+{
+  if (frontend == NULL || cb == NULL)
+    return;
+  return cb->ClosePort(frontend->addonData, port);
+}
+
+DLLEXPORT void GAME_rumble_set_state(AddonCB* frontend, CB_GameLib* cb, unsigned int port, GAME_RUMBLE_EFFECT effect, float strength)
+{
+  if (frontend == NULL || cb == NULL)
+    return;
+  return cb->RumbleSetState(frontend->addonData, port, effect, strength);
+}
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/lib/addons/library.kodi.game/project/VS2010Express/libKODI_game.vcxproj b/lib/addons/library.kodi.game/project/VS2010Express/libKODI_game.vcxproj
new file mode 100644
index 0000000..36c9931
--- /dev/null
+++ b/lib/addons/library.kodi.game/project/VS2010Express/libKODI_game.vcxproj
@@ -0,0 +1,82 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{1400C916-B4AD-41D7-ACEE-A853F3B89B38}</ProjectGuid>
+    <RootNamespace>XBMC_VDR</RootNamespace>
+    <Keyword>Win32Proj</Keyword>
+    <ProjectName>libKODI_game</ProjectName>
+  </PropertyGroup>
+  <Import Project="$(SolutionDir)\XBMC.core-defaults.props" />
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets">
+    <Import Project="$(SolutionDir)\XBMC.defaults.props" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\..\..\addons\library.kodi.game\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Debug\</IntDir>
+    <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\..\..\addons\library.kodi.game\</OutDir>
+    <IntDir Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Release\</IntDir>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">..\..\..\..\..\addons\library.xbmc.addon\;$(IncludePath)</IncludePath>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">..\..\..\..\..\addons\library.xbmc.addon\;$(IncludePath)</IncludePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <AdditionalIncludeDirectories>..\..\..\..\..\xbmc;..\..\..\..\..\xbmc\addons\include;..\..\..\..\..\xbmc\cores\dvdplayer\DVDDemuxers;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>_USRDLL;_WIN32PC;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <ExceptionHandling>Sync</ExceptionHandling>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+    </ClCompile>
+    <Link>
+      <OutputFile>..\..\..\..\..\addons\library.kodi.game\$(ProjectName).dll</OutputFile>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <AdditionalIncludeDirectories>..\..\..\..\..\xbmc;..\..\..\..\..\xbmc\addons\include;..\..\..\..\..\xbmc\cores\dvdplayer\DVDDemuxers;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>_USRDLL;XBMC__WIN32PC;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <ExceptionHandling>Sync</ExceptionHandling>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+    </ClCompile>
+    <Link>
+      <OutputFile>..\..\..\..\..\addons\library.kodi.game\$(ProjectName).dll</OutputFile>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="..\..\libKODI_game.cpp" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/lib/addons/library.kodi.game/project/VS2010Express/libKODI_game.vcxproj.filters b/lib/addons/library.kodi.game/project/VS2010Express/libKODI_game.vcxproj.filters
new file mode 100644
index 0000000..3609c12
--- /dev/null
+++ b/lib/addons/library.kodi.game/project/VS2010Express/libKODI_game.vcxproj.filters
@@ -0,0 +1,14 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\..\libKODI_game.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/lib/addons/library.xbmc.addon/libXBMC_addon.cpp b/lib/addons/library.xbmc.addon/libXBMC_addon.cpp
index e376885..50738d9 100644
--- a/lib/addons/library.xbmc.addon/libXBMC_addon.cpp
+++ b/lib/addons/library.xbmc.addon/libXBMC_addon.cpp
@@ -78,14 +78,6 @@ DLLEXPORT bool XBMC_get_setting(void *hdl, void* cb, const char* settingName, vo
   return ((CB_AddOnLib*)cb)->GetSetting(((AddonCB*)hdl)->addonData, settingName, settingValue);
 }
 
-DLLEXPORT char* XBMC_translate_special(void *hdl, void* cb, const char* source)
-{
-  if (cb == NULL)
-    return NULL;
-
-  return ((CB_AddOnLib*)cb)->TranslateSpecialProtocol(source);
-}
-
 DLLEXPORT void XBMC_queue_notification(void *hdl, void* cb, const queue_msg_t type, const char *msg)
 {
   if (cb == NULL)
diff --git a/project/BuildDependencies/DownloadMingwBuildEnv.bat b/project/BuildDependencies/DownloadMingwBuildEnv.bat
index 616c718..2247d0f 100644
--- a/project/BuildDependencies/DownloadMingwBuildEnv.bat
+++ b/project/BuildDependencies/DownloadMingwBuildEnv.bat
@@ -28,7 +28,7 @@ set build32=yes
 set build64=no
 set instdir=%CD%
 set msyspackages=autoconf automake libtool m4 make gettext patch pkg-config wget p7zip coreutils
-set mingwpackages=dlfcn gcc gcc-libs gettext libiconv libgpg-error libpng yasm nettle libtasn1 openssl
+set mingwpackages=dlfcn gcc gcc-libs gettext libiconv libgpg-error libpng yasm dcadec nettle libtasn1 openssl
 set locals32=gnutls-3.4.9-static
 set locals64=gnutls-3.4.9-static
 set usemirror=yes
diff --git a/project/VS2010Express/XBMC for Windows.sln b/project/VS2010Express/XBMC for Windows.sln
index e2c0c65..22fcd51 100644
--- a/project/VS2010Express/XBMC for Windows.sln	
+++ b/project/VS2010Express/XBMC for Windows.sln	
@@ -43,6 +43,8 @@ Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libKODI_inputstream", "..\.
 EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libKODI_peripheral", "..\..\lib\addons\library.kodi.peripheral\project\VS2010Express\libKODI_peripheral.vcxproj", "{FEA71D39-CB68-486B-A978-246E661A3F89}"
 EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libKODI_game", "..\..\lib\addons\library.kodi.game\project\VS2010Express\libKODI_game.vcxproj", "{1400C916-B4AD-41D7-ACEE-A853F3B89B38}"
+EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
 		Debug Testsuite|Win32 = Debug Testsuite|Win32
@@ -153,6 +155,12 @@ Global
 		{FEA71D39-CB68-486B-A978-246E661A3F89}.Debug|Win32.Build.0 = Debug|Win32
 		{FEA71D39-CB68-486B-A978-246E661A3F89}.Release|Win32.ActiveCfg = Release|Win32
 		{FEA71D39-CB68-486B-A978-246E661A3F89}.Release|Win32.Build.0 = Release|Win32
+		{1400C916-B4AD-41D7-ACEE-A853F3B89B38}.Debug Testsuite|Win32.ActiveCfg = Debug|Win32
+		{1400C916-B4AD-41D7-ACEE-A853F3B89B38}.Debug Testsuite|Win32.Build.0 = Debug|Win32
+		{1400C916-B4AD-41D7-ACEE-A853F3B89B38}.Debug|Win32.ActiveCfg = Debug|Win32
+		{1400C916-B4AD-41D7-ACEE-A853F3B89B38}.Debug|Win32.Build.0 = Debug|Win32
+		{1400C916-B4AD-41D7-ACEE-A853F3B89B38}.Release|Win32.ActiveCfg = Release|Win32
+		{1400C916-B4AD-41D7-ACEE-A853F3B89B38}.Release|Win32.Build.0 = Release|Win32
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
diff --git a/project/VS2010Express/XBMC.vcxproj b/project/VS2010Express/XBMC.vcxproj
index 3a9c265..732611f 100644
--- a/project/VS2010Express/XBMC.vcxproj
+++ b/project/VS2010Express/XBMC.vcxproj
@@ -96,7 +96,7 @@
       <IgnoreSpecificDefaultLibraries>libcpmt;libc;msvcrt;libcmt;msvcrtd;msvcprtd;%(IgnoreSpecificDefaultLibraries)</IgnoreSpecificDefaultLibraries>
       <ModuleDefinitionFile>
       </ModuleDefinitionFile>
-      <DelayLoadDLLs>zlib.dll;libmysql.dll;libxslt.dll;dnssd.dll;dwmapi.dll;ssh.dll;sqlite3.dll;avcodec-57.dll;avfilter-6.dll;avformat-57.dll;avutil-55.dll;postproc-54.dll;swresample-2.dll;swscale-4.dll;d3dcompiler_47.dll;%(DelayLoadDLLs)</DelayLoadDLLs>
+      <DelayLoadDLLs>libmysql.dll;libxslt.dll;dnssd.dll;dwmapi.dll;ssh.dll;sqlite3.dll;avcodec-56.dll;avfilter-5.dll;avformat-56.dll;avutil-54.dll;postproc-53.dll;swresample-1.dll;swscale-3.dll;d3dcompiler_47.dll;%(DelayLoadDLLs)</DelayLoadDLLs>
       <ProgramDatabaseFile>$(OutDir)$(ProjectName).pdb</ProgramDatabaseFile>
       <EntryPointSymbol>
       </EntryPointSymbol>
@@ -134,7 +134,7 @@
       <IgnoreSpecificDefaultLibraries>libc;msvcrt;libcmt;msvcrtd;msvcprtd;%(IgnoreSpecificDefaultLibraries)</IgnoreSpecificDefaultLibraries>
       <ModuleDefinitionFile>
       </ModuleDefinitionFile>
-      <DelayLoadDLLs>libxslt.dll;dnssd.dll;dwmapi.dll;ssh.dll;sqlite3.dll;avcodec-57.dll;avfilter-6.dll;avformat-57.dll;avutil-55.dll;postproc-54.dll;swresample-2.dll;swscale-4.dll;d3dcompiler_47.dll;%(DelayLoadDLLs)</DelayLoadDLLs>
+      <DelayLoadDLLs>libxslt.dll;dnssd.dll;dwmapi.dll;ssh.dll;sqlite3.dll;avcodec-56.dll;avfilter-5.dll;avformat-56.dll;avutil-54.dll;postproc-53.dll;swresample-1.dll;swscale-3.dll;d3dcompiler_47.dll;%(DelayLoadDLLs)</DelayLoadDLLs>
       <ProgramDatabaseFile>$(OutDir)$(ProjectName).pdb</ProgramDatabaseFile>
       <SubSystem>Console</SubSystem>
       <EntryPointSymbol>
@@ -168,7 +168,7 @@
       <AdditionalDependencies>d3d11.lib;DInput8.lib;DSound.lib;winmm.lib;CrossGuid.lib;Mpr.lib;Iphlpapi.lib;PowrProf.lib;setupapi.lib;dwmapi.lib;yajl.lib;dxguid.lib;%(AdditionalDependencies)</AdditionalDependencies>
       <OutputFile>$(OutDir)$(ProjectName).exe</OutputFile>
       <IgnoreSpecificDefaultLibraries>libc;msvcrt;libci;msvcprt;%(IgnoreSpecificDefaultLibraries)</IgnoreSpecificDefaultLibraries>
-      <DelayLoadDLLs>zlib.dll;libmysql.dll;libxslt.dll;dnssd.dll;dwmapi.dll;ssh.dll;sqlite3.dll;avcodec-57.dll;avfilter-6.dll;avformat-57.dll;avutil-55.dll;postproc-54.dll;swresample-2.dll;swscale-4.dll;d3dcompiler_47.dll;%(DelayLoadDLLs)</DelayLoadDLLs>
+      <DelayLoadDLLs>libmysql.dll;libxslt.dll;dnssd.dll;dwmapi.dll;ssh.dll;sqlite3.dll;avcodec-56.dll;avfilter-5.dll;avformat-56.dll;avutil-54.dll;postproc-53.dll;swresample-1.dll;swscale-3.dll;d3dcompiler_47.dll;%(DelayLoadDLLs)</DelayLoadDLLs>
       <GenerateDebugInformation>true</GenerateDebugInformation>
       <ProgramDatabaseFile>$(OutDir)$(ProjectName).pdb</ProgramDatabaseFile>
       <RandomizedBaseAddress>true</RandomizedBaseAddress>
@@ -403,6 +403,8 @@
     <ClCompile Include="..\..\xbmc\filesystem\MultiPathFile.cpp" />
     <ClCompile Include="..\..\xbmc\filesystem\MusicDatabaseDirectory.cpp" />
     <ClCompile Include="..\..\xbmc\filesystem\MusicDatabaseDirectory\DirectoryNodeGrouped.cpp" />
+    <ClCompile Include="..\..\xbmc\games\GameSettings.cpp" />
+    <ClCompile Include="..\..\xbmc\games\tags\GameInfoTag.cpp" />
     <ClCompile Include="..\..\xbmc\input\joysticks\DefaultJoystick.cpp" />
     <ClCompile Include="..\..\xbmc\input\joysticks\generic\ButtonMapping.cpp" />
     <ClCompile Include="..\..\xbmc\input\joysticks\generic\FeatureHandling.cpp" />
@@ -1107,6 +1109,8 @@
     <ClInclude Include="..\..\xbmc\filesystem\DAVFile.h" />
     <ClInclude Include="..\..\xbmc\filesystem\ImageFile.h" />
     <ClInclude Include="..\..\xbmc\filesystem\MusicDatabaseDirectory\DirectoryNodeGrouped.h" />
+    <ClInclude Include="..\..\xbmc\games\GameSettings.h" />
+    <ClInclude Include="..\..\xbmc\games\tags\GameInfoTag.h" />
     <ClInclude Include="..\..\xbmc\input\joysticks\DefaultJoystick.h" />
     <ClInclude Include="..\..\xbmc\input\joysticks\generic\ButtonMapping.h" />
     <ClInclude Include="..\..\xbmc\input\joysticks\generic\FeatureHandling.h" />
@@ -1364,6 +1368,7 @@
     <ClInclude Include="..\..\xbmc\utils\win32\Win32InterfaceForCLog.h" />
     <ClInclude Include="..\..\xbmc\utils\win32\Win32Log.h" />
     <ClInclude Include="..\..\xbmc\utils\XSLTUtils.h" />
+    <ClInclude Include="..\..\xbmc\video\FFmpegVideoDecoder.h" />
     <ClInclude Include="..\..\xbmc\interfaces\python\swig.h" />
     <ClInclude Include="..\..\xbmc\interfaces\python\XBPython.h" />
     <ClInclude Include="..\..\xbmc\music\MusicDbUrl.h" />
@@ -1777,6 +1782,7 @@
     <ClCompile Include="..\..\xbmc\video\dialogs\GUIDialogVideoInfo.cpp" />
     <ClCompile Include="..\..\xbmc\video\dialogs\GUIDialogVideoOSD.cpp" />
     <ClCompile Include="..\..\xbmc\video\dialogs\GUIDialogVideoSettings.cpp" />
+    <ClCompile Include="..\..\xbmc\video\FFmpegVideoDecoder.cpp" />
     <ClCompile Include="..\..\xbmc\video\GUIViewStateVideo.cpp" />
     <ClCompile Include="..\..\xbmc\video\Teletext.cpp" />
     <ClCompile Include="..\..\xbmc\video\VideoDatabase.cpp" />
diff --git a/project/VS2010Express/XBMC.vcxproj.filters b/project/VS2010Express/XBMC.vcxproj.filters
index f0960a9..13d5fca 100644
--- a/project/VS2010Express/XBMC.vcxproj.filters
+++ b/project/VS2010Express/XBMC.vcxproj.filters
@@ -2617,6 +2617,9 @@
     <ClCompile Include="..\..\xbmc\interfaces\python\PyContext.cpp">
       <Filter>interfaces\python</Filter>
     </ClCompile>
+    <ClCompile Include="..\..\xbmc\video\FFmpegVideoDecoder.cpp">
+      <Filter>video</Filter>
+    </ClCompile>
     <ClCompile Include="..\..\xbmc\view\GUIViewControl.cpp">
       <Filter>view</Filter>
     </ClCompile>
@@ -5715,6 +5718,9 @@
     <ClInclude Include="..\..\xbmc\guilib\imagefactory.h">
       <Filter>guilib</Filter>
     </ClInclude>
+    <ClInclude Include="..\..\xbmc\video\FFmpegVideoDecoder.h">
+      <Filter>video</Filter>
+    </ClInclude>
     <ClInclude Include="..\..\xbmc\view\GUIViewControl.h">
       <Filter>view</Filter>
     </ClInclude>
@@ -6812,4 +6818,4 @@
       <Filter>shaders</Filter>
     </FxCompile>
   </ItemGroup>
-</Project>
+</Project>
\ No newline at end of file
diff --git a/project/Win32BuildSetup/BuildSetup.bat b/project/Win32BuildSetup/BuildSetup.bat
index f2cb163..f3e1d8e 100644
--- a/project/Win32BuildSetup/BuildSetup.bat
+++ b/project/Win32BuildSetup/BuildSetup.bat
@@ -19,7 +19,6 @@ rem clean to force a full rebuild
 rem noclean to force a build without clean
 rem noprompt to avoid all prompts
 rem nomingwlibs to skip building all libs built with mingw
-rem cmake to build with cmake instead of VS solution
 CLS
 COLOR 1B
 TITLE %APP_NAME% for Windows Build Script
@@ -36,16 +35,14 @@ SET buildmingwlibs=true
 SET buildbinaryaddons=true
 SET exitcode=0
 SET useshell=rxvt
-SET cmake=0
 SET BRANCH=na
-FOR %%b in (%1, %2, %3, %4, %5, %6) DO (
+FOR %%b in (%1, %2, %3, %4, %5) DO (
   IF %%b==clean SET buildmode=clean
   IF %%b==noclean SET buildmode=noclean
   IF %%b==noprompt SET promptlevel=noprompt
   IF %%b==nomingwlibs SET buildmingwlibs=false
   IF %%b==nobinaryaddons SET buildbinaryaddons=false
   IF %%b==sh SET useshell=sh
-  IF %%b==cmake SET cmake=1
 )
 
 SET buildconfig=Release
@@ -121,7 +118,6 @@ set WORKSPACE=%CD%\..\..
       goto DIE
     )
   )
-  IF %cmake%==1 goto COMPILE_CMAKE_EXE
   IF %buildmode%==clean goto COMPILE_EXE
   goto COMPILE_NO_CLEAN_EXE
   
@@ -161,40 +157,6 @@ set WORKSPACE=%CD%\..\..
   ECHO ------------------------------------------------------------
   GOTO MAKE_BUILD_EXE
 
-
-:COMPILE_CMAKE_EXE
-  ECHO Wait while preparing the build.
-  ECHO ------------------------------------------------------------
-  ECHO Compiling %APP_NAME% branch %BRANCH%...
-
-  IF %buildmode%==clean (
-    RMDIR /S /Q %WORKSPACE%\kodi-build
-  )
-  MKDIR %WORKSPACE%\kodi-build
-  PUSHD %WORKSPACE%\kodi-build
-
-  cmake.exe -G "Visual Studio 14" %WORKSPACE%\project\cmake
-  IF %errorlevel%==1 (
-    set DIETEXT="%APP_NAME%.EXE failed to build!"
-    goto DIE
-  )
-
-  cmake.exe --build . --config "%buildconfig%"
-  IF %errorlevel%==1 (
-    set DIETEXT="%APP_NAME%.EXE failed to build!"
-    goto DIE
-  )
-
-  set EXE="%WORKSPACE%\kodi-build\%buildconfig%\%APP_NAME%.exe"
-  set PDB="%WORKSPACE%\kodi-build\%buildconfig%\%APP_NAME%.pdb"
-  set D3D="%WORKSPACE%\kodi-build\D3DCompile*.DLL"
-
-  POPD
-  ECHO Done!
-  ECHO ------------------------------------------------------------
-  GOTO MAKE_BUILD_EXE
-
-
 :MAKE_BUILD_EXE
   ECHO Copying files...
   IF EXIST BUILD_WIN32 rmdir BUILD_WIN32 /S /Q
@@ -223,6 +185,11 @@ set WORKSPACE=%CD%\..\..
   Echo userdata\database\>>exclude.txt
   Echo userdata\playlists\>>exclude.txt
   Echo userdata\thumbnails\>>exclude.txt
+  rem Exclude non Windows addons
+  Echo addons\repository.pvr-android.xbmc.org\>>exclude.txt
+  Echo addons\repository.pvr-ios.xbmc.org\>>exclude.txt
+  Echo addons\repository.pvr-osx32.xbmc.org\>>exclude.txt
+  Echo addons\repository.pvr-osx64.xbmc.org\>>exclude.txt
   rem Exclude skins as they're copied by their own script
   Echo addons\skin.estuary\>>exclude.txt
   Echo addons\skin.estouchy\>>exclude.txt
diff --git a/project/Win32BuildSetup/genNsisIncludes.bat b/project/Win32BuildSetup/genNsisIncludes.bat
index 037a9fc..f0ea95a 100644
--- a/project/Win32BuildSetup/genNsisIncludes.bat
+++ b/project/Win32BuildSetup/genNsisIncludes.bat
@@ -28,6 +28,22 @@ IF EXIST BUILD_WIN32\addons\pvr.* (
 )
 
 SET Counter=1
+IF EXIST BUILD_WIN32\addons\game.libretro.* (
+  ECHO SectionGroup "Game Add-ons" SecGameAddons >> game-addons.nsi
+  FOR /F "tokens=*" %%P IN ('dir /B /AD BUILD_WIN32\addons\game.libretro.*') DO (
+    SET "output=%%P"
+    SET output=!output:game.=!
+    ECHO Section "!output!" SecGameAddons!Counter! >> game-addons.nsi
+    ECHO SectionIn 1 #section is in installtype Full >> game-addons.nsi
+    ECHO SetOutPath "$INSTDIR\addons\%%P" >> game-addons.nsi
+    ECHO File /r "${app_root}\addons\%%P\*.*" >> game-addons.nsi
+    ECHO SectionEnd >> game-addons.nsi
+    SET /A Counter = !Counter! + 1
+    )
+  ECHO SectionGroupEnd >> game-addons.nsi
+)
+
+SET Counter=1
 IF EXIST BUILD_WIN32\addons\audiodecoder.* (
   ECHO SectionGroup "Audio Decoder Add-ons" SecAudioDecoderAddons >> audiodecoder-addons.nsi
   FOR /F "tokens=*" %%P IN ('dir /B /AD BUILD_WIN32\addons\audiodecoder.*') DO (
diff --git a/project/Win32BuildSetup/genNsisInstaller.nsi b/project/Win32BuildSetup/genNsisInstaller.nsi
index ac450df..f988947 100644
--- a/project/Win32BuildSetup/genNsisInstaller.nsi
+++ b/project/Win32BuildSetup/genNsisInstaller.nsi
@@ -283,6 +283,7 @@ SectionEnd
 !include /nonfatal "audiodecoder-addons.nsi"
 !include /nonfatal "audioencoder-addons.nsi"
 !include /nonfatal "audiodsp-addons.nsi"
+!include /nonfatal "game-addons.nsi"
 !include /nonfatal "inputstream-addons.nsi"
 !include /nonfatal "pvr-addons.nsi"
 ;!include /nonfatal "skin-addons.nsi"
@@ -369,6 +370,16 @@ SectionEnd
 ;--------------------------------
 ;vs redist installer Section
 SectionGroup "Microsoft Visual C++ packages" SEC_VCREDIST
+Section "VS2008 C++ re-distributable Package (x86)" SEC_VCREDIST1
+  ;vc90 for python
+  DetailPrint "Running VS2008 re-distributable setup..."
+  SectionIn 1 2 #section is in install type Full 
+  SetOutPath "$TEMP\vc2008"
+  File "${app_root}\..\dependencies\vcredist\2008\vcredist_x86.exe"
+  ExecWait '"$TEMP\vc2008\vcredist_x86.exe" /q' $VSRedistSetupError
+  RMDir /r "$TEMP\vc2008"
+  DetailPrint "Finished VS2008 re-distributable setup"
+SectionEnd
 
 Section "VS2010 C++ re-distributable Package (x86)" SEC_VCREDIST2
   DetailPrint "Running VS2010 re-distributable setup..."
diff --git a/project/Win32BuildSetup/getdeploydependencies.bat b/project/Win32BuildSetup/getdeploydependencies.bat
index 06fb745..a3e2d78 100644
--- a/project/Win32BuildSetup/getdeploydependencies.bat
+++ b/project/Win32BuildSetup/getdeploydependencies.bat
@@ -8,10 +8,15 @@ echo Downloading from mirror %KODI_MIRROR%
 :: Following commands expect this script's parent directory to be the current directory, so make sure that's so
 PUSHD %~dp0
 
+if not exist dependencies\vcredist\2008 mkdir dependencies\vcredist\2008
 if not exist dependencies\vcredist\2010 mkdir dependencies\vcredist\2010
 if not exist dependencies\vcredist\2013 mkdir dependencies\vcredist\2013
 if not exist dependencies\vcredist\2015 mkdir dependencies\vcredist\2015
 
+if not exist dependencies\vcredist\2008\vcredist_x86.exe (
+  echo Downloading vc90 redist...
+  ..\BuildDependencies\bin\wget -nv -O dependencies\vcredist\2008\vcredist_x86.exe %KODI_MIRROR%/build-deps/win32/vcredist/2008/vcredist_x86.exe
+)
 if not exist dependencies\vcredist\2010\vcredist_x86.exe (
   echo Downloading vc100 redist...
   ..\BuildDependencies\bin\wget -nv -O dependencies\vcredist\2010\vcredist_x86.exe %KODI_MIRROR%/build-deps/win32/vcredist/2010/vcredist_x86.exe
diff --git a/project/cmake/CMakeLists.txt b/project/cmake/CMakeLists.txt
index 8def4fc..f96f3fe 100644
--- a/project/cmake/CMakeLists.txt
+++ b/project/cmake/CMakeLists.txt
@@ -57,9 +57,6 @@ endif()
 get_filename_component(CORE_SOURCE_DIR ${PROJECT_SOURCE_DIR}/../.. ABSOLUTE)
 set(CORE_BUILD_DIR build)
 
-message(STATUS "Source directory: ${CORE_SOURCE_DIR}")
-message(STATUS "Build directory: ${CMAKE_BINARY_DIR}")
-
 include(scripts/common/generatorsetup.cmake)
 include(scripts/common/addoptions.cmake)
 include(scripts/common/archsetup.cmake)
diff --git a/project/cmake/README.md b/project/cmake/README.md
index 28af525..c0f94d8 100644
--- a/project/cmake/README.md
+++ b/project/cmake/README.md
@@ -8,7 +8,7 @@ executable (but no packaging or dependency management yet) for the following
 platforms:
 
 - Linux (GNU Makefiles)
-- Windows (NMake Makefiles, Visual Studio 14 (2015))
+- Windows (NMake Makefiles, Visual Studio 12 (2013))
 - OSX (GNU Makefiles, Xcode)
 - Android (GNU Makefiles)
 
@@ -107,7 +107,7 @@ kodi.exe
 ### Windows with Visual Studio project files
 
 ```
-cmake -G "Visual Studio 14" <KODI_SRC>/project/cmake/
+cmake -G "Visual Studio 12" <KODI_SRC>/project/cmake/
 cmake --build . --config "Debug"  # or: Build solution with Visual Studio
 set KODI_HOME="%CD%" && Debug\kodi.exe
 ```
diff --git a/project/cmake/addons/addons/game.libretro.2048/game.libretro.2048.txt b/project/cmake/addons/addons/game.libretro.2048/game.libretro.2048.txt
new file mode 100644
index 0000000..638d886
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.2048/game.libretro.2048.txt
@@ -0,0 +1 @@
+game.libretro.2048 https://github.com/kodi-game/game.libretro.2048 master
diff --git a/project/cmake/addons/addons/game.libretro.2048/platforms.txt b/project/cmake/addons/addons/game.libretro.2048/platforms.txt
new file mode 100644
index 0000000..0702cb5
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.2048/platforms.txt
@@ -0,0 +1 @@
+all
diff --git a/project/cmake/addons/addons/game.libretro.beetle-bsnes/game.libretro.beetle-bsnes.txt b/project/cmake/addons/addons/game.libretro.beetle-bsnes/game.libretro.beetle-bsnes.txt
new file mode 100644
index 0000000..bbde9e4
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.beetle-bsnes/game.libretro.beetle-bsnes.txt
@@ -0,0 +1 @@
+game.libretro.beetle-bsnes https://github.com/kodi-game/game.libretro.beetle-bsnes master
diff --git a/project/cmake/addons/addons/game.libretro.beetle-bsnes/platforms.txt b/project/cmake/addons/addons/game.libretro.beetle-bsnes/platforms.txt
new file mode 100644
index 0000000..0702cb5
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.beetle-bsnes/platforms.txt
@@ -0,0 +1 @@
+all
diff --git a/project/cmake/addons/addons/game.libretro.beetle-gba/game.libretro.beetle-gba.txt b/project/cmake/addons/addons/game.libretro.beetle-gba/game.libretro.beetle-gba.txt
new file mode 100644
index 0000000..56360e8
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.beetle-gba/game.libretro.beetle-gba.txt
@@ -0,0 +1 @@
+game.libretro.beetle-gba https://github.com/kodi-game/game.libretro.beetle-gba master
diff --git a/project/cmake/addons/addons/game.libretro.beetle-gba/platforms.txt b/project/cmake/addons/addons/game.libretro.beetle-gba/platforms.txt
new file mode 100644
index 0000000..0702cb5
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.beetle-gba/platforms.txt
@@ -0,0 +1 @@
+all
diff --git a/project/cmake/addons/addons/game.libretro.beetle-lynx/game.libretro.beetle-lynx.txt b/project/cmake/addons/addons/game.libretro.beetle-lynx/game.libretro.beetle-lynx.txt
new file mode 100644
index 0000000..987b4f7
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.beetle-lynx/game.libretro.beetle-lynx.txt
@@ -0,0 +1 @@
+game.libretro.beetle-lynx https://github.com/kodi-game/game.libretro.beetle-lynx master
diff --git a/project/cmake/addons/addons/game.libretro.beetle-lynx/platforms.txt b/project/cmake/addons/addons/game.libretro.beetle-lynx/platforms.txt
new file mode 100644
index 0000000..0702cb5
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.beetle-lynx/platforms.txt
@@ -0,0 +1 @@
+all
diff --git a/project/cmake/addons/addons/game.libretro.beetle-ngp/game.libretro.beetle-ngp.txt b/project/cmake/addons/addons/game.libretro.beetle-ngp/game.libretro.beetle-ngp.txt
new file mode 100644
index 0000000..9b35867
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.beetle-ngp/game.libretro.beetle-ngp.txt
@@ -0,0 +1 @@
+game.libretro.beetle-ngp https://github.com/kodi-game/game.libretro.beetle-ngp master
diff --git a/project/cmake/addons/addons/game.libretro.beetle-ngp/platforms.txt b/project/cmake/addons/addons/game.libretro.beetle-ngp/platforms.txt
new file mode 100644
index 0000000..0702cb5
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.beetle-ngp/platforms.txt
@@ -0,0 +1 @@
+all
diff --git a/project/cmake/addons/addons/game.libretro.beetle-pce-fast/game.libretro.beetle-pce-fast.txt b/project/cmake/addons/addons/game.libretro.beetle-pce-fast/game.libretro.beetle-pce-fast.txt
new file mode 100644
index 0000000..c36b020
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.beetle-pce-fast/game.libretro.beetle-pce-fast.txt
@@ -0,0 +1 @@
+game.libretro.beetle-pce-fast https://github.com/kodi-game/game.libretro.beetle-pce-fast master
diff --git a/project/cmake/addons/addons/game.libretro.beetle-pce-fast/platforms.txt b/project/cmake/addons/addons/game.libretro.beetle-pce-fast/platforms.txt
new file mode 100644
index 0000000..0702cb5
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.beetle-pce-fast/platforms.txt
@@ -0,0 +1 @@
+all
diff --git a/project/cmake/addons/addons/game.libretro.beetle-psx/game.libretro.beetle-psx.txt b/project/cmake/addons/addons/game.libretro.beetle-psx/game.libretro.beetle-psx.txt
new file mode 100644
index 0000000..94ea7a3
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.beetle-psx/game.libretro.beetle-psx.txt
@@ -0,0 +1 @@
+game.libretro.beetle-psx https://github.com/kodi-game/game.libretro.beetle-psx master
diff --git a/project/cmake/addons/addons/game.libretro.beetle-psx/platforms.txt b/project/cmake/addons/addons/game.libretro.beetle-psx/platforms.txt
new file mode 100644
index 0000000..0702cb5
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.beetle-psx/platforms.txt
@@ -0,0 +1 @@
+all
diff --git a/project/cmake/addons/addons/game.libretro.bluemsx/game.libretro.bluemsx.txt b/project/cmake/addons/addons/game.libretro.bluemsx/game.libretro.bluemsx.txt
new file mode 100644
index 0000000..8a14ad7
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.bluemsx/game.libretro.bluemsx.txt
@@ -0,0 +1 @@
+game.libretro.bluemsx https://github.com/kodi-game/game.libretro.bluemsx master
diff --git a/project/cmake/addons/addons/game.libretro.bluemsx/platforms.txt b/project/cmake/addons/addons/game.libretro.bluemsx/platforms.txt
new file mode 100644
index 0000000..0702cb5
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.bluemsx/platforms.txt
@@ -0,0 +1 @@
+all
diff --git a/project/cmake/addons/addons/game.libretro.bnes/game.libretro.bnes.txt b/project/cmake/addons/addons/game.libretro.bnes/game.libretro.bnes.txt
new file mode 100644
index 0000000..1976fcc
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.bnes/game.libretro.bnes.txt
@@ -0,0 +1 @@
+game.libretro.bnes https://github.com/kodi-game/game.libretro.bnes master
diff --git a/project/cmake/addons/addons/game.libretro.bnes/platforms.txt b/project/cmake/addons/addons/game.libretro.bnes/platforms.txt
new file mode 100644
index 0000000..0702cb5
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.bnes/platforms.txt
@@ -0,0 +1 @@
+all
diff --git a/project/cmake/addons/addons/game.libretro.bsnes-mercury-accuracy/game.libretro.bsnes-mercury-accuracy.txt b/project/cmake/addons/addons/game.libretro.bsnes-mercury-accuracy/game.libretro.bsnes-mercury-accuracy.txt
new file mode 100644
index 0000000..2f3b3d1
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.bsnes-mercury-accuracy/game.libretro.bsnes-mercury-accuracy.txt
@@ -0,0 +1 @@
+game.libretro.bsnes-mercury-accuracy https://github.com/kodi-game/game.libretro.bsnes-mercury-accuracy master
diff --git a/project/cmake/addons/addons/game.libretro.bsnes-mercury-accuracy/platforms.txt b/project/cmake/addons/addons/game.libretro.bsnes-mercury-accuracy/platforms.txt
new file mode 100644
index 0000000..0702cb5
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.bsnes-mercury-accuracy/platforms.txt
@@ -0,0 +1 @@
+all
diff --git a/project/cmake/addons/addons/game.libretro.bsnes-mercury-balanced/game.libretro.bsnes-mercury-balanced.txt b/project/cmake/addons/addons/game.libretro.bsnes-mercury-balanced/game.libretro.bsnes-mercury-balanced.txt
new file mode 100644
index 0000000..78a9684
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.bsnes-mercury-balanced/game.libretro.bsnes-mercury-balanced.txt
@@ -0,0 +1 @@
+game.libretro.bsnes-mercury-balanced https://github.com/kodi-game/game.libretro.bsnes-mercury-balanced master
diff --git a/project/cmake/addons/addons/game.libretro.bsnes-mercury-balanced/platforms.txt b/project/cmake/addons/addons/game.libretro.bsnes-mercury-balanced/platforms.txt
new file mode 100644
index 0000000..0702cb5
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.bsnes-mercury-balanced/platforms.txt
@@ -0,0 +1 @@
+all
diff --git a/project/cmake/addons/addons/game.libretro.bsnes-mercury-performance/game.libretro.bsnes-mercury-performance.txt b/project/cmake/addons/addons/game.libretro.bsnes-mercury-performance/game.libretro.bsnes-mercury-performance.txt
new file mode 100644
index 0000000..127fe6d
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.bsnes-mercury-performance/game.libretro.bsnes-mercury-performance.txt
@@ -0,0 +1 @@
+game.libretro.bsnes-mercury-performance https://github.com/kodi-game/game.libretro.bsnes-mercury-performance master
diff --git a/project/cmake/addons/addons/game.libretro.bsnes-mercury-performance/platforms.txt b/project/cmake/addons/addons/game.libretro.bsnes-mercury-performance/platforms.txt
new file mode 100644
index 0000000..0702cb5
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.bsnes-mercury-performance/platforms.txt
@@ -0,0 +1 @@
+all
diff --git a/project/cmake/addons/addons/game.libretro.dosbox/game.libretro.dosbox.txt b/project/cmake/addons/addons/game.libretro.dosbox/game.libretro.dosbox.txt
new file mode 100644
index 0000000..2a9cdd4
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.dosbox/game.libretro.dosbox.txt
@@ -0,0 +1 @@
+game.libretro.dosbox https://github.com/kodi-game/game.libretro.dosbox master
diff --git a/project/cmake/addons/addons/game.libretro.dosbox/platforms.txt b/project/cmake/addons/addons/game.libretro.dosbox/platforms.txt
new file mode 100644
index 0000000..0702cb5
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.dosbox/platforms.txt
@@ -0,0 +1 @@
+all
diff --git a/project/cmake/addons/addons/game.libretro.fceumm/game.libretro.fceumm.txt b/project/cmake/addons/addons/game.libretro.fceumm/game.libretro.fceumm.txt
new file mode 100644
index 0000000..6228996
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.fceumm/game.libretro.fceumm.txt
@@ -0,0 +1 @@
+game.libretro.fceumm https://github.com/kodi-game/game.libretro.fceumm master
diff --git a/project/cmake/addons/addons/game.libretro.fceumm/platforms.txt b/project/cmake/addons/addons/game.libretro.fceumm/platforms.txt
new file mode 100644
index 0000000..0702cb5
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.fceumm/platforms.txt
@@ -0,0 +1 @@
+all
diff --git a/project/cmake/addons/addons/game.libretro.gambatte/game.libretro.gambatte.txt b/project/cmake/addons/addons/game.libretro.gambatte/game.libretro.gambatte.txt
new file mode 100644
index 0000000..b809a52
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.gambatte/game.libretro.gambatte.txt
@@ -0,0 +1 @@
+game.libretro.gambatte https://github.com/kodi-game/game.libretro.gambatte master
diff --git a/project/cmake/addons/addons/game.libretro.gambatte/platforms.txt b/project/cmake/addons/addons/game.libretro.gambatte/platforms.txt
new file mode 100644
index 0000000..0702cb5
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.gambatte/platforms.txt
@@ -0,0 +1 @@
+all
diff --git a/project/cmake/addons/addons/game.libretro.genplus/game.libretro.genplus.txt b/project/cmake/addons/addons/game.libretro.genplus/game.libretro.genplus.txt
new file mode 100644
index 0000000..144a6d5
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.genplus/game.libretro.genplus.txt
@@ -0,0 +1 @@
+game.libretro.genplus https://github.com/kodi-game/game.libretro.genplus master
diff --git a/project/cmake/addons/addons/game.libretro.genplus/platforms.txt b/project/cmake/addons/addons/game.libretro.genplus/platforms.txt
new file mode 100644
index 0000000..0702cb5
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.genplus/platforms.txt
@@ -0,0 +1 @@
+all
diff --git a/project/cmake/addons/addons/game.libretro.handy/game.libretro.handy.txt b/project/cmake/addons/addons/game.libretro.handy/game.libretro.handy.txt
new file mode 100644
index 0000000..c478ceb
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.handy/game.libretro.handy.txt
@@ -0,0 +1 @@
+game.libretro.handy https://github.com/kodi-game/game.libretro.handy master
diff --git a/project/cmake/addons/addons/game.libretro.handy/platforms.txt b/project/cmake/addons/addons/game.libretro.handy/platforms.txt
new file mode 100644
index 0000000..0702cb5
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.handy/platforms.txt
@@ -0,0 +1 @@
+all
diff --git a/project/cmake/addons/addons/game.libretro.mame/game.libretro.mame.txt b/project/cmake/addons/addons/game.libretro.mame/game.libretro.mame.txt
new file mode 100644
index 0000000..a81a4d6
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.mame/game.libretro.mame.txt
@@ -0,0 +1 @@
+game.libretro.mame https://github.com/kodi-game/game.libretro.mame master
diff --git a/project/cmake/addons/addons/game.libretro.mame/platforms.txt b/project/cmake/addons/addons/game.libretro.mame/platforms.txt
new file mode 100644
index 0000000..0702cb5
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.mame/platforms.txt
@@ -0,0 +1 @@
+all
diff --git a/project/cmake/addons/addons/game.libretro.meteor/game.libretro.meteor.txt b/project/cmake/addons/addons/game.libretro.meteor/game.libretro.meteor.txt
new file mode 100644
index 0000000..36966d1
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.meteor/game.libretro.meteor.txt
@@ -0,0 +1 @@
+game.libretro.meteor https://github.com/kodi-game/game.libretro.meteor master
diff --git a/project/cmake/addons/addons/game.libretro.meteor/platforms.txt b/project/cmake/addons/addons/game.libretro.meteor/platforms.txt
new file mode 100644
index 0000000..0702cb5
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.meteor/platforms.txt
@@ -0,0 +1 @@
+all
diff --git a/project/cmake/addons/addons/game.libretro.mgba/game.libretro.mgba.txt b/project/cmake/addons/addons/game.libretro.mgba/game.libretro.mgba.txt
new file mode 100644
index 0000000..57ade8a
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.mgba/game.libretro.mgba.txt
@@ -0,0 +1 @@
+game.libretro.mgba https://github.com/kodi-game/game.libretro.mgba master
diff --git a/project/cmake/addons/addons/game.libretro.mgba/platforms.txt b/project/cmake/addons/addons/game.libretro.mgba/platforms.txt
new file mode 100644
index 0000000..0702cb5
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.mgba/platforms.txt
@@ -0,0 +1 @@
+all
diff --git a/project/cmake/addons/addons/game.libretro.mupen64plus/game.libretro.mupen64plus.txt b/project/cmake/addons/addons/game.libretro.mupen64plus/game.libretro.mupen64plus.txt
new file mode 100644
index 0000000..1beb1a6
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.mupen64plus/game.libretro.mupen64plus.txt
@@ -0,0 +1 @@
+game.libretro.mupen64plus https://github.com/kodi-game/game.libretro.mupen64plus master
diff --git a/project/cmake/addons/addons/game.libretro.mupen64plus/platforms.txt b/project/cmake/addons/addons/game.libretro.mupen64plus/platforms.txt
new file mode 100644
index 0000000..0702cb5
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.mupen64plus/platforms.txt
@@ -0,0 +1 @@
+all
diff --git a/project/cmake/addons/addons/game.libretro.nestopia/game.libretro.nestopia.txt b/project/cmake/addons/addons/game.libretro.nestopia/game.libretro.nestopia.txt
new file mode 100644
index 0000000..ae61052
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.nestopia/game.libretro.nestopia.txt
@@ -0,0 +1 @@
+game.libretro.nestopia https://github.com/kodi-game/game.libretro.nestopia master
diff --git a/project/cmake/addons/addons/game.libretro.nestopia/platforms.txt b/project/cmake/addons/addons/game.libretro.nestopia/platforms.txt
new file mode 100644
index 0000000..0702cb5
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.nestopia/platforms.txt
@@ -0,0 +1 @@
+all
diff --git a/project/cmake/addons/addons/game.libretro.pcsx-rearmed/game.libretro.pcsx-rearmed.txt b/project/cmake/addons/addons/game.libretro.pcsx-rearmed/game.libretro.pcsx-rearmed.txt
new file mode 100644
index 0000000..f6be498
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.pcsx-rearmed/game.libretro.pcsx-rearmed.txt
@@ -0,0 +1 @@
+game.libretro.pcsx-rearmed https://github.com/kodi-game/game.libretro.pcsx-rearmed master
diff --git a/project/cmake/addons/addons/game.libretro.pcsx-rearmed/platforms.txt b/project/cmake/addons/addons/game.libretro.pcsx-rearmed/platforms.txt
new file mode 100644
index 0000000..0b3e5d7
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.pcsx-rearmed/platforms.txt
@@ -0,0 +1 @@
+!windows
diff --git a/project/cmake/addons/addons/game.libretro.picodrive/game.libretro.picodrive.txt b/project/cmake/addons/addons/game.libretro.picodrive/game.libretro.picodrive.txt
new file mode 100644
index 0000000..88fb20c
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.picodrive/game.libretro.picodrive.txt
@@ -0,0 +1 @@
+game.libretro.picodrive https://github.com/kodi-game/game.libretro.picodrive master
diff --git a/project/cmake/addons/addons/game.libretro.picodrive/platforms.txt b/project/cmake/addons/addons/game.libretro.picodrive/platforms.txt
new file mode 100644
index 0000000..0702cb5
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.picodrive/platforms.txt
@@ -0,0 +1 @@
+all
diff --git a/project/cmake/addons/addons/game.libretro.quicknes/game.libretro.quicknes.txt b/project/cmake/addons/addons/game.libretro.quicknes/game.libretro.quicknes.txt
new file mode 100644
index 0000000..6649b9b
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.quicknes/game.libretro.quicknes.txt
@@ -0,0 +1 @@
+game.libretro.quicknes https://github.com/kodi-game/game.libretro.quicknes master
diff --git a/project/cmake/addons/addons/game.libretro.quicknes/platforms.txt b/project/cmake/addons/addons/game.libretro.quicknes/platforms.txt
new file mode 100644
index 0000000..0702cb5
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.quicknes/platforms.txt
@@ -0,0 +1 @@
+all
diff --git a/project/cmake/addons/addons/game.libretro.reicast/game.libretro.reicast.txt b/project/cmake/addons/addons/game.libretro.reicast/game.libretro.reicast.txt
new file mode 100644
index 0000000..516c5c8
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.reicast/game.libretro.reicast.txt
@@ -0,0 +1 @@
+game.libretro.reicast https://github.com/kodi-game/game.libretro.reicast master
diff --git a/project/cmake/addons/addons/game.libretro.reicast/platforms.txt b/project/cmake/addons/addons/game.libretro.reicast/platforms.txt
new file mode 100644
index 0000000..0b3e5d7
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.reicast/platforms.txt
@@ -0,0 +1 @@
+!windows
diff --git a/project/cmake/addons/addons/game.libretro.snes9x-next/game.libretro.snes9x-next.txt b/project/cmake/addons/addons/game.libretro.snes9x-next/game.libretro.snes9x-next.txt
new file mode 100644
index 0000000..817773c
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.snes9x-next/game.libretro.snes9x-next.txt
@@ -0,0 +1 @@
+game.libretro.snes9x-next https://github.com/kodi-game/game.libretro.snes9x-next master
diff --git a/project/cmake/addons/addons/game.libretro.snes9x-next/platforms.txt b/project/cmake/addons/addons/game.libretro.snes9x-next/platforms.txt
new file mode 100644
index 0000000..0702cb5
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.snes9x-next/platforms.txt
@@ -0,0 +1 @@
+all
diff --git a/project/cmake/addons/addons/game.libretro.snes9x/game.libretro.snes9x.txt b/project/cmake/addons/addons/game.libretro.snes9x/game.libretro.snes9x.txt
new file mode 100644
index 0000000..7bc9379
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.snes9x/game.libretro.snes9x.txt
@@ -0,0 +1 @@
+game.libretro.snes9x https://github.com/kodi-game/game.libretro.snes9x master
diff --git a/project/cmake/addons/addons/game.libretro.snes9x/platforms.txt b/project/cmake/addons/addons/game.libretro.snes9x/platforms.txt
new file mode 100644
index 0000000..0702cb5
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.snes9x/platforms.txt
@@ -0,0 +1 @@
+all
diff --git a/project/cmake/addons/addons/game.libretro.stella/game.libretro.stella.txt b/project/cmake/addons/addons/game.libretro.stella/game.libretro.stella.txt
new file mode 100644
index 0000000..d600070
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.stella/game.libretro.stella.txt
@@ -0,0 +1 @@
+game.libretro.stella https://github.com/kodi-game/game.libretro.stella master
diff --git a/project/cmake/addons/addons/game.libretro.stella/platforms.txt b/project/cmake/addons/addons/game.libretro.stella/platforms.txt
new file mode 100644
index 0000000..0702cb5
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.stella/platforms.txt
@@ -0,0 +1 @@
+all
diff --git a/project/cmake/addons/addons/game.libretro.vba-next/game.libretro.vba-next.txt b/project/cmake/addons/addons/game.libretro.vba-next/game.libretro.vba-next.txt
new file mode 100644
index 0000000..93eb231
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.vba-next/game.libretro.vba-next.txt
@@ -0,0 +1 @@
+game.libretro.vba-next https://github.com/kodi-game/game.libretro.vba-next master
diff --git a/project/cmake/addons/addons/game.libretro.vba-next/platforms.txt b/project/cmake/addons/addons/game.libretro.vba-next/platforms.txt
new file mode 100644
index 0000000..0702cb5
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.vba-next/platforms.txt
@@ -0,0 +1 @@
+all
diff --git a/project/cmake/addons/addons/game.libretro.vbam/game.libretro.vbam.txt b/project/cmake/addons/addons/game.libretro.vbam/game.libretro.vbam.txt
new file mode 100644
index 0000000..fc3b91a
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.vbam/game.libretro.vbam.txt
@@ -0,0 +1 @@
+game.libretro.vbam https://github.com/kodi-game/game.libretro.vbam master
diff --git a/project/cmake/addons/addons/game.libretro.vbam/platforms.txt b/project/cmake/addons/addons/game.libretro.vbam/platforms.txt
new file mode 100644
index 0000000..0702cb5
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.vbam/platforms.txt
@@ -0,0 +1 @@
+all
diff --git a/project/cmake/addons/addons/game.libretro.yabause/game.libretro.yabause.txt b/project/cmake/addons/addons/game.libretro.yabause/game.libretro.yabause.txt
new file mode 100644
index 0000000..2032994
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.yabause/game.libretro.yabause.txt
@@ -0,0 +1 @@
+game.libretro.yabause https://github.com/kodi-game/game.libretro.yabause master
diff --git a/project/cmake/addons/addons/game.libretro.yabause/platforms.txt b/project/cmake/addons/addons/game.libretro.yabause/platforms.txt
new file mode 100644
index 0000000..0702cb5
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro.yabause/platforms.txt
@@ -0,0 +1 @@
+all
diff --git a/project/cmake/addons/addons/game.libretro/game.libretro.txt b/project/cmake/addons/addons/game.libretro/game.libretro.txt
new file mode 100644
index 0000000..27dabc7
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro/game.libretro.txt
@@ -0,0 +1 @@
+game.libretro https://github.com/kodi-game/game.libretro master
diff --git a/project/cmake/addons/addons/game.libretro/platforms.txt b/project/cmake/addons/addons/game.libretro/platforms.txt
new file mode 100644
index 0000000..0702cb5
--- /dev/null
+++ b/project/cmake/addons/addons/game.libretro/platforms.txt
@@ -0,0 +1 @@
+all
diff --git a/project/cmake/addons/addons/game.moonlight/game.moonlight.txt b/project/cmake/addons/addons/game.moonlight/game.moonlight.txt
new file mode 100644
index 0000000..2fb0daf
--- /dev/null
+++ b/project/cmake/addons/addons/game.moonlight/game.moonlight.txt
@@ -0,0 +1 @@
+game.moonlight https://github.com/garbear/game.moonlight master
diff --git a/project/cmake/addons/addons/game.moonlight/platforms.txt b/project/cmake/addons/addons/game.moonlight/platforms.txt
new file mode 100644
index 0000000..0702cb5
--- /dev/null
+++ b/project/cmake/addons/addons/game.moonlight/platforms.txt
@@ -0,0 +1 @@
+all
diff --git a/project/cmake/addons/depends/windows/CMakeLists.txt b/project/cmake/addons/depends/windows/CMakeLists.txt
index 4480f1e..0a158f7 100644
--- a/project/cmake/addons/depends/windows/CMakeLists.txt
+++ b/project/cmake/addons/depends/windows/CMakeLists.txt
@@ -36,11 +36,50 @@ function(add_internal id url inputfile)
                      )
 endfunction()
 
-#find_package(7Zip REQUIRED)
+function(add_7zip id url inputfile)
+  externalproject_add(${id}
+                      PREFIX build/${id}
+                      DOWNLOAD_COMMAND ${CMAKE_COMMAND}
+                                       -D7ZIP_EXECUTABLE=${7ZIP_EXECUTABLE}
+                                       -DURL=${url}
+                                       -DDEST=${PROJECT_BINARY_DIR}/build/${id}/src/${id}
+                                       -DDESTDIR=${PROJECT_BINARY_DIR}/build/${id}/src/${id}
+                                       -P ${PROJECT_SOURCE_DIR}/extract-7z.cmake
+                      CONFIGURE_COMMAND ""
+                      BUILD_COMMAND ""
+                      INSTALL_COMMAND ${CMAKE_COMMAND}
+                                      -DINPUTDIR=${PROJECT_BINARY_DIR}/build/${id}/src/${id}
+                                      -DINPUTFILE=${inputfile}
+                                      -DDESTDIR=${DEPENDS_PATH}
+                                      -P ${PROJECT_SOURCE_DIR}/install.cmake
+                     )
+endfunction()
+
+function(add_direct id url inputfile)
+  externalproject_add(${id}
+                      PREFIX build/${id}
+                      DOWNLOAD_COMMAND ${CMAKE_COMMAND}
+                                       -DURL=${url}
+                                       -DDEST=${PROJECT_BINARY_DIR}/build/${id}/src/${id}
+                                       -P ${PROJECT_SOURCE_DIR}/extract-direct.cmake
+                      CONFIGURE_COMMAND ""
+                      BUILD_COMMAND ""
+                      INSTALL_COMMAND ${CMAKE_COMMAND}
+                                      -DINPUTDIR=${PROJECT_BINARY_DIR}/build/${id}/src/${id}
+                                      -DINPUTFILE=${inputfile}
+                                      -DDESTDIR=${DEPENDS_PATH}
+                                      -P ${PROJECT_SOURCE_DIR}/install.cmake
+                     )
+endfunction()
+
+find_package(7Zip REQUIRED)
 
 file(GLOB_RECURSE download_input_files prebuilt/*.txt)
 foreach(file ${download_input_files})
-  if(NOT file MATCHES install.txt)
+  if(NOT (file MATCHES install.txt OR
+          file MATCHES deps.txt))
+    message(STATUS "Processing ${file}")
+
     file(STRINGS ${file} def)
     get_filename_component(dir ${file} PATH)
     separate_arguments(def)
@@ -48,8 +87,46 @@ foreach(file ${download_input_files})
 
     list(FIND DEPENDS_TO_BUILD ${id} idx)
     if(idx GREATER -1 OR DEPENDS_TO_BUILD STREQUAL "all")
-      list(GET def 1 url)
-      add_internal(${id} ${url} ${dir}/install.txt)
+      list(LENGTH def deflength)
+
+      set(url "")
+      if(deflength GREATER 1)
+        list(GET def 1 url)
+        message(STATUS "${id} url: ${url}")
+      endif()
+
+      # check if there's a deps.txt containing dependencies on other libraries
+      if(EXISTS ${dir}/deps.txt)
+        file(STRINGS ${dir}/deps.txt deps)
+        message(STATUS "${id} depends: ${deps}")
+      else()
+        set(deps)
+      endif()
+
+      if(NOT "${url}" STREQUAL "" AND EXISTS ${dir}/install.txt)
+        if(url MATCHES .7z OR url MATCHES .lzma)
+          add_7zip(${id} ${url} ${dir}/install.txt)
+        elseif(url MATCHES .exe)
+          add_direct(${id} ${url} ${dir}/install.txt)
+        else()
+          add_internal(${id} ${url} ${dir}/install.txt)
+        endif()
+      elseif(NOT "${deps}" STREQUAL "")
+        externalproject_add(${id}
+                            DOWNLOAD_COMMAND ""
+                            UPDATE_COMMAND ""
+                            PATCH_COMMAND ""
+                            CONFIGURE_COMMAND ""
+                            BUILD_COMMAND ""
+                            INSTALL_COMMAND ""
+                            TEST_COMMAND "")
+      else()
+        message(FATAL_ERROR "Invalid dependency definition for ${id}")
+      endif()
+
+      if(deps)
+        add_dependencies(${id} ${deps})
+      endif()
     endif()
   endif()
 endforeach()
diff --git a/project/cmake/addons/depends/windows/Find7Zip.cmake b/project/cmake/addons/depends/windows/Find7Zip.cmake
index 82b0902..f993b2a 100644
--- a/project/cmake/addons/depends/windows/Find7Zip.cmake
+++ b/project/cmake/addons/depends/windows/Find7Zip.cmake
@@ -1,4 +1,4 @@
-find_program(7ZIP_EXECUTABLE NAMES 7z.exe
+find_program(7ZIP_EXECUTABLE NAMES 7z 7za 7z.exe 7za.exe
              HINTS PATHS "c:/Program Files/7-Zip")
 
 include(FindPackageHandleStandardArgs)
diff --git a/project/cmake/addons/depends/windows/cmake/mingw/CMakeLists.txt b/project/cmake/addons/depends/windows/cmake/mingw/CMakeLists.txt
new file mode 100644
index 0000000..7b544a6
--- /dev/null
+++ b/project/cmake/addons/depends/windows/cmake/mingw/CMakeLists.txt
@@ -0,0 +1,25 @@
+project(mingw)
+
+cmake_minimum_required(VERSION 2.8)
+
+function(generate_mingw32_wrapper cmd)
+  set(CMD ${cmd})
+  configure_file(${PROJECT_SOURCE_DIR}/mingw32-cmd.bat.in ${MINGW_PATH}/bin/${CMD}.bat @ONLY)
+endfunction()
+
+set(MSYS_PATH "${CMAKE_INSTALL_PREFIX}/msys")
+set(MINGW_PATH "${CMAKE_INSTALL_PREFIX}/mingw")
+
+# configure the MinGW toolchain file
+configure_file(${PROJECT_SOURCE_DIR}/Toolchain_mingw32.cmake.in ${CMAKE_INSTALL_PREFIX}/Toolchain_mingw32.cmake @ONLY)
+
+# configure mingw-config.cmake
+configure_file(${PROJECT_SOURCE_DIR}/mingw-config.cmake.in ${CMAKE_INSTALL_PREFIX}/mingw-config.cmake)
+
+# configure the MinGW wrapper batch scripts
+generate_mingw32_wrapper("mingw32-make")
+generate_mingw32_wrapper("mingw32-gcc")
+generate_mingw32_wrapper("mingw32-g++")
+generate_mingw32_wrapper("ar")
+generate_mingw32_wrapper("ld")
+generate_mingw32_wrapper("windres")
diff --git a/project/cmake/addons/depends/windows/cmake/mingw/Toolchain_mingw32.cmake.in b/project/cmake/addons/depends/windows/cmake/mingw/Toolchain_mingw32.cmake.in
new file mode 100644
index 0000000..3844afe
--- /dev/null
+++ b/project/cmake/addons/depends/windows/cmake/mingw/Toolchain_mingw32.cmake.in
@@ -0,0 +1,17 @@
+set(CMAKE_SYSTEM_VERSION 1)
+set(CMAKE_SYSTEM_NAME Windows)
+
+set(CMAKE_FIND_ROOT_PATH @CMAKE_FIND_ROOT_PATH@ @CMAKE_INSTALL_PREFIX@ @MSYS_PATH@ @MINGW_PATH@)
+
+# specify the cross compiler
+set(CMAKE_C_COMPILER   @MINGW_PATH@/bin/mingw32-gcc.bat)
+set(CMAKE_CXX_COMPILER @MINGW_PATH@/bin/mingw32-g++.bat)
+set(CMAKE_AR           @MINGW_PATH@/bin/ar.bat CACHE FILEPATH "Archiver")
+set(CMAKE_LINKER       @MINGW_PATH@/bin/ld.bat CACHE FILEPATH "Linker")
+SET(CMAKE_RC_COMPILER  @MINGW_PATH@/bin/windres.bat)
+
+# search for programs in the build host directories
+set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
+# for libraries and headers in the target directories
+set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
+set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
diff --git a/project/cmake/addons/depends/windows/cmake/mingw/deps.txt b/project/cmake/addons/depends/windows/cmake/mingw/deps.txt
new file mode 100644
index 0000000..04849da
--- /dev/null
+++ b/project/cmake/addons/depends/windows/cmake/mingw/deps.txt
@@ -0,0 +1,29 @@
+msys
+automake
+binutils
+dlfcn
+expat_mingw
+gcc-c++
+gcc-core
+gettext
+gmp
+gnutls
+iconv_mingw
+iconv-dev_mingw
+libintl
+libstdc++
+libtool
+mads
+make
+mingw-rt
+mingw-rt-dev
+mpc
+mpfr
+pkgconfig-lite
+plibc
+pthreadgc
+pthreads
+w32api-dev
+xasm
+yasm
+zlib_mingw
\ No newline at end of file
diff --git a/project/cmake/addons/depends/windows/cmake/mingw/mingw-config.cmake.in b/project/cmake/addons/depends/windows/cmake/mingw/mingw-config.cmake.in
new file mode 100644
index 0000000..6b83844
--- /dev/null
+++ b/project/cmake/addons/depends/windows/cmake/mingw/mingw-config.cmake.in
@@ -0,0 +1,3 @@
+set(MINGW_INCLUDE_DIRS @MINGW_PATH@/include)
+set(MINGW_MAKE @MINGW_PATH@/bin/mingw32-make.bat)
+set(MINGW_FOUND 1)
\ No newline at end of file
diff --git a/project/cmake/addons/depends/windows/cmake/mingw/mingw.txt b/project/cmake/addons/depends/windows/cmake/mingw/mingw.txt
new file mode 100644
index 0000000..24508bb
--- /dev/null
+++ b/project/cmake/addons/depends/windows/cmake/mingw/mingw.txt
@@ -0,0 +1 @@
+mingw
\ No newline at end of file
diff --git a/project/cmake/addons/depends/windows/cmake/mingw/mingw32-cmd.bat.in b/project/cmake/addons/depends/windows/cmake/mingw/mingw32-cmd.bat.in
new file mode 100644
index 0000000..33829ca
--- /dev/null
+++ b/project/cmake/addons/depends/windows/cmake/mingw/mingw32-cmd.bat.in
@@ -0,0 +1,5 @@
+@ECHO OFF
+SETLOCAL
+
+SET PATH=%PATH%;@MINGW_PATH@/bin
+@CMD@.exe %*
\ No newline at end of file
diff --git a/project/cmake/addons/depends/windows/cmake/mingw/noinstall.txt b/project/cmake/addons/depends/windows/cmake/mingw/noinstall.txt
new file mode 100644
index 0000000..e69de29
diff --git a/project/cmake/addons/depends/windows/cmake/msys/CMakeLists.txt b/project/cmake/addons/depends/windows/cmake/msys/CMakeLists.txt
new file mode 100644
index 0000000..a2e9e05
--- /dev/null
+++ b/project/cmake/addons/depends/windows/cmake/msys/CMakeLists.txt
@@ -0,0 +1,9 @@
+project(msys)
+
+cmake_minimum_required(VERSION 2.8)
+
+set(MINGW_PATH "${CMAKE_INSTALL_PREFIX}/mingw")
+set(MSYS_ETC_FSTAB "${MSYS_PATH}/etc/fstab")
+
+# create /etc/fstab
+file(WRITE "${MSYS_ETC_FSTAB}" "${MINGW_PATH} /mingw\n")
diff --git a/project/cmake/addons/depends/windows/cmake/msys/deps.txt b/project/cmake/addons/depends/windows/cmake/msys/deps.txt
new file mode 100644
index 0000000..484b8aa
--- /dev/null
+++ b/project/cmake/addons/depends/windows/cmake/msys/deps.txt
@@ -0,0 +1,29 @@
+autoconf
+automake_msys
+bash
+coreutils
+coreutils597
+crypt
+diffutils
+findutils
+gawk
+gettext_msys
+grep
+gzip
+iconv_msys
+libintl_msys
+libtool_msys
+m4
+make_msys
+mktemp
+msyscore
+msyscore-ext
+patch
+perl
+regex
+rxvt
+sed
+tar
+termcap
+texinfo
+xz
\ No newline at end of file
diff --git a/project/cmake/addons/depends/windows/cmake/msys/msys.txt b/project/cmake/addons/depends/windows/cmake/msys/msys.txt
new file mode 100644
index 0000000..f434c83
--- /dev/null
+++ b/project/cmake/addons/depends/windows/cmake/msys/msys.txt
@@ -0,0 +1 @@
+msys
\ No newline at end of file
diff --git a/project/cmake/addons/depends/windows/cmake/msys/noinstall.txt b/project/cmake/addons/depends/windows/cmake/msys/noinstall.txt
new file mode 100644
index 0000000..e69de29
diff --git a/project/cmake/addons/depends/windows/install.cmake b/project/cmake/addons/depends/windows/install.cmake
index 9a3adbb..f295008 100644
--- a/project/cmake/addons/depends/windows/install.cmake
+++ b/project/cmake/addons/depends/windows/install.cmake
@@ -2,19 +2,23 @@ if(EXISTS "${INPUTFILE}")
   # if there's an input file we use it to determine which files to copy where
   file(STRINGS ${INPUTFILE} FILES)
   string(REPLACE "\n" ";" FILES "${FILES}")
+
   foreach(file ${FILES})
     string(REPLACE " " ";" file "${file}")
     list(GET file 0 dir)
     list(GET file 1 dest)
+
     list(LENGTH file deflength)
     if(deflength GREATER 2)
-      list(GET file 2 copy)
+      list(GET file 2 move)
     endif()
+
     file(GLOB files ${INPUTDIR}/${dir})
     foreach(instfile ${files})
       file(COPY ${instfile} DESTINATION ${DESTDIR}/${dest})
-      if(copy)
-        file(COPY ${instfile} DESTINATION ${DESTDIR}/${copy})
+
+      if(move)
+        file(RENAME ${instfile} ${DESTDIR}/${move})
       endif()
     endforeach()
   endforeach()
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/automake/automake.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/automake/automake.txt
new file mode 100644
index 0000000..d3acfb2
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/automake/automake.txt
@@ -0,0 +1 @@
+automake http://mirrors.xbmc.org/build-deps/win32/mingw-msys/automake1.11-1.11.1-1-mingw32-bin.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/automake/install.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/automake/install.txt
new file mode 100644
index 0000000..ebce641
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/automake/install.txt
@@ -0,0 +1,2 @@
+bin/* mingw/bin
+share/* mingw/share
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/binutils/binutils.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/binutils/binutils.txt
new file mode 100644
index 0000000..03ca886
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/binutils/binutils.txt
@@ -0,0 +1 @@
+binutils http://mirrors.xbmc.org/build-deps/win32/mingw-msys/binutils-2.22-1-mingw32-bin.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/binutils/install.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/binutils/install.txt
new file mode 100644
index 0000000..ee9ca52
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/binutils/install.txt
@@ -0,0 +1,4 @@
+bin/* mingw/bin
+mingw32/* mingw/mingw32
+include/* mingw/include
+lib/* mingw/lib
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/dlfcn/dlfcn.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/dlfcn/dlfcn.txt
new file mode 100644
index 0000000..0c1b08e
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/dlfcn/dlfcn.txt
@@ -0,0 +1 @@
+dlfcn http://mirrors.xbmc.org/build-deps/win32/mingw-msys/dlfcn-win32-static-r19.tar.bz2
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/dlfcn/install.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/dlfcn/install.txt
new file mode 100644
index 0000000..e3513e8
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/dlfcn/install.txt
@@ -0,0 +1,2 @@
+include/* mingw/include
+lib/* mingw/lib
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/expat_mingw/expat_mingw.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/expat_mingw/expat_mingw.txt
new file mode 100644
index 0000000..d668483
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/expat_mingw/expat_mingw.txt
@@ -0,0 +1 @@
+expat_mingw http://mirrors.xbmc.org/build-deps/win32/mingw-msys/libexpat-2.0.1-1-mingw32-dev.tar.gz
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/expat_mingw/install.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/expat_mingw/install.txt
new file mode 100644
index 0000000..e3513e8
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/expat_mingw/install.txt
@@ -0,0 +1,2 @@
+include/* mingw/include
+lib/* mingw/lib
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/gcc-c++/gcc-c++.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/gcc-c++/gcc-c++.txt
new file mode 100644
index 0000000..e64cece
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/gcc-c++/gcc-c++.txt
@@ -0,0 +1 @@
+gcc-c++ http://mirrors.xbmc.org/build-deps/win32/mingw-msys/gcc-c++-4.6.2-1-mingw32-bin.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/gcc-c++/install.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/gcc-c++/install.txt
new file mode 100644
index 0000000..09e3359
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/gcc-c++/install.txt
@@ -0,0 +1,4 @@
+lib/gcc/mingw32/4.6.2/* mingw/lib/gcc/mingw32/4.6.2
+libexec/gcc/mingw32/4.6.2/* mingw/libexec/gcc/mingw32/4.6.2
+share/gcc-4.6.2./python/* mingw/share/gcc-4.6.2/python
+bin/* mingw/bin
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/gcc-core/gcc-core.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/gcc-core/gcc-core.txt
new file mode 100644
index 0000000..507072f
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/gcc-core/gcc-core.txt
@@ -0,0 +1 @@
+gcc-core http://mirrors.xbmc.org/build-deps/win32/mingw-msys/gcc-core-4.6.2-1-mingw32-bin.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/gcc-core/install.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/gcc-core/install.txt
new file mode 100644
index 0000000..89bce80
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/gcc-core/install.txt
@@ -0,0 +1,3 @@
+lib/gcc/mingw32/4.6.2/* mingw/lib/gcc/mingw32/4.6.2
+libexec/gcc/mingw32/4.6.2/* mingw/libexec/gcc/mingw32/4.6.2
+bin/* mingw/bin
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/gettext/gettext.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/gettext/gettext.txt
new file mode 100644
index 0000000..419edb4
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/gettext/gettext.txt
@@ -0,0 +1 @@
+gettext http://mirrors.xbmc.org/build-deps/win32/mingw-msys/gettext-0.17-1-mingw32-dev.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/gettext/install.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/gettext/install.txt
new file mode 100644
index 0000000..c1893b7
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/gettext/install.txt
@@ -0,0 +1,4 @@
+bin/* mingw/bin
+include/* mingw/include
+lib/* mingw/lib
+share/* mingw/share
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/gmp/gmp.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/gmp/gmp.txt
new file mode 100644
index 0000000..aa9ee99
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/gmp/gmp.txt
@@ -0,0 +1 @@
+gmp http://mirrors.xbmc.org/build-deps/win32/mingw-msys/libgmp-5.0.1-1-mingw32-dll-10.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/gmp/install.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/gmp/install.txt
new file mode 100644
index 0000000..305fee3
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/gmp/install.txt
@@ -0,0 +1 @@
+bin/* mingw/bin
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/gnutls/gnutls.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/gnutls/gnutls.txt
new file mode 100644
index 0000000..6441adc
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/gnutls/gnutls.txt
@@ -0,0 +1 @@
+gnutls http://mirrors.xbmc.org/build-deps/win32/mingw-msys/gnutls-dev_2.4.2-1_win32.zip
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/gnutls/install.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/gnutls/install.txt
new file mode 100644
index 0000000..e0f0928
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/gnutls/install.txt
@@ -0,0 +1,4 @@
+bin/* mingw/bin
+lib/* mingw/lib
+share/* mingw/share
+include/* mingw/include
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/iconv-dev_mingw/iconv-dev_mingw.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/iconv-dev_mingw/iconv-dev_mingw.txt
new file mode 100644
index 0000000..885324c
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/iconv-dev_mingw/iconv-dev_mingw.txt
@@ -0,0 +1 @@
+iconv-dev_mingw http://mirrors.xbmc.org/build-deps/win32/mingw-msys/libiconv-1.13.1-1-mingw32-dev.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/iconv-dev_mingw/install.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/iconv-dev_mingw/install.txt
new file mode 100644
index 0000000..e3513e8
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/iconv-dev_mingw/install.txt
@@ -0,0 +1,2 @@
+include/* mingw/include
+lib/* mingw/lib
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/iconv_mingw/icon_mingw.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/iconv_mingw/icon_mingw.txt
new file mode 100644
index 0000000..021f407
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/iconv_mingw/icon_mingw.txt
@@ -0,0 +1 @@
+iconv_mingw http://mirrors.xbmc.org/build-deps/win32/mingw-msys/libiconv-1.13.1-1-mingw32-dll-2.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/iconv_mingw/install.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/iconv_mingw/install.txt
new file mode 100644
index 0000000..305fee3
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/iconv_mingw/install.txt
@@ -0,0 +1 @@
+bin/* mingw/bin
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/libintl/install.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/libintl/install.txt
new file mode 100644
index 0000000..305fee3
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/libintl/install.txt
@@ -0,0 +1 @@
+bin/* mingw/bin
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/libintl/libintl.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/libintl/libintl.txt
new file mode 100644
index 0000000..ba5fdcc
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/libintl/libintl.txt
@@ -0,0 +1 @@
+libintl http://mirrors.xbmc.org/build-deps/win32/mingw-msys/libintl-0.17-1-mingw32-dll-8.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/libstdc++/install.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/libstdc++/install.txt
new file mode 100644
index 0000000..305fee3
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/libstdc++/install.txt
@@ -0,0 +1 @@
+bin/* mingw/bin
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/libstdc++/libstdc++.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/libstdc++/libstdc++.txt
new file mode 100644
index 0000000..895d37c
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/libstdc++/libstdc++.txt
@@ -0,0 +1 @@
+libstdc++ http://mirrors.xbmc.org/build-deps/win32/mingw-msys/libstdc++-4.6.2-1-mingw32-dll-6.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/libtool/install.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/libtool/install.txt
new file mode 100644
index 0000000..ebce641
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/libtool/install.txt
@@ -0,0 +1,2 @@
+bin/* mingw/bin
+share/* mingw/share
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/libtool/libtool.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/libtool/libtool.txt
new file mode 100644
index 0000000..c203d9e
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/libtool/libtool.txt
@@ -0,0 +1 @@
+libtool http://mirrors.xbmc.org/build-deps/win32/mingw-msys/libtool-2.4-1-mingw32-bin.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/mads/install.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/mads/install.txt
new file mode 100644
index 0000000..0775c88
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/mads/install.txt
@@ -0,0 +1 @@
+mads.exe mingw/bin
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/mads/mads.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/mads/mads.txt
new file mode 100644
index 0000000..5e197e5
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/mads/mads.txt
@@ -0,0 +1 @@
+mads http://mirrors.xbmc.org/build-deps/win32/mingw-msys/mads_1.9.3.7z
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/make/install.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/make/install.txt
new file mode 100644
index 0000000..305fee3
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/make/install.txt
@@ -0,0 +1 @@
+bin/* mingw/bin
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/make/make.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/make/make.txt
new file mode 100644
index 0000000..741330c
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/make/make.txt
@@ -0,0 +1 @@
+make http://mirrors.xbmc.org/build-deps/win32/mingw-msys/make-3.82-5-mingw32-bin.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/mingw-rt-dev/install.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/mingw-rt-dev/install.txt
new file mode 100644
index 0000000..e3513e8
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/mingw-rt-dev/install.txt
@@ -0,0 +1,2 @@
+include/* mingw/include
+lib/* mingw/lib
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/mingw-rt-dev/mingw-rt-dev.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/mingw-rt-dev/mingw-rt-dev.txt
new file mode 100644
index 0000000..bb88c36
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/mingw-rt-dev/mingw-rt-dev.txt
@@ -0,0 +1 @@
+mingw-rt-dev http://mirrors.xbmc.org/build-deps/win32/mingw-msys/mingwrt-3.20-mingw32-dev.tar.gz
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/mingw-rt/install.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/mingw-rt/install.txt
new file mode 100644
index 0000000..305fee3
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/mingw-rt/install.txt
@@ -0,0 +1 @@
+bin/* mingw/bin
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/mingw-rt/mingw-rt.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/mingw-rt/mingw-rt.txt
new file mode 100644
index 0000000..397d18e
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/mingw-rt/mingw-rt.txt
@@ -0,0 +1 @@
+mingw-rt http://mirrors.xbmc.org/build-deps/win32/mingw-msys/mingwrt-3.20-mingw32-dll.tar.gz
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/mpc/install.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/mpc/install.txt
new file mode 100644
index 0000000..305fee3
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/mpc/install.txt
@@ -0,0 +1 @@
+bin/* mingw/bin
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/mpc/mpc.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/mpc/mpc.txt
new file mode 100644
index 0000000..80c08c9
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/mpc/mpc.txt
@@ -0,0 +1 @@
+mpc http://mirrors.xbmc.org/build-deps/win32/mingw-msys/libmpc-0.8.1-1-mingw32-dll-2.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/mpfr/install.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/mpfr/install.txt
new file mode 100644
index 0000000..305fee3
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/mpfr/install.txt
@@ -0,0 +1 @@
+bin/* mingw/bin
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/mpfr/mpfr.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/mpfr/mpfr.txt
new file mode 100644
index 0000000..3ef2053
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/mpfr/mpfr.txt
@@ -0,0 +1 @@
+mpfr http://mirrors.xbmc.org/build-deps/win32/mingw-msys/libmpfr-2.4.1-1-mingw32-dll-1.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/pkgconfig-lite/install.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/pkgconfig-lite/install.txt
new file mode 100644
index 0000000..ebce641
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/pkgconfig-lite/install.txt
@@ -0,0 +1,2 @@
+bin/* mingw/bin
+share/* mingw/share
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/pkgconfig-lite/pkgconfig-lite.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/pkgconfig-lite/pkgconfig-lite.txt
new file mode 100644
index 0000000..ac2cd82
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/pkgconfig-lite/pkgconfig-lite.txt
@@ -0,0 +1 @@
+pkgconfig-lite http://mirrors.xbmc.org/build-deps/win32/mingw-msys/pkg-config-lite-0.28-1_bin-win32.zip
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/plibc/install.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/plibc/install.txt
new file mode 100644
index 0000000..c550388
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/plibc/install.txt
@@ -0,0 +1,3 @@
+include/* mingw/include
+lib/* mingw/lib
+bin/* mingw/bin
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/plibc/plibc.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/plibc/plibc.txt
new file mode 100644
index 0000000..ee57ca1
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/plibc/plibc.txt
@@ -0,0 +1 @@
+plibc http://mirrors.xbmc.org/build-deps/win32/mingw-msys/plibc-0.1.6.zip
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/pthreadgc/install.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/pthreadgc/install.txt
new file mode 100644
index 0000000..305fee3
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/pthreadgc/install.txt
@@ -0,0 +1 @@
+bin/* mingw/bin
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/pthreadgc/pthreadgc.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/pthreadgc/pthreadgc.txt
new file mode 100644
index 0000000..7ccc6e2
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/pthreadgc/pthreadgc.txt
@@ -0,0 +1 @@
+pthreadgc http://mirrors.xbmc.org/build-deps/win32/mingw-msys/libpthreadgc-2.9.0-mingw32-pre-20110507-2-dll-2.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/pthreads/install.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/pthreads/install.txt
new file mode 100644
index 0000000..c550388
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/pthreads/install.txt
@@ -0,0 +1,3 @@
+include/* mingw/include
+lib/* mingw/lib
+bin/* mingw/bin
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/pthreads/pthreads.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/pthreads/pthreads.txt
new file mode 100644
index 0000000..c1deac0
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/pthreads/pthreads.txt
@@ -0,0 +1 @@
+pthreads http://mirrors.xbmc.org/build-deps/win32/mingw-msys/pthreads-w32-2.9.0-mingw32-pre-20110507-2-dev.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/w32api-dev/install.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/w32api-dev/install.txt
new file mode 100644
index 0000000..e3513e8
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/w32api-dev/install.txt
@@ -0,0 +1,2 @@
+include/* mingw/include
+lib/* mingw/lib
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/w32api-dev/w32api-dev.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/w32api-dev/w32api-dev.txt
new file mode 100644
index 0000000..729e3f8
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/w32api-dev/w32api-dev.txt
@@ -0,0 +1 @@
+w32api-dev http://mirrors.xbmc.org/build-deps/win32/mingw-msys/w32api-3.17-2-mingw32-dev.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/xasm/install.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/xasm/install.txt
new file mode 100644
index 0000000..3bf3bf9
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/xasm/install.txt
@@ -0,0 +1 @@
+xasm.exe mingw/bin
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/xasm/xasm.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/xasm/xasm.txt
new file mode 100644
index 0000000..d3feafd
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/xasm/xasm.txt
@@ -0,0 +1 @@
+xasm http://mirrors.xbmc.org/build-deps/win32/mingw-msys/xasm-3.0.2-windows.zip
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/yasm/install.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/yasm/install.txt
new file mode 100644
index 0000000..aa97fa1
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/yasm/install.txt
@@ -0,0 +1 @@
+yasm-1.2.0-win32.exe mingw/bin mingw/bin/yasm.exe
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/yasm/yasm.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/yasm/yasm.txt
new file mode 100644
index 0000000..3be48cd
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/yasm/yasm.txt
@@ -0,0 +1 @@
+yasm http://mirrors.xbmc.org/build-deps/win32/mingw-msys/yasm-1.2.0-win32.exe
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/zlib_mingw/install.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/zlib_mingw/install.txt
new file mode 100644
index 0000000..e3513e8
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/zlib_mingw/install.txt
@@ -0,0 +1,2 @@
+include/* mingw/include
+lib/* mingw/lib
diff --git a/project/cmake/addons/depends/windows/prebuilt/mingw/zlib_mingw/zlib_mingw.txt b/project/cmake/addons/depends/windows/prebuilt/mingw/zlib_mingw/zlib_mingw.txt
new file mode 100644
index 0000000..7520913
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/mingw/zlib_mingw/zlib_mingw.txt
@@ -0,0 +1 @@
+zlib_mingw http://mirrors.xbmc.org/build-deps/win32/mingw-msys/libz-1.2.5-1-mingw32-dev.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/autoconf/autoconf.txt b/project/cmake/addons/depends/windows/prebuilt/msys/autoconf/autoconf.txt
new file mode 100644
index 0000000..f0f6a74
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/autoconf/autoconf.txt
@@ -0,0 +1 @@
+autoconf http://mirrors.xbmc.org/build-deps/win32/mingw-msys/autoconf-2.68-1-msys-1.0.17-bin.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/autoconf/install.txt b/project/cmake/addons/depends/windows/prebuilt/msys/autoconf/install.txt
new file mode 100644
index 0000000..19d4eb9
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/autoconf/install.txt
@@ -0,0 +1,2 @@
+bin/* msys/bin
+share/* msys/share
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/automake_msys/automake_msys.txt b/project/cmake/addons/depends/windows/prebuilt/msys/automake_msys/automake_msys.txt
new file mode 100644
index 0000000..7bf11d2
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/automake_msys/automake_msys.txt
@@ -0,0 +1 @@
+automake_msys http://mirrors.xbmc.org/build-deps/win32/mingw-msys/automake-1.11.1-1-msys-1.0.13-bin.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/automake_msys/install.txt b/project/cmake/addons/depends/windows/prebuilt/msys/automake_msys/install.txt
new file mode 100644
index 0000000..19d4eb9
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/automake_msys/install.txt
@@ -0,0 +1,2 @@
+bin/* msys/bin
+share/* msys/share
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/bash/bash.txt b/project/cmake/addons/depends/windows/prebuilt/msys/bash/bash.txt
new file mode 100644
index 0000000..383d1d2
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/bash/bash.txt
@@ -0,0 +1 @@
+bash http://mirrors.xbmc.org/build-deps/win32/mingw-msys/bash-3.1.17-4-msys-1.0.16-bin.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/bash/install.txt b/project/cmake/addons/depends/windows/prebuilt/msys/bash/install.txt
new file mode 100644
index 0000000..304b234
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/bash/install.txt
@@ -0,0 +1 @@
+bin/* msys/bin
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/coreutils/coreutils.txt b/project/cmake/addons/depends/windows/prebuilt/msys/coreutils/coreutils.txt
new file mode 100644
index 0000000..a251538
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/coreutils/coreutils.txt
@@ -0,0 +1 @@
+coreutils http://mirrors.xbmc.org/build-deps/win32/mingw-msys/coreutils-5.97-3-msys-1.0.13-bin.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/coreutils/install.txt b/project/cmake/addons/depends/windows/prebuilt/msys/coreutils/install.txt
new file mode 100644
index 0000000..304b234
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/coreutils/install.txt
@@ -0,0 +1 @@
+bin/* msys/bin
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/coreutils597/coreutils597.txt b/project/cmake/addons/depends/windows/prebuilt/msys/coreutils597/coreutils597.txt
new file mode 100644
index 0000000..58c1b35
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/coreutils597/coreutils597.txt
@@ -0,0 +1 @@
+coreutils597 http://mirrors.xbmc.org/build-deps/win32/mingw-msys/coreutils-5.97-MSYS-1.0.11-snapshot.tar.bz2
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/coreutils597/install.txt b/project/cmake/addons/depends/windows/prebuilt/msys/coreutils597/install.txt
new file mode 100644
index 0000000..89ab457
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/coreutils597/install.txt
@@ -0,0 +1 @@
+bin/pr.exe msys/bin
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/crypt/crypt.txt b/project/cmake/addons/depends/windows/prebuilt/msys/crypt/crypt.txt
new file mode 100644
index 0000000..b208da9
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/crypt/crypt.txt
@@ -0,0 +1 @@
+crypt http://mirrors.xbmc.org/build-deps/win32/mingw-msys/libcrypt-1.1_1-3-msys-1.0.13-dll-0.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/crypt/install.txt b/project/cmake/addons/depends/windows/prebuilt/msys/crypt/install.txt
new file mode 100644
index 0000000..304b234
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/crypt/install.txt
@@ -0,0 +1 @@
+bin/* msys/bin
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/diffutils/diffutils.txt b/project/cmake/addons/depends/windows/prebuilt/msys/diffutils/diffutils.txt
new file mode 100644
index 0000000..a8c3ede
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/diffutils/diffutils.txt
@@ -0,0 +1 @@
+diffutils http://mirrors.xbmc.org/build-deps/win32/mingw-msys/diffutils-2.8.7.20071206cvs-3-msys-1.0.13-bin.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/diffutils/install.txt b/project/cmake/addons/depends/windows/prebuilt/msys/diffutils/install.txt
new file mode 100644
index 0000000..304b234
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/diffutils/install.txt
@@ -0,0 +1 @@
+bin/* msys/bin
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/findutils/findutils.txt b/project/cmake/addons/depends/windows/prebuilt/msys/findutils/findutils.txt
new file mode 100644
index 0000000..cbd7cd2
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/findutils/findutils.txt
@@ -0,0 +1 @@
+findutils http://mirrors.xbmc.org/build-deps/win32/mingw-msys/findutils-4.4.2-2-msys-1.0.13-bin.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/findutils/install.txt b/project/cmake/addons/depends/windows/prebuilt/msys/findutils/install.txt
new file mode 100644
index 0000000..d500b8f
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/findutils/install.txt
@@ -0,0 +1,3 @@
+bin/find.exe msys/bin
+bin/oldfind.exe msys/bin
+bin/xargs.exe msys/bin
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/gawk/gawk.txt b/project/cmake/addons/depends/windows/prebuilt/msys/gawk/gawk.txt
new file mode 100644
index 0000000..c7c8fc9
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/gawk/gawk.txt
@@ -0,0 +1 @@
+gawk http://mirrors.xbmc.org/build-deps/win32/mingw-msys/gawk-3.1.7-2-msys-1.0.13-bin.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/gawk/install.txt b/project/cmake/addons/depends/windows/prebuilt/msys/gawk/install.txt
new file mode 100644
index 0000000..cb98828
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/gawk/install.txt
@@ -0,0 +1,3 @@
+bin/* msys/bin
+sbin/* msys/sbin
+share/* msys/share
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/gettext_msys/gettext_msys.txt b/project/cmake/addons/depends/windows/prebuilt/msys/gettext_msys/gettext_msys.txt
new file mode 100644
index 0000000..b2da37f
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/gettext_msys/gettext_msys.txt
@@ -0,0 +1 @@
+gettext_msys http://mirrors.xbmc.org/build-deps/win32/mingw-msys/gettext-0.17-2-msys-1.0.13-bin.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/gettext_msys/install.txt b/project/cmake/addons/depends/windows/prebuilt/msys/gettext_msys/install.txt
new file mode 100644
index 0000000..eb3d6ce
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/gettext_msys/install.txt
@@ -0,0 +1,3 @@
+bin/* msys/bin
+lib/* msys/lib
+share/* msys/share
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/grep/grep.txt b/project/cmake/addons/depends/windows/prebuilt/msys/grep/grep.txt
new file mode 100644
index 0000000..38782da
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/grep/grep.txt
@@ -0,0 +1 @@
+grep http://mirrors.xbmc.org/build-deps/win32/mingw-msys/grep-2.5.4-2-msys-1.0.13-bin.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/grep/install.txt b/project/cmake/addons/depends/windows/prebuilt/msys/grep/install.txt
new file mode 100644
index 0000000..304b234
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/grep/install.txt
@@ -0,0 +1 @@
+bin/* msys/bin
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/gzip/gzip.txt b/project/cmake/addons/depends/windows/prebuilt/msys/gzip/gzip.txt
new file mode 100644
index 0000000..8fc1270
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/gzip/gzip.txt
@@ -0,0 +1 @@
+gzip http://mirrors.xbmc.org/build-deps/win32/mingw-msys/gzip-1.3.12-2-msys-1.0.13-bin.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/gzip/install.txt b/project/cmake/addons/depends/windows/prebuilt/msys/gzip/install.txt
new file mode 100644
index 0000000..304b234
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/gzip/install.txt
@@ -0,0 +1 @@
+bin/* msys/bin
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/iconv_msys/iconv_msys.txt b/project/cmake/addons/depends/windows/prebuilt/msys/iconv_msys/iconv_msys.txt
new file mode 100644
index 0000000..136cef7
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/iconv_msys/iconv_msys.txt
@@ -0,0 +1 @@
+iconv_msys http://mirrors.xbmc.org/build-deps/win32/mingw-msys/libiconv-1.13.1-2-msys-1.0.13-dll-2.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/iconv_msys/install.txt b/project/cmake/addons/depends/windows/prebuilt/msys/iconv_msys/install.txt
new file mode 100644
index 0000000..304b234
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/iconv_msys/install.txt
@@ -0,0 +1 @@
+bin/* msys/bin
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/libintl_msys/install.txt b/project/cmake/addons/depends/windows/prebuilt/msys/libintl_msys/install.txt
new file mode 100644
index 0000000..304b234
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/libintl_msys/install.txt
@@ -0,0 +1 @@
+bin/* msys/bin
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/libintl_msys/libintl_msys.txt b/project/cmake/addons/depends/windows/prebuilt/msys/libintl_msys/libintl_msys.txt
new file mode 100644
index 0000000..116b16b
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/libintl_msys/libintl_msys.txt
@@ -0,0 +1 @@
+libintl_msys http://mirrors.xbmc.org/build-deps/win32/mingw-msys/libintl-0.17-2-msys-dll-8.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/libtool_msys/install.txt b/project/cmake/addons/depends/windows/prebuilt/msys/libtool_msys/install.txt
new file mode 100644
index 0000000..19d4eb9
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/libtool_msys/install.txt
@@ -0,0 +1,2 @@
+bin/* msys/bin
+share/* msys/share
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/libtool_msys/libtool_msys.txt b/project/cmake/addons/depends/windows/prebuilt/msys/libtool_msys/libtool_msys.txt
new file mode 100644
index 0000000..f0f446e
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/libtool_msys/libtool_msys.txt
@@ -0,0 +1 @@
+libtool_msys http://mirrors.xbmc.org/build-deps/win32/mingw-msys/libtool-2.4-1-msys-1.0.15-bin.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/m4/install.txt b/project/cmake/addons/depends/windows/prebuilt/msys/m4/install.txt
new file mode 100644
index 0000000..304b234
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/m4/install.txt
@@ -0,0 +1 @@
+bin/* msys/bin
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/m4/m4.txt b/project/cmake/addons/depends/windows/prebuilt/msys/m4/m4.txt
new file mode 100644
index 0000000..448ef83
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/m4/m4.txt
@@ -0,0 +1 @@
+m4 http://mirrors.xbmc.org/build-deps/win32/mingw-msys/m4-1.4.14-1-msys-1.0.13-bin.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/make_msys/install.txt b/project/cmake/addons/depends/windows/prebuilt/msys/make_msys/install.txt
new file mode 100644
index 0000000..304b234
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/make_msys/install.txt
@@ -0,0 +1 @@
+bin/* msys/bin
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/make_msys/make_msys.txt b/project/cmake/addons/depends/windows/prebuilt/msys/make_msys/make_msys.txt
new file mode 100644
index 0000000..d6909cd
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/make_msys/make_msys.txt
@@ -0,0 +1 @@
+make_msys http://mirrors.xbmc.org/build-deps/win32/mingw-msys/make-3.81-3-msys-1.0.13-bin.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/mktemp/install.txt b/project/cmake/addons/depends/windows/prebuilt/msys/mktemp/install.txt
new file mode 100644
index 0000000..304b234
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/mktemp/install.txt
@@ -0,0 +1 @@
+bin/* msys/bin
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/mktemp/mktemp.txt b/project/cmake/addons/depends/windows/prebuilt/msys/mktemp/mktemp.txt
new file mode 100644
index 0000000..93ff74f
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/mktemp/mktemp.txt
@@ -0,0 +1 @@
+mktemp http://mirrors.xbmc.org/build-deps/win32/mingw-msys/mktemp-1.6-2-msys-1.0.13-bin.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/msyscore-ext/install.txt b/project/cmake/addons/depends/windows/prebuilt/msys/msyscore-ext/install.txt
new file mode 100644
index 0000000..3197e1c
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/msyscore-ext/install.txt
@@ -0,0 +1,2 @@
+*.bat msys
+bin/* msys/bin
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/msyscore-ext/msyscore-ext.txt b/project/cmake/addons/depends/windows/prebuilt/msys/msyscore-ext/msyscore-ext.txt
new file mode 100644
index 0000000..b63ecd9
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/msyscore-ext/msyscore-ext.txt
@@ -0,0 +1 @@
+msyscore-ext http://mirrors.xbmc.org/build-deps/win32/mingw-msys/msysCORE-1.0.17-1-msys-1.0.17-ext.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/msyscore/install.txt b/project/cmake/addons/depends/windows/prebuilt/msys/msyscore/install.txt
new file mode 100644
index 0000000..b25990a
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/msyscore/install.txt
@@ -0,0 +1,3 @@
+*.ico msys
+bin/* msys/bin
+etc/* msys/etc
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/msyscore/msyscore.txt b/project/cmake/addons/depends/windows/prebuilt/msys/msyscore/msyscore.txt
new file mode 100644
index 0000000..080bde2
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/msyscore/msyscore.txt
@@ -0,0 +1 @@
+msyscore http://mirrors.xbmc.org/build-deps/win32/mingw-msys/msysCORE-1.0.17-1-msys-1.0.17-bin.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/patch/install.txt b/project/cmake/addons/depends/windows/prebuilt/msys/patch/install.txt
new file mode 100644
index 0000000..304b234
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/patch/install.txt
@@ -0,0 +1 @@
+bin/* msys/bin
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/patch/patch.txt b/project/cmake/addons/depends/windows/prebuilt/msys/patch/patch.txt
new file mode 100644
index 0000000..17122cf
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/patch/patch.txt
@@ -0,0 +1 @@
+patch http://mirrors.xbmc.org/build-deps/win32/mingw-msys/patch-2.6.1-1-msys-1.0.13-bin.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/perl/install.txt b/project/cmake/addons/depends/windows/prebuilt/msys/perl/install.txt
new file mode 100644
index 0000000..f0cc17e
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/perl/install.txt
@@ -0,0 +1,2 @@
+bin/* msys/bin
+lib/* msys/lib
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/perl/perl.txt b/project/cmake/addons/depends/windows/prebuilt/msys/perl/perl.txt
new file mode 100644
index 0000000..7ac083f
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/perl/perl.txt
@@ -0,0 +1 @@
+perl http://mirrors.xbmc.org/build-deps/win32/mingw-msys/perl-5.6.1_2-2-msys-1.0.13-bin.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/regex/install.txt b/project/cmake/addons/depends/windows/prebuilt/msys/regex/install.txt
new file mode 100644
index 0000000..304b234
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/regex/install.txt
@@ -0,0 +1 @@
+bin/* msys/bin
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/regex/regex.txt b/project/cmake/addons/depends/windows/prebuilt/msys/regex/regex.txt
new file mode 100644
index 0000000..834f68c
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/regex/regex.txt
@@ -0,0 +1 @@
+regex http://mirrors.xbmc.org/build-deps/win32/mingw-msys/libregex-1.20090805-2-msys-1.0.13-dll-1.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/rxvt/install.txt b/project/cmake/addons/depends/windows/prebuilt/msys/rxvt/install.txt
new file mode 100644
index 0000000..304b234
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/rxvt/install.txt
@@ -0,0 +1 @@
+bin/* msys/bin
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/rxvt/rxvt.txt b/project/cmake/addons/depends/windows/prebuilt/msys/rxvt/rxvt.txt
new file mode 100644
index 0000000..2430e81
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/rxvt/rxvt.txt
@@ -0,0 +1 @@
+rxvt http://mirrors.xbmc.org/build-deps/win32/mingw-msys/rxvt-2.7.2-3-msys-1.0.14-bin.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/sed/install.txt b/project/cmake/addons/depends/windows/prebuilt/msys/sed/install.txt
new file mode 100644
index 0000000..304b234
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/sed/install.txt
@@ -0,0 +1 @@
+bin/* msys/bin
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/sed/sed.txt b/project/cmake/addons/depends/windows/prebuilt/msys/sed/sed.txt
new file mode 100644
index 0000000..431f53d
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/sed/sed.txt
@@ -0,0 +1 @@
+sed http://mirrors.xbmc.org/build-deps/win32/mingw-msys/sed-4.2.1-2-msys-1.0.13-bin.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/tar/install.txt b/project/cmake/addons/depends/windows/prebuilt/msys/tar/install.txt
new file mode 100644
index 0000000..304b234
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/tar/install.txt
@@ -0,0 +1 @@
+bin/* msys/bin
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/tar/tar.txt b/project/cmake/addons/depends/windows/prebuilt/msys/tar/tar.txt
new file mode 100644
index 0000000..b9e1698
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/tar/tar.txt
@@ -0,0 +1 @@
+tar http://mirrors.xbmc.org/build-deps/win32/mingw-msys/tar-1.23-1-msys-1.0.13-bin.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/termcap/install.txt b/project/cmake/addons/depends/windows/prebuilt/msys/termcap/install.txt
new file mode 100644
index 0000000..304b234
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/termcap/install.txt
@@ -0,0 +1 @@
+bin/* msys/bin
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/termcap/termcap.txt b/project/cmake/addons/depends/windows/prebuilt/msys/termcap/termcap.txt
new file mode 100644
index 0000000..bdf90e7
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/termcap/termcap.txt
@@ -0,0 +1 @@
+termcap http://mirrors.xbmc.org/build-deps/win32/mingw-msys/libtermcap-0.20050421_1-2-msys-1.0.13-dll-0.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/texinfo/install.txt b/project/cmake/addons/depends/windows/prebuilt/msys/texinfo/install.txt
new file mode 100644
index 0000000..19d4eb9
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/texinfo/install.txt
@@ -0,0 +1,2 @@
+bin/* msys/bin
+share/* msys/share
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/texinfo/texinfo.txt b/project/cmake/addons/depends/windows/prebuilt/msys/texinfo/texinfo.txt
new file mode 100644
index 0000000..158b0b7
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/texinfo/texinfo.txt
@@ -0,0 +1 @@
+texinfo http://mirrors.xbmc.org/build-deps/win32/mingw-msys/texinfo-4.13a-2-msys-1.0.13-bin.tar.lzma
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/xz/install.txt b/project/cmake/addons/depends/windows/prebuilt/msys/xz/install.txt
new file mode 100644
index 0000000..c9a1163
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/xz/install.txt
@@ -0,0 +1 @@
+* msys/bin
diff --git a/project/cmake/addons/depends/windows/prebuilt/msys/xz/xz.txt b/project/cmake/addons/depends/windows/prebuilt/msys/xz/xz.txt
new file mode 100644
index 0000000..170422b
--- /dev/null
+++ b/project/cmake/addons/depends/windows/prebuilt/msys/xz/xz.txt
@@ -0,0 +1 @@
+xz http://mirrors.xbmc.org/build-deps/win32/mingw-msys/xz-4.999.9beta_20100401-1-msys-1.0.13-bin.tar.gz
diff --git a/project/cmake/modules/FindCpluff.cmake b/project/cmake/modules/FindCpluff.cmake
index f4a0dc1..b8fa22d 100644
--- a/project/cmake/modules/FindCpluff.cmake
+++ b/project/cmake/modules/FindCpluff.cmake
@@ -34,9 +34,11 @@ else()
                       CONFIGURE_COMMAND ""
                       # TODO: Building the project directly from lib/cpluff/libcpluff/win32/cpluff.vcxproj
                       #       fails becaue it imports XBMC.defaults.props
-                      BUILD_COMMAND msbuild ${CORE_SOURCE_DIR}/project/VS2010Express/XBMC\ for\ Windows.sln
-                                            /t:cpluff /p:Configuration=${CORE_BUILD_CONFIG}
+                      BUILD_COMMAND devenv /build ${CORE_BUILD_CONFIG}
+                                           ${CORE_SOURCE_DIR}/project/VS2010Express/XBMC\ for\ Windows.sln
+                                           /project cpluff
                       INSTALL_COMMAND "")
+  # TODO: core_link_library
 endif()
 
 set(CPLUFF_INCLUDE_DIRS ${CMAKE_BINARY_DIR}/${CORE_BUILD_DIR}/cpluff/include)
diff --git a/project/cmake/modules/FindCrossGUID.cmake b/project/cmake/modules/FindCrossGUID.cmake
index df40c9e..0d4a915 100644
--- a/project/cmake/modules/FindCrossGUID.cmake
+++ b/project/cmake/modules/FindCrossGUID.cmake
@@ -30,8 +30,10 @@ if(ENABLE_INTERNAL_CROSSGUID)
 else()
   find_path(CROSSGUID_INCLUDE_DIR guid.h)
 
-  find_library(CROSSGUID_LIBRARY_RELEASE NAMES crossguid)
-  find_library(CROSSGUID_LIBRARY_DEBUG NAMES crossguidd)
+  find_library(CROSSGUID_LIBRARY_RELEASE NAMES crossguid
+                                         ${CONFIGURATION_LIBDIR_RELEASE})
+  find_library(CROSSGUID_LIBRARY_DEBUG NAMES crossguidd
+                                       ${CONFIGURATION_LIBDIR_DEBUG})
 
   include(SelectLibraryConfigurations)
   select_library_configurations(CROSSGUID)
diff --git a/project/cmake/modules/FindD3DX11Effects.cmake b/project/cmake/modules/FindD3DX11Effects.cmake
index 9de8c2b..2b2de85 100644
--- a/project/cmake/modules/FindD3DX11Effects.cmake
+++ b/project/cmake/modules/FindD3DX11Effects.cmake
@@ -10,8 +10,8 @@ ExternalProject_Add(d3dx11effects
             SOURCE_DIR ${CORE_SOURCE_DIR}/lib/win32/Effects11
             PREFIX ${CORE_BUILD_DIR}/Effects11
             CONFIGURE_COMMAND ""
-            BUILD_COMMAND msbuild ${CORE_SOURCE_DIR}/lib/win32/Effects11/Effects11_2013.sln
-                                  /t:Effects11 /p:Configuration=${CORE_BUILD_CONFIG}
+            BUILD_COMMAND devenv /build ${CORE_BUILD_CONFIG}
+                          ${CORE_SOURCE_DIR}/lib/win32/Effects11/Effects11_2013.sln
             INSTALL_COMMAND "")
 
 set(D3DX11EFFECTS_FOUND 1)
diff --git a/project/cmake/modules/FindFFMPEG.cmake b/project/cmake/modules/FindFFMPEG.cmake
index 7104231..711845a 100644
--- a/project/cmake/modules/FindFFMPEG.cmake
+++ b/project/cmake/modules/FindFFMPEG.cmake
@@ -54,7 +54,8 @@ then
   swresample=`PKG_CONFIG_PATH=${CMAKE_BINARY_DIR}/${CORE_BUILD_DIR}/lib/pkgconfig ${PKG_CONFIG_EXECUTABLE} --libs --static libswresample`
   gnutls=`PKG_CONFIG_PATH=${DEPENDS_PATH}/lib/pkgconfig/ ${PKG_CONFIG_EXECUTABLE}  --libs-only-l --static --silence-errors gnutls`
   vorbisenc=`PKG_CONFIG_PATH=${DEPENDS_PATH}/lib/pkgconfig/ ${PKG_CONFIG_EXECUTABLE}  --libs-only-l --static --silence-errors vorbisenc`
-  $@ $avcodec $avformat $avcodec $avfilter $swscale $swresample -lpostproc $gnutls $vorbisenc
+  dcadec=`PKG_CONFIG_PATH=${DEPENDS_PATH}/lib/pkgconfig/ ${PKG_CONFIG_EXECUTABLE}  --libs-only-l --static --silence-errors dcadec`
+  $@ $avcodec $avformat $avcodec $avfilter $swscale $swresample -lpostproc $gnutls $vorbisenc $dcadec
 else
   $@
 fi")
diff --git a/project/cmake/modules/FindMySqlClient.cmake b/project/cmake/modules/FindMySqlClient.cmake
index 2295c81..12fee5c 100644
--- a/project/cmake/modules/FindMySqlClient.cmake
+++ b/project/cmake/modules/FindMySqlClient.cmake
@@ -15,10 +15,10 @@
 #   MySqlClient::MySqlClient   - The MySqlClient library
 
 find_path(MYSQLCLIENT_INCLUDE_DIR mysql/mysql_time.h)
-find_library(MYSQLCLIENT_LIBRARY_RELEASE NAMES mysqlclient libmysql
-                                         PATH_SUFFIXES mysql)
-find_library(MYSQLCLIENT_LIBRARY_DEBUG NAMES mysqlclient libmysql
-                                       PATH_SUFFIXES mysql)
+find_library(MYSQLCLIENT_LIBRARY_RELEASE NAMES mysqlclient mysqlclient_r
+                                         PATH_SUFFIXES ${CONFIGURATION_LIBDIR_RELEASE} mysql)
+find_library(MYSQLCLIENT_LIBRARY_DEBUG NAMES mysqlclient
+                                       PATH_SUFFIXES ${CONFIGURATION_LIBDIR_DEBUG} mysql)
 
 include(SelectLibraryConfigurations)
 select_library_configurations(MYSQLCLIENT)
diff --git a/project/cmake/modules/FindPCRE.cmake b/project/cmake/modules/FindPCRE.cmake
index 8babed3..54c4ab4 100644
--- a/project/cmake/modules/FindPCRE.cmake
+++ b/project/cmake/modules/FindPCRE.cmake
@@ -22,12 +22,16 @@ endif()
 find_path(PCRE_INCLUDE_DIR pcrecpp.h
                            PATHS ${PC_PCRE_INCLUDEDIR})
 find_library(PCRECPP_LIBRARY_RELEASE NAMES pcrecpp
+                                     PATH_SUFFIXES ${CONFIGURATION_LIBDIR_RELEASE}
                                      PATHS ${PC_PCRE_LIBDIR})
 find_library(PCRE_LIBRARY_RELEASE NAMES pcre
+                                  PATH_SUFFIXES ${CONFIGURATION_LIBDIR_RELEASE}
                                   PATHS ${PC_PCRE_LIBDIR})
 find_library(PCRECPP_LIBRARY_DEBUG NAMES pcrecppd
+                                   PATH_SUFFIXES ${CONFIGURATION_LIBDIR_DEBUG}
                                    PATHS ${PC_PCRE_LIBDIR})
 find_library(PCRE_LIBRARY_DEBUG NAMES pcred
+                                   PATH_SUFFIXES ${CONFIGURATION_LIBDIR_DEBUG}
                                    PATHS ${PC_PCRE_LIBDIR})
 set(PCRE_VERSION ${PC_PCRE_VERSION})
 
diff --git a/project/cmake/modules/FindTagLib.cmake b/project/cmake/modules/FindTagLib.cmake
index 06b615d..b515e81 100644
--- a/project/cmake/modules/FindTagLib.cmake
+++ b/project/cmake/modules/FindTagLib.cmake
@@ -20,8 +20,10 @@ endif()
 find_path(TAGLIB_INCLUDE_DIR taglib/tag.h
                              PATHS ${PC_TAGLIB_INCLUDEDIR})
 find_library(TAGLIB_LIBRARY_RELEASE NAMES tag
+                                    PATH_SUFFIXES ${CONFIGURATION_LIBDIR_RELEASE}
                                     PATHS ${PC_TAGLIB_LIBDIR})
-find_library(TAGLIB_LIBRARY_DEBUG NAMES tagd
+find_library(TAGLIB_LIBRARY_DEBUG NAMES tag
+                                  PATH_SUFFIXES ${CONFIGURATION_LIBDIR_DEBUG}
                                   PATHS ${PC_TAGLIB_LIBDIR})
 set(TAGLIB_VERSION ${PC_TAGLIB_VERSION})
 
diff --git a/project/cmake/modules/FindTinyXML.cmake b/project/cmake/modules/FindTinyXML.cmake
index 54ec946..0168f40 100644
--- a/project/cmake/modules/FindTinyXML.cmake
+++ b/project/cmake/modules/FindTinyXML.cmake
@@ -22,10 +22,10 @@ find_path(TINYXML_INCLUDE_DIR tinyxml.h
                               PATH_SUFFIXES tinyxml
                               PATHS ${PC_TINYXML_INCLUDEDIR})
 find_library(TINYXML_LIBRARY_RELEASE NAMES tinyxml tinyxmlSTL
-                                     PATH_SUFFIXES tinyxml
+                                     PATH_SUFFIXES tinyxml ${CONFIGURATION_LIBDIR_RELEASE}
                                      PATHS ${PC_TINYXML_LIBDIR})
-find_library(TINYXML_LIBRARY_DEBUG NAMES tinyxmld tinyxmlSTLd
-                                   PATH_SUFFIXES tinyxml
+find_library(TINYXML_LIBRARY_DEBUG NAMES tinyxml tinyxmlSTL
+                                   PATH_SUFFIXES tinyxml ${CONFIGURATION_LIBDIR_DEBUG}
                                    PATHS ${PC_TINYXML_LIBDIR})
 set(TINYXML_VERSION ${PC_TINYXML_VERSION})
 
diff --git a/project/cmake/scripts/common/addon-helpers.cmake b/project/cmake/scripts/common/addon-helpers.cmake
index 9541df4..7d98021 100644
--- a/project/cmake/scripts/common/addon-helpers.cmake
+++ b/project/cmake/scripts/common/addon-helpers.cmake
@@ -34,15 +34,19 @@ endmacro()
 
 # Build, link and optionally package an add-on
 macro (build_addon target prefix libs)
-  ADD_LIBRARY(${target} ${${prefix}_SOURCES})
-  TARGET_LINK_LIBRARIES(${target} ${${libs}})
   addon_version(${target} ${prefix})
-  SET_TARGET_PROPERTIES(${target} PROPERTIES VERSION ${${prefix}_VERSION}
-                                             SOVERSION ${APP_VERSION_MAJOR}.${APP_VERSION_MINOR}
-                                             PREFIX "")
-  IF(OS STREQUAL "android")
-    SET_TARGET_PROPERTIES(${target} PROPERTIES PREFIX "lib")
-  ENDIF(OS STREQUAL "android")
+  if(${prefix}_SOURCES)
+    ADD_LIBRARY(${target} ${${prefix}_SOURCES})
+    TARGET_LINK_LIBRARIES(${target} ${${libs}})
+    SET_TARGET_PROPERTIES(${target} PROPERTIES VERSION ${${prefix}_VERSION}
+                                               SOVERSION ${APP_VERSION_MAJOR}.${APP_VERSION_MINOR}
+                                               PREFIX "")
+    IF(OS STREQUAL "android")
+      SET_TARGET_PROPERTIES(${target} PROPERTIES PREFIX "lib")
+    ENDIF(OS STREQUAL "android")
+  else()
+    add_custom_target(${target})
+  endif()
 
   # get the library's location
   SET(LIBRARY_LOCATION $<TARGET_FILE:${target}>)
@@ -100,22 +104,40 @@ macro (build_addon target prefix libs)
       # is changed within Visual Studio)
       string(REPLACE "$(Configuration)" "${CMAKE_BUILD_TYPE}" LIBRARY_LOCATION "${LIBRARY_LOCATION}")
 
-      # install the generated DLL file
-      INSTALL(PROGRAMS ${LIBRARY_LOCATION} DESTINATION ${target}
-              COMPONENT ${target}-${${prefix}_VERSION})
-
-      IF(CMAKE_BUILD_TYPE MATCHES Debug)
-        # for debug builds also install the PDB file
-        get_filename_component(LIBRARY_DIR ${LIBRARY_LOCATION} DIRECTORY)
-        INSTALL(FILES ${LIBRARY_DIR}/${target}.pdb DESTINATION ${target}
+      if(${prefix}_SOURCES)
+        # install the generated DLL file
+        INSTALL(PROGRAMS ${LIBRARY_LOCATION} DESTINATION ${target}
                 COMPONENT ${target}-${${prefix}_VERSION})
-      ENDIF()
+
+        IF(CMAKE_BUILD_TYPE MATCHES Debug)
+          # for debug builds also install the PDB file
+          get_filename_component(LIBRARY_DIR ${LIBRARY_LOCATION} DIRECTORY)
+          INSTALL(FILES ${LIBRARY_DIR}/${target}.pdb DESTINATION ${target}
+                  COMPONENT ${target}-${${prefix}_VERSION})
+        ENDIF()
+      endif()
+      if (${prefix}_CUSTOM_BINARY)
+        list(GET ${prefix}_CUSTOM_BINARY 0 FROM_BINARY)
+        list(GET ${prefix}_CUSTOM_BINARY 1 TO_BINARY)
+        install(FILES ${FROM_BINARY} DESTINATION ${target} RENAME ${TO_BINARY})
+      endif()
     ELSE(WIN32)
       if(NOT CPACK_PACKAGE_DIRECTORY)
         set(CPACK_PACKAGE_DIRECTORY ${CMAKE_BINARY_DIR})
       endif()
-      INSTALL(TARGETS ${target} DESTINATION ${target}
-              COMPONENT ${target}-${${prefix}_VERSION})
+      if(${prefix}_SOURCES)
+        INSTALL(TARGETS ${target} DESTINATION ${target}
+                COMPONENT ${target}-${${prefix}_VERSION})
+      endif()
+      if (${prefix}_CUSTOM_BINARY)
+        list(GET ${prefix}_CUSTOM_BINARY 0 FROM_BINARY)
+        list(GET ${prefix}_CUSTOM_BINARY 1 TO_BINARY)
+        if(OS STREQUAL "android")
+          set(TO_BINARY "lib${TO_BINARY}")
+        endif()
+        install(FILES ${FROM_BINARY} DESTINATION ${target} RENAME ${TO_BINARY}
+                COMPONENT ${target}-${${prefix}_VERSION})
+      endif()
     ENDIF(WIN32)
     add_cpack_workaround(${target} ${${prefix}_VERSION} ${ext})
   ELSE(PACKAGE_ZIP OR PACKAGE_TGZ)
@@ -134,7 +156,17 @@ macro (build_addon target prefix libs)
     else()
       set(CMAKE_INSTALL_LIBDIR "lib/${APP_NAME_LC}")
     endif()
-    INSTALL(TARGETS ${target} DESTINATION ${CMAKE_INSTALL_LIBDIR}/addons/${target})
+    if(${prefix}_SOURCES)
+      INSTALL(TARGETS ${target} DESTINATION ${CMAKE_INSTALL_LIBDIR}/addons/${target})
+    endif()
+    if (${prefix}_CUSTOM_BINARY)
+      list(GET ${prefix}_CUSTOM_BINARY 0 FROM_BINARY)
+      list(GET ${prefix}_CUSTOM_BINARY 1 TO_BINARY)
+      if(OS STREQUAL "android")
+        set(TO_BINARY "lib${TO_BINARY}")
+      endif()
+      install(FILES ${FROM_BINARY} DESTINATION ${CMAKE_INSTALL_LIBDIR}/addons/${target} RENAME ${TO_BINARY})
+    endif()
     INSTALL(DIRECTORY ${target} DESTINATION share/${APP_NAME_LC}/addons PATTERN "addon.xml.in" EXCLUDE)
   ENDIF(PACKAGE_ZIP OR PACKAGE_TGZ)
 endmacro()
diff --git a/project/cmake/scripts/common/handle-depends.cmake b/project/cmake/scripts/common/handle-depends.cmake
index 4d78928..7dadeef 100644
--- a/project/cmake/scripts/common/handle-depends.cmake
+++ b/project/cmake/scripts/common/handle-depends.cmake
@@ -1,11 +1,32 @@
 include(${APP_ROOT}/project/cmake/scripts/common/check_target_platform.cmake)
 
+# exclude all sub-directories and files of a given directory from the list of files
+function(exclude_directory_from_list file_list excluded_directory resulting_list)
+  # list file_list: original list of files
+  # string excluded_directory: directory to be excluded
+  # string resulting_list: variable name where the resulting list should be stored
+
+  foreach(file ${file_list})
+    if("${file}" MATCHES "(.*)${excluded_directory}(.*)")
+      list (REMOVE_ITEM file_list ${file})
+    endif()
+  endforeach()
+
+  set(${resulting_list} ${file_list} PARENT_SCOPE)
+endfunction()
+
 # handle addon depends
 function(add_addon_depends addon searchpath)
   # input: string addon string searchpath
 
   set(OUTPUT_DIR ${DEPENDS_PATH})
+  # look for platform-specific dependencies
   file(GLOB_RECURSE cmake_input_files ${searchpath}/${CORE_SYSTEM_NAME}/*.txt)
+
+  # exclude any platform-specific prebuilt dependencies
+  exclude_directory_from_list("${cmake_input_files}" "${CORE_SYSTEM_NAME}/prebuilt/" cmake_input_files)
+
+  # look for common dependencies
   file(GLOB_RECURSE cmake_input_files2 ${searchpath}/common/*.txt)
   list(APPEND cmake_input_files ${cmake_input_files2})
 
@@ -15,6 +36,7 @@ function(add_addon_depends addon searchpath)
             file MATCHES noinstall.txt OR
             file MATCHES flags.txt OR
             file MATCHES deps.txt OR
+            file MATCHES "[a-z]+-deps[.]txt" OR
             file MATCHES platforms.txt))
       message(STATUS "Processing ${file}")
       file(STRINGS ${file} def)
@@ -46,6 +68,10 @@ function(add_addon_depends addon searchpath)
         # check if there are any library specific flags that need to be passed on
         if(EXISTS ${dir}/flags.txt)
           file(STRINGS ${dir}/flags.txt extraflags)
+
+          # replace some custom placeholders
+          string(REPLACE "@MINGW_TOOLCHAIN_FILE@" "${OUTPUT_DIR}/Toolchain_mingw32.cmake" extraflags "${extraflags}")
+          
           separate_arguments(extraflags)
           message(STATUS "${id} extraflags: ${extraflags}")
         endif()
@@ -123,8 +149,11 @@ function(add_addon_depends addon searchpath)
           set(INSTALL_COMMAND INSTALL_COMMAND "")
         endif()
 
-        # check if there's a deps.txt containing dependencies on other libraries
-        if(EXISTS ${dir}/deps.txt)
+        # check if there's a platform-specific or generic deps.txt containing dependencies on other libraries
+        if(EXISTS ${dir}/${CORE_SYSTEM_NAME}-deps.txt)
+          file(STRINGS ${dir}/${CORE_SYSTEM_NAME}-deps.txt deps)
+          message(STATUS "${id} depends: ${deps}")
+        elseif(EXISTS ${dir}/deps.txt)
           file(STRINGS ${dir}/deps.txt deps)
           message(STATUS "${id} depends: ${deps}")
         else()
diff --git a/project/cmake/scripts/common/prepare-env.cmake b/project/cmake/scripts/common/prepare-env.cmake
index 8e9bd1c..0812a2e 100644
--- a/project/cmake/scripts/common/prepare-env.cmake
+++ b/project/cmake/scripts/common/prepare-env.cmake
@@ -94,43 +94,14 @@ foreach(binding ${bindings})
   endif()
 endforeach()
 
-### on windows we need a "patch" binary to be able to patch 3rd party sources
-if(WIN32)
-  find_program(PATCH_FOUND NAMES patch patch.exe)
-  if(PATCH_FOUND)
-    message(STATUS "patch utility found at ${PATCH_FOUND}")
-  else()
-    set(PATCH_ARCHIVE_NAME "patch-2.5.9-7-bin-3")
-    set(PATCH_ARCHIVE "${PATCH_ARCHIVE_NAME}.zip")
-    set(PATCH_URL "${KODI_MIRROR}/build-deps/win32/${PATCH_ARCHIVE}")
-    set(PATCH_DOWNLOAD ${BUILD_DIR}/download/${PATCH_ARCHIVE})
-
-    # download the archive containing patch.exe
-    message(STATUS "Downloading patch utility from ${PATCH_URL}...")
-    file(DOWNLOAD "${PATCH_URL}" "${PATCH_DOWNLOAD}" STATUS PATCH_DL_STATUS LOG PATCH_LOG SHOW_PROGRESS)
-    list(GET PATCH_DL_STATUS 0 PATCH_RETCODE)
-    if(NOT ${PATCH_RETCODE} EQUAL 0)
-      message(FATAL_ERROR "ERROR downloading ${PATCH_URL} - status: ${PATCH_DL_STATUS} log: ${PATCH_LOG}")
-    endif()
-
-    # extract the archive containing patch.exe
-    execute_process(COMMAND ${CMAKE_COMMAND} -E tar xzvf ${PATCH_DOWNLOAD}
-                    WORKING_DIRECTORY ${BUILD_DIR})
-
-    # make sure the extraction worked and that patch.exe is there
-    set(PATCH_PATH ${BUILD_DIR}/${PATCH_ARCHIVE_NAME})
-    set(PATCH_BINARY_PATH ${PATCH_PATH}/bin/patch.exe)
-    if(NOT EXISTS ${PATCH_PATH} OR NOT EXISTS ${PATCH_BINARY_PATH})
-      message(FATAL_ERROR "ERROR extracting patch utility from ${PATCH_DOWNLOAD_DIR}")
-    endif()
-
-    # copy patch.exe into the output directory
-    file(INSTALL ${PATCH_BINARY_PATH} DESTINATION ${DEPENDS_PATH}/bin)
-
-    # make sure that cmake can find the copied patch.exe
-    find_program(PATCH_FOUND NAMES patch patch.exe)
-    if(NOT PATCH_FOUND)
-      message(FATAL_ERROR "ERROR installing patch utility from ${PATCH_BINARY_PATH} to ${DEPENDS_PATH}/bin")
-    endif()
-  endif()
+### processing additional tools required by the platform
+if(EXISTS ${APP_ROOT}/project/cmake/scripts/${CORE_SYSTEM_NAME}/tools/)
+  file(GLOB platform_tools ${APP_ROOT}/project/cmake/scripts/${CORE_SYSTEM_NAME}/tools/*.cmake)
+  foreach(platform_tool ${platform_tools})
+    get_filename_component(platform_tool_name ${platform_tool} NAME_WE)
+    message(STATUS "Processing ${CORE_SYSTEM_NAME} specific tool: ${platform_tool_name}")
+
+    # include the file
+    include(${platform_tool})
+  endforeach()
 endif()
diff --git a/project/cmake/scripts/windows/archsetup.cmake b/project/cmake/scripts/windows/archsetup.cmake
index 0b86b05..baa3624 100644
--- a/project/cmake/scripts/windows/archsetup.cmake
+++ b/project/cmake/scripts/windows/archsetup.cmake
@@ -15,6 +15,9 @@ list(APPEND CMAKE_SYSTEM_PREFIX_PATH ${PROJECT_SOURCE_DIR}/../../lib/win32)
 list(APPEND CMAKE_SYSTEM_PREFIX_PATH ${PROJECT_SOURCE_DIR}/../../lib/win32/ffmpeg)
 list(APPEND CMAKE_SYSTEM_LIBRARY_PATH ${PROJECT_SOURCE_DIR}/../../lib/win32/ffmpeg/bin)
 list(APPEND CMAKE_SYSTEM_PREFIX_PATH ${PROJECT_SOURCE_DIR}/../BuildDependencies)
+set(CONFIGURATION_LIBDIR lib/${CORE_BUILD_CONFIG}-vc120)
+set(CONFIGURATION_LIBDIR_RELEASE lib/Release-vc120)
+set(CONFIGURATION_LIBDIR_DEBUG lib/Debug-vc120)
 
 set(JPEG_NAMES ${JPEG_NAMES} jpeg-static)
 set(PYTHON_INCLUDE_DIR ${PROJECT_SOURCE_DIR}/../BuildDependencies/include/python)
@@ -29,7 +32,7 @@ set(SYSTEM_DEFINES -DNOMINMAX -D_USE_32BIT_TIME_T -DHAS_DX -D__STDC_CONSTANT_MAC
                    -DPLT_HTTP_DEFAULT_USER_AGENT="UPnP/1.0 DLNADOC/1.50 Kodi"
                    -DPLT_HTTP_DEFAULT_SERVER="UPnP/1.0 DLNADOC/1.50 Kodi"
                    -DBUILDING_WITH_CMAKE
-                   $<$<CONFIG:Debug>:-DD3D_DEBUG_INFO -D_SECURE_SCL=0>)
+                   $<$<CONFIG:Debug>:-DD3D_DEBUG_INFO -D_SECURE_SCL=0 -D_HAS_ITERATOR_DEBUGGING=0>)
 
 # Compile with /MT (to be compatible with the dependent libraries)
 foreach(CompilerFlag CMAKE_CXX_FLAGS CMAKE_CXX_FLAGS_DEBUG CMAKE_CXX_FLAGS_RELEASE
@@ -50,7 +53,8 @@ set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} /SAFESEH:NO")
 # For #pragma comment(lib X)
 # TODO: It would certainly be better to handle these libraries via CMake modules.
 link_directories(${PROJECT_SOURCE_DIR}/../../lib/win32/ffmpeg/bin
-                 ${PROJECT_SOURCE_DIR}/../BuildDependencies/lib)
+                 ${PROJECT_SOURCE_DIR}/../BuildDependencies/lib
+                 ${PROJECT_SOURCE_DIR}/../BuildDependencies/${CONFIGURATION_LIBDIR})
 
 # Additional libraries
 list(APPEND DEPLIBS d3d11.lib DInput8.lib DSound.lib winmm.lib Mpr.lib Iphlpapi.lib
@@ -68,8 +72,8 @@ endforeach()
 
 # DELAYLOAD option
 set(_delayloadlibs libxslt.dll dnssd.dll dwmapi.dll ssh.dll sqlite3.dll
-                   avcodec-57.dll avfilter-6.dll avformat-57.dll avutil-55.dll
-                   postproc-54.dll swresample-2.dll swscale-4.dll d3dcompiler_47.dll)
+                   avcodec-56.dll avfilter-5.dll avformat-56.dll avutil-54.dll
+                   postproc-53.dll swresample-1.dll swscale-3.dll d3dcompiler_47.dll)
 foreach(_lib ${_delayloadlibs})
   set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} /DELAYLOAD:\"${_lib}\"")
 endforeach()
diff --git a/project/cmake/scripts/windows/macros.cmake b/project/cmake/scripts/windows/macros.cmake
index 2b61875..6aabf7d 100644
--- a/project/cmake/scripts/windows/macros.cmake
+++ b/project/cmake/scripts/windows/macros.cmake
@@ -87,13 +87,11 @@ function(add_precompiled_header target pch_header pch_source)
     # As own target for usage in multiple libraries
     if(NOT TARGET ${PCH_PCH_TARGET}_pch)
       add_library(${PCH_PCH_TARGET}_pch STATIC ${pch_source})
-      set_target_properties(${PCH_PCH_TARGET}_pch PROPERTIES COMPILE_PDB_NAME vc140
-                                                             COMPILE_PDB_OUTPUT_DIRECTORY ${PRECOMPILEDHEADER_DIR})
+      set_target_properties(${PCH_PCH_TARGET}_pch PROPERTIES COMPILE_PDB_OUTPUT_DIRECTORY ${PRECOMPILEDHEADER_DIR})
     endif()
     # From VS2012 onwards, precompiled headers have to be linked against (LNK2011).
     target_link_libraries(${target} PUBLIC ${PCH_PCH_TARGET}_pch)
-    set_target_properties(${target} PROPERTIES COMPILE_PDB_NAME vc140
-                                               COMPILE_PDB_OUTPUT_DIRECTORY ${PRECOMPILEDHEADER_DIR})
+    set_target_properties(${target} PROPERTIES COMPILE_PDB_OUTPUT_DIRECTORY ${PRECOMPILEDHEADER_DIR})
   else()
     # As part of the target
     target_sources(${target} PRIVATE ${pch_source})
diff --git a/project/cmake/scripts/windows/tools/7zip.cmake b/project/cmake/scripts/windows/tools/7zip.cmake
new file mode 100644
index 0000000..4962501
--- /dev/null
+++ b/project/cmake/scripts/windows/tools/7zip.cmake
@@ -0,0 +1,37 @@
+find_program(7ZIP_FOUND NAMES 7z 7za 7z.exe 7za.exe)
+if(7ZIP_FOUND)
+  message(STATUS "7-Zip utility found at ${7ZIP_FOUND}")
+else()
+  set(7ZIP_ARCHIVE_NAME "7z-9.20-bin")
+  set(7ZIP_ARCHIVE "${7ZIP_ARCHIVE_NAME}.zip")
+  set(7ZIP_URL "http://mirrors.xbmc.org/build-deps/win32/${7ZIP_ARCHIVE}")
+  set(7ZIP_DOWNLOAD ${BUILD_DIR}/download/${7ZIP_ARCHIVE})
+
+  # download the archive containing 7za.exe
+  message(STATUS "Downloading 7-Zip utility from ${7ZIP_URL}...")
+  file(DOWNLOAD "${7ZIP_URL}" "${7ZIP_DOWNLOAD}" STATUS 7ZIP_DL_STATUS LOG 7ZIP_LOG SHOW_PROGRESS)
+  list(GET 7ZIP_DL_STATUS 0 7ZIP_RETCODE)
+  if(NOT ${7ZIP_RETCODE} EQUAL 0)
+    message(FATAL_ERROR "ERROR downloading ${7ZIP_URL} - status: ${7ZIP_DL_STATUS} log: ${7ZIP_LOG}")
+  endif()
+
+  # extract the archive containing 7za.exe
+  execute_process(COMMAND ${CMAKE_COMMAND} -E tar xzvf ${7ZIP_DOWNLOAD}
+                  WORKING_DIRECTORY ${BUILD_DIR})
+
+  # make sure the extraction worked and that 7za.exe is there
+  set(7ZIP_PATH ${BUILD_DIR}/${7ZIP_ARCHIVE_NAME})
+  set(7ZIP_BINARY_PATH ${7ZIP_PATH}/7za.exe)
+  if(NOT EXISTS ${7ZIP_PATH} OR NOT EXISTS ${7ZIP_BINARY_PATH})
+    message(FATAL_ERROR "ERROR extracting 7-Zip utility from ${7ZIP_PATH}")
+  endif()
+
+  # copy 7za.exe into the output directory
+  file(INSTALL ${7ZIP_BINARY_PATH} DESTINATION ${DEPENDS_PATH}/bin)
+
+  # make sure that cmake can find the copied 7za.exe
+  find_program(7ZIP_FOUND NAMES 7z 7za 7z.exe 7za.exe)
+  if(NOT 7ZIP_FOUND)
+    message(FATAL_ERROR "ERROR installing 7-Zip utility from ${7ZIP_BINARY_PATH} to ${DEPENDS_PATH}/bin")
+  endif()
+endif()
diff --git a/project/cmake/scripts/windows/tools/patch.cmake b/project/cmake/scripts/windows/tools/patch.cmake
new file mode 100644
index 0000000..23cf8be
--- /dev/null
+++ b/project/cmake/scripts/windows/tools/patch.cmake
@@ -0,0 +1,37 @@
+find_program(PATCH_FOUND NAMES patch patch.exe)
+if(PATCH_FOUND)
+  message(STATUS "patch utility found at ${PATCH_FOUND}")
+else()
+  set(PATCH_ARCHIVE_NAME "patch-2.5.9-7-bin-1")
+  set(PATCH_ARCHIVE "${PATCH_ARCHIVE_NAME}.zip")
+  set(PATCH_URL "${KODI_MIRROR}/build-deps/win32/${PATCH_ARCHIVE}")
+  set(PATCH_DOWNLOAD ${BUILD_DIR}/download/${PATCH_ARCHIVE})
+
+  # download the archive containing patch.exe
+  message(STATUS "Downloading patch utility from ${PATCH_URL}...")
+  file(DOWNLOAD "${PATCH_URL}" "${PATCH_DOWNLOAD}" STATUS PATCH_DL_STATUS LOG PATCH_LOG SHOW_PROGRESS)
+  list(GET PATCH_DL_STATUS 0 PATCH_RETCODE)
+  if(NOT ${PATCH_RETCODE} EQUAL 0)
+    message(FATAL_ERROR "ERROR downloading ${PATCH_URL} - status: ${PATCH_DL_STATUS} log: ${PATCH_LOG}")
+  endif()
+
+  # extract the archive containing patch.exe
+  execute_process(COMMAND ${CMAKE_COMMAND} -E tar xzvf ${PATCH_DOWNLOAD}
+                  WORKING_DIRECTORY ${BUILD_DIR})
+
+  # make sure the extraction worked and that patch.exe is there
+  set(PATCH_PATH ${BUILD_DIR}/${PATCH_ARCHIVE_NAME})
+  set(PATCH_BINARY_PATH ${PATCH_PATH}/bin/patch.exe)
+  if(NOT EXISTS ${PATCH_PATH} OR NOT EXISTS ${PATCH_BINARY_PATH})
+    message(FATAL_ERROR "ERROR extracting patch utility from ${PATCH_PATH}")
+  endif()
+
+  # copy patch.exe into the output directory
+  file(INSTALL ${PATCH_BINARY_PATH} DESTINATION ${DEPENDS_PATH}/bin)
+
+  # make sure that cmake can find the copied patch.exe
+  find_program(PATCH_FOUND NAMES patch patch.exe)
+  if(NOT PATCH_FOUND)
+    message(FATAL_ERROR "ERROR installing patch utility from ${PATCH_BINARY_PATH} to ${DEPENDS_PATH}/bin")
+  endif()
+endif()
diff --git a/system/keymaps/keyboard.xml b/system/keymaps/keyboard.xml
index 9d0979d..49d6fb8 100644
--- a/system/keymaps/keyboard.xml
+++ b/system/keymaps/keyboard.xml
@@ -95,7 +95,6 @@
       <sleep>ActivateWindow(shutdownmenu)</sleep>
       <!-- PVR windows -->
       <e>ActivateWindow(TVGuide)</e>
-      <epg>ActivateWindow(TVGuide)</epg>
       <h>ActivateWindow(TVChannels)</h>
       <j>ActivateWindow(RadioChannels)</j>
       <k>ActivateWindow(TVRecordings)</k>
@@ -222,7 +221,6 @@
     <keyboard>
       <e>PreviousMenu</e>
       <t>ShowTimerRule</t>
-      <epg>PreviousMenu</epg>
     </keyboard>
   </TVGuide>
   <MyRadioChannels>
diff --git a/system/library/music/musicroles/Arrangers.xml b/system/library/music/musicroles/Arrangers.xml
index 69c9223..0118e2a 100644
--- a/system/library/music/musicroles/Arrangers.xml
+++ b/system/library/music/musicroles/Arrangers.xml
@@ -1,6 +1,6 @@
 <?xml version='1.0' encoding='UTF-8'?>
 <node order="5" type="folder" visible="Library.HasContent(Role, Arranger)">
-	<label>29988</label>
-	<icon>DefaultMusicGenres.png</icon>
+	<label>Arrangers</label>
+        <icon>DefaultMusicGenres.png</icon>
 	<path>musicdb://artists/?role=Arranger</path>
 </node>
diff --git a/system/library/music/musicroles/Composers.xml b/system/library/music/musicroles/Composers.xml
index e26b79f..d737424 100644
--- a/system/library/music/musicroles/Composers.xml
+++ b/system/library/music/musicroles/Composers.xml
@@ -1,6 +1,6 @@
 <?xml version='1.0' encoding='UTF-8'?>
 <node order="1" type="folder" visible="Library.HasContent(Role, Composer)">
-	<label>29989</label>
-	<icon>DefaultMusicGenres.png</icon>
+	<label>Composers</label>
+      	<icon>DefaultMusicGenres.png</icon>
 	<path>musicdb://artists/?role=Composer</path>
 </node>
diff --git a/system/library/music/musicroles/Conductors.xml b/system/library/music/musicroles/Conductors.xml
index f326052..7cf4452 100644
--- a/system/library/music/musicroles/Conductors.xml
+++ b/system/library/music/musicroles/Conductors.xml
@@ -1,6 +1,6 @@
 <?xml version='1.0' encoding='UTF-8'?>
 <node order="2" type="folder" visible="Library.HasContent(Role, Conductor)">
-	<label>29990</label>
-	<icon>DefaultMusicGenres.png</icon>
+	<label>Conductors</label>
+      <icon>DefaultMusicGenres.png</icon>
 	<path>musicdb://artists/?role=Conductor</path>
 </node>
diff --git a/system/library/music/musicroles/DJMixers.xml b/system/library/music/musicroles/DJMixers.xml
index 7d79e7d..3afe2d3 100644
--- a/system/library/music/musicroles/DJMixers.xml
+++ b/system/library/music/musicroles/DJMixers.xml
@@ -1,6 +1,6 @@
 <?xml version='1.0' encoding='UTF-8'?>
 <node order="6" type="folder" visible="Library.HasContent(Role, DJMixer)">
-	<label>29991</label>
-	<icon>DefaultMusicGenres.png</icon>
+	<label>DJ Mixers</label>
+      <icon>DefaultMusicGenres.png</icon>
 	<path>musicdb://artists/?role=DJMixer</path>
 </node>
diff --git a/system/library/music/musicroles/Lyricists.xml b/system/library/music/musicroles/Lyricists.xml
index b575132..19e324b 100644
--- a/system/library/music/musicroles/Lyricists.xml
+++ b/system/library/music/musicroles/Lyricists.xml
@@ -1,6 +1,6 @@
 <?xml version='1.0' encoding='UTF-8'?>
 <node order="4" type="folder" visible="Library.HasContent(Role, Lyricist)">
-	<label>29992</label>
-	<icon>DefaultMusicGenres.png</icon>
+	<label>Lyricists</label>
+      <icon>DefaultMusicGenres.png</icon>
 	<path>musicdb://artists/?role=Lyricist</path>
 </node>
diff --git a/system/library/music/musicroles/Orchestras.xml b/system/library/music/musicroles/Orchestras.xml
index 0b38613..ed90d31 100644
--- a/system/library/music/musicroles/Orchestras.xml
+++ b/system/library/music/musicroles/Orchestras.xml
@@ -1,6 +1,6 @@
 <?xml version='1.0' encoding='UTF-8'?>
 <node order="3" type="folder" visible="Library.HasContent(Role, Orchestra)">
-	<label>29993</label>
-	<icon>DefaultMusicGenres.png</icon>
+	<label>Orchestras</label>
+        <icon>DefaultMusicGenres.png</icon>
 	<path>musicdb://artists/?role=Orchestra</path>
 </node>
diff --git a/system/library/music/musicroles/index.xml b/system/library/music/musicroles/index.xml
index fede58c..c674375 100644
--- a/system/library/music/musicroles/index.xml
+++ b/system/library/music/musicroles/index.xml
@@ -1,5 +1,5 @@
 <?xml version='1.0' encoding='UTF-8'?>
 <node order="15" type="folder" visible="Library.HasContent(Music)">
-	<label>29994</label>
+	<label>Roles</label>
 	<icon>DefaultMusicSongs.png</icon>
 </node>
diff --git a/system/settings/android.xml b/system/settings/android.xml
index d8025b0..dd21807 100644
--- a/system/settings/android.xml
+++ b/system/settings/android.xml
@@ -8,6 +8,13 @@
     </category>
   </section>
   <section id="videos">
+    <category id="videoplayer">
+      <group id="3">
+        <setting id="videoplayer.usedisplayasclock">
+          <visible>false</visible>
+        </setting>
+      </group>
+    </category>
     <category id="videoacceleration">
       <group id="3">
         <setting id="videoplayer.usemediacodecsurface" type="boolean" label="13440" help="36544">
diff --git a/system/settings/darwin_ios.xml b/system/settings/darwin_ios.xml
index 98881e8..63278b9 100644
--- a/system/settings/darwin_ios.xml
+++ b/system/settings/darwin_ios.xml
@@ -6,6 +6,9 @@
         <setting id="videoplayer.adjustrefreshrate">
           <visible>false</visible>
         </setting>
+        <setting id="videoplayer.pauseafterrefreshchange">
+          <visible>false</visible>
+        </setting>
       </group>
     </category>
     <category id="videoacceleration">
@@ -30,9 +33,6 @@
         <setting id="videoscreen.blankdisplays">
           <visible>false</visible>
         </setting>
-        <setting id="videoscreen.delayrefreshchange">
-          <visible>false</visible>
-        </setting>
       </group>
     </category>
     <category id="audiooutput">
diff --git a/system/settings/settings.xml b/system/settings/settings.xml
index d304e51..fc2a51f 100644
--- a/system/settings/settings.xml
+++ b/system/settings/settings.xml
@@ -1943,6 +1943,93 @@
       </group>
     </category>
   </section>
+  <section id="games" label="15016" help="35200">
+    <category id="gamesgeneral" label="16000" help="35202">
+      <group id="1">
+        <setting id="gamesgeneral.enablerewind" type="boolean" label="35203" help="35204">
+          <level>0</level>
+          <default>true</default>
+          <control type="toggle" />
+        </setting>
+        <setting id="gamesgeneral.rewindtime" type="integer" label="35205" help="35206">
+          <level>2</level>
+          <default>60</default>
+          <constraints>
+            <minimum>10</minimum>
+            <step>10</step>
+            <maximum>600</maximum>
+          </constraints>
+          <dependencies>
+            <dependency type="enable" setting="gamesgeneral.enablerewind">true</dependency>
+          </dependencies>
+          <control type="spinner" format="string">
+            <formatlabel>14045</formatlabel>
+          </control>
+        </setting>
+      </group>
+    </category>
+    <category id="gamesinput" label="15087" help="35201">
+      <group id="1">
+        <setting id="gamesinput.controllerconfig" type="action" label="35063" help="35064">
+          <level>0</level>
+          <dependencies>
+            <dependency type="enable" on="property" name="SupportsPeripheralControllers" />
+          </dependencies>
+          <control type="button" format="action" />
+        </setting>
+      </group>
+      <group id="2">
+        <setting id="gamesinput.emulatedcontrollers" type="integer" label="35066" help="35067">
+          <level>0</level>
+          <default>0</default>
+          <constraints>
+            <minimum>0</minimum>
+            <step>1</step>
+            <maximum>4</maximum>
+          </constraints>
+          <control type="spinner" format="string">
+            <formatlabel>35065</formatlabel>
+          </control>
+        </setting>
+        <setting id="gamesinput.emulatedcontroller1" type="action" label="35069" help="35067">
+          <level>0</level>
+          <control type="button" format="action" />
+          <dependencies>
+            <dependency type="visible">
+              <condition on="property" name="gte" setting="gamesinput.emulatedcontrollers">1</condition>
+            </dependency>
+          </dependencies>
+        </setting>
+        <setting id="gamesinput.emulatedcontroller2" type="action" label="35070" help="35067">
+          <level>0</level>
+          <control type="button" format="action" />
+          <dependencies>
+            <dependency type="visible">
+              <condition on="property" name="gte" setting="gamesinput.emulatedcontrollers">2</condition>
+            </dependency>
+          </dependencies>
+        </setting>
+        <setting id="gamesinput.emulatedcontroller3" type="action" label="35071" help="35067">
+          <level>0</level>
+          <control type="button" format="action" />
+          <dependencies>
+            <dependency type="visible">
+              <condition on="property" name="gte" setting="gamesinput.emulatedcontrollers">3</condition>
+            </dependency>
+          </dependencies>
+        </setting>
+        <setting id="gamesinput.emulatedcontroller4" type="action" label="35072" help="35067">
+          <level>0</level>
+          <control type="button" format="action" />
+          <dependencies>
+            <dependency type="visible">
+              <condition on="property" name="gte" setting="gamesinput.emulatedcontrollers">4</condition>
+            </dependency>
+          </dependencies>
+        </setting>
+      </group>
+    </category>
+  </section>
   <section id="pictures" label="1" help="36304">
     <category id="pictures" label="14081" help="36305">
       <group id="1">
@@ -2739,13 +2826,6 @@
           <control type="toggle" />
           <default>true</default>
         </setting>
-        <setting id="input.controllerconfig" type="action" label="35063" help="35064">
-          <level>0</level>
-          <dependencies>
-            <dependency type="enable" on="property" name="SupportsPeripheralControllers" />
-          </dependencies>
-          <control type="button" format="action" />
-        </setting>
       </group>
     </category>
     <category id="network" label="798" help="36379">
@@ -2895,7 +2975,7 @@
         </setting>
         <setting id="general.addonnotifications" type="boolean" label="36609" help="36612">
           <level>0</level>
-          <default>false</default>
+          <default>true</default>
           <control type="toggle" />
           <dependencies>
             <dependency type="enable" setting="general.addonupdates">0</dependency>
diff --git a/tools/android/packaging/xbmc/AndroidManifest.xml.in b/tools/android/packaging/xbmc/AndroidManifest.xml.in
index 374abec..82cf82c 100644
--- a/tools/android/packaging/xbmc/AndroidManifest.xml.in
+++ b/tools/android/packaging/xbmc/AndroidManifest.xml.in
@@ -5,7 +5,7 @@
     android:versionCode="@APP_VERSION_CODE@"
     android:versionName="@APP_VERSION@" >
 
-    <uses-sdk android:minSdkVersion="19" android:targetSdkVersion="22" />
+    <uses-sdk android:minSdkVersion="17" android:targetSdkVersion="22" />
 
     <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
     <uses-permission android:name="android.permission.INTERNET" />
@@ -21,7 +21,7 @@
     <uses-feature android:name="android.hardware.type.television" android:required="false" />
     <uses-feature android:name="android.hardware.usb.host" android:required="false" />
     <uses-feature android:name="android.hardware.wifi" android:required="false" />
-
+	
     <application android:icon="@drawable/ic_launcher"
 				android:logo="@drawable/banner"
 				android:label="@string/app_name"
@@ -96,3 +96,4 @@
     </application>
 
 </manifest><!-- END_INCLUDE(manifest) -->
+
diff --git a/tools/android/packaging/xbmc/src/org/xbmc/kodi/Main.java.in b/tools/android/packaging/xbmc/src/org/xbmc/kodi/Main.java.in
index d7413e0..b78b7bf 100644
--- a/tools/android/packaging/xbmc/src/org/xbmc/kodi/Main.java.in
+++ b/tools/android/packaging/xbmc/src/org/xbmc/kodi/Main.java.in
@@ -7,7 +7,6 @@ import android.hardware.input.InputManager;
 import android.media.AudioManager;
 import android.os.Bundle;
 import android.util.Log;
-import android.view.Choreographer;
 import android.view.View;
 import android.view.Surface;
 import android.widget.RelativeLayout;
@@ -16,7 +15,7 @@ import android.graphics.PixelFormat;
 import android.os.Handler;
 import org.xbmc.@APP_NAME_LC@.XBMCVideoView;
 
-public class Main extends NativeActivity implements Choreographer.FrameCallback
+public class Main extends NativeActivity
 {
   private static final String TAG = "@APP_NAME_LC@";
 
@@ -28,7 +27,6 @@ public class Main extends NativeActivity implements Choreographer.FrameCallback
   private Handler handler = new Handler();
 
   native void _onNewIntent(Intent intent);
-  native void _doFrame(long frameTimeNanos);
 
   public Main()
   {
@@ -166,8 +164,6 @@ public class Main extends NativeActivity implements Choreographer.FrameCallback
   {
     super.onResume();
 
-    Choreographer.getInstance().postFrameCallback(this);
-
     if (android.os.Build.VERSION.SDK_INT >= 19) {
       // Immersive mode
 
@@ -185,13 +181,6 @@ public class Main extends NativeActivity implements Choreographer.FrameCallback
   }
 
   @Override
-  public void onPause()
-  {
-    super.onPause();
-    
-    Choreographer.getInstance().removeFrameCallback(this);
-  }
-  
   public void onDestroy()
   {
     // unregister the InputDeviceListener implementation
@@ -201,13 +190,6 @@ public class Main extends NativeActivity implements Choreographer.FrameCallback
     getApplicationContext().getContentResolver().unregisterContentObserver(mSettingsContentObserver);
     super.onDestroy();
   }
-  
-  @Override
-  public void doFrame(long frameTimeNanos)
-  {
-    Choreographer.getInstance().postFrameCallback(this);
-    _doFrame(frameTimeNanos);
-  }
 
   private native void _callNative(long funcAddr, long variantAddr);
 
diff --git a/tools/buildsteps/README b/tools/buildsteps/README
index 0fc6349..782e2c4 100644
--- a/tools/buildsteps/README
+++ b/tools/buildsteps/README
@@ -11,5 +11,6 @@ $XBMC_DEPENDS_ROOT - root for installing the xbmc build depends and toolchain he
 Additional ENV variables might be specified by the buildnodes. For android buildslaves these are:
 
 TOOLCHAIN - the used toolchain dir
+TOOLCHAIN_X86 - this is the toolchain dir for x86 toolchain of android. This needs this extra var for beeing able to specify both toolchains (arm & x86) at the same slave.
 NDK_PATH  - the path to the android native ndk
 SDK_PATH  - the path to the android sdk
diff --git a/tools/buildsteps/android/configure-depends b/tools/buildsteps/android/configure-depends
index cb9dd93..746c11f 100644
--- a/tools/buildsteps/android/configure-depends
+++ b/tools/buildsteps/android/configure-depends
@@ -4,8 +4,8 @@ XBMC_PLATFORM_DIR=android
 
 NDK_ARCH="arm"
 #the following pathes must exist on the slave and use the defined scheme here!
-NDK_PATH=$ANDROID_DEV_ROOT/android-ndk-r$NDK_VERSION
-TOOLCHAIN=$ANDROID_DEV_ROOT/android-toolchain-$NDK_ARCH-$SDK_VERSION-r$NDK_VERSION
+CURRENT_NDK_PATH=$ANDROID_DEV_ROOT/android-ndk-r$NDK_VERSION
+CURRENT_TOOLCHAIN=$ANDROID_DEV_ROOT/android-toolchain-$NDK_ARCH-$SDK_VERSION-r$NDK_VERSION
 
 if [ "$(pathChanged $WORKSPACE/tools/depends)" == "1" ]
 then
@@ -13,9 +13,9 @@ then
     --with-tarballs=$TARBALLS \
     --host=arm-linux-androideabi \
     --with-sdk-path=$SDK_PATH \
-    --with-ndk=$NDK_PATH \
+    --with-ndk=$CURRENT_NDK_PATH \
     $(if [ "$SDK_VERSION" != "Default" ]; then echo --with-sdk=android-$SDK_VERSION;fi) \
-    --with-toolchain=$TOOLCHAIN \
+    --with-toolchain=$CURRENT_TOOLCHAIN \
     --prefix=$XBMC_DEPENDS_ROOT \
     --enable-neon
 fi
diff --git a/tools/buildsteps/androidx86/configure-depends b/tools/buildsteps/androidx86/configure-depends
index 69b2309..5c35987 100644
--- a/tools/buildsteps/androidx86/configure-depends
+++ b/tools/buildsteps/androidx86/configure-depends
@@ -4,8 +4,8 @@ XBMC_PLATFORM_DIR=android
 
 NDK_ARCH=x86
 #the following pathes must exist on the slave and use the defined scheme here!
-NDK_PATH=$ANDROID_DEV_ROOT/android-ndk-r$NDK_VERSION
-TOOLCHAIN=$ANDROID_DEV_ROOT/android-toolchain-$NDK_ARCH-$SDK_VERSION-r$NDK_VERSION
+CURRENT_NDK_PATH=$ANDROID_DEV_ROOT/android-ndk-r$NDK_VERSION
+CURRENT_TOOLCHAIN=$ANDROID_DEV_ROOT/android-toolchain-$NDK_ARCH-$SDK_VERSION-r$NDK_VERSION
 
 if [ "$(pathChanged $WORKSPACE/tools/depends)" == "1" ]
 then
@@ -13,8 +13,8 @@ then
     --with-tarballs=$TARBALLS \
     --host=i686-linux-android \
     --with-sdk-path=$SDK_PATH \
-    --with-ndk=$NDK_PATH \
+    --with-ndk=$CURRENT_NDK_PATH \
     $(if [ "$SDK_VERSION" != "Default" ]; then echo --with-sdk=android-$SDK_VERSION;fi) \
-    --with-toolchain=$TOOLCHAIN \
+    --with-toolchain=$CURRENT_TOOLCHAIN \
     --prefix=$XBMC_DEPENDS_ROOT
 fi
diff --git a/tools/buildsteps/defaultenv b/tools/buildsteps/defaultenv
index 6d620ab..e672a1d 100644
--- a/tools/buildsteps/defaultenv
+++ b/tools/buildsteps/defaultenv
@@ -75,7 +75,7 @@ fi
 
 #helper functions
 
-#hash a dir based on the git revision, SDK_PATH, NDK_PATH, NDK_VERSION, SDK_VERSION, TOOLCHAIN and XBMC_DEPENDS_ROOT
+#hash a dir based on the git revision, SDK_PATH, NDK_PATH, NDK_VERSION, SDK_VERSION, TOOLCHAIN TOOLCHAIN_X86 (for droidx86) and XBMC_DEPENDS_ROOT
 #param1 path to be hashed
 function getBuildHash ()
 {
@@ -83,7 +83,7 @@ function getBuildHash ()
   checkPath="$1"
   local hashStr
   hashStr="$(git rev-list HEAD --max-count=1  -- $checkPath)"
-  hashStr="$hashStr $SDK_PATH $NDK_PATH $NDK_VERSION $SDK_VERSION $TOOLCHAIN $XBMC_DEPENDS_ROOT"
+  hashStr="$hashStr $SDK_PATH $NDK_PATH $NDK_VERSION $SDK_VERSION $TOOLCHAIN $TOOLCHAIN_X86 $XBMC_DEPENDS_ROOT"
   echo $hashStr
 }
 
diff --git a/tools/buildsteps/win32/bootstrap-addons.bat b/tools/buildsteps/win32/bootstrap-addons.bat
index 1e1d59a..cddb77a 100644
--- a/tools/buildsteps/win32/bootstrap-addons.bat
+++ b/tools/buildsteps/win32/bootstrap-addons.bat
@@ -18,7 +18,7 @@ if "%1" == "clean" (
 )
 
 rem set Visual C++ build environment
-call "%VS140COMNTOOLS%..\..\VC\bin\vcvars32.bat"
+call "%VS120COMNTOOLS%..\..\VC\bin\vcvars32.bat"
 
 SET WORKDIR=%WORKSPACE%
 
diff --git a/tools/buildsteps/win32/buildffmpeg.sh b/tools/buildsteps/win32/buildffmpeg.sh
index 9283838..6623f3e 100644
--- a/tools/buildsteps/win32/buildffmpeg.sh
+++ b/tools/buildsteps/win32/buildffmpeg.sh
@@ -79,6 +79,7 @@ do_getFFmpegConfig
 
 if [[ "$tools" = "msvc" ]]; then
   # this experimental feature for debuging purpose
+  do_removeOption "--enable-libdcadec"
   do_removeOption "--enable-gnutls"
   do_removeOption "--disable-debug"
   do_addOption "--disable-gnutls"
@@ -143,4 +144,4 @@ cp $FFMPEGDESTDIR/bin/*.dll /xbmc/system/players/VideoPlayer/ &&
 #remove the bgprocessfile for signaling the process end
 if [ -f $BGPROCESSFILE ]; then
   rm $BGPROCESSFILE
-fi
+fi
\ No newline at end of file
diff --git a/tools/buildsteps/win32/download-msys.bat b/tools/buildsteps/win32/download-msys.bat
index e076c7a..5e627e4 100644
--- a/tools/buildsteps/win32/download-msys.bat
+++ b/tools/buildsteps/win32/download-msys.bat
@@ -58,7 +58,7 @@ cd %CUR_PATH%
 rem insert call to vsvars32.bat in msys.bat
 cd %MSYS_INSTALL_PATH%
 Move msys.bat msys.bat_dist
-ECHO CALL "%VS140COMNTOOLS%\..\..\VC\bin\vcvars32.bat">>msys.bat
+ECHO CALL "%VS120COMNTOOLS%vsvars32.bat">>msys.bat
 TYPE msys.bat_dist>>msys.bat
 
 cd %CUR_PATH%
diff --git a/tools/buildsteps/win32/fmpeg_options.txt b/tools/buildsteps/win32/fmpeg_options.txt
index 8f06cd4..a44bb64 100644
--- a/tools/buildsteps/win32/fmpeg_options.txt
+++ b/tools/buildsteps/win32/fmpeg_options.txt
@@ -20,3 +20,4 @@
 --enable-encoder=mjpeg
 --enable-protocol=http
 --enable-runtime-cpudetect
+--enable-libdcadec
diff --git a/tools/buildsteps/win32/make-addons.bat b/tools/buildsteps/win32/make-addons.bat
index 9fa1898..6373ea4 100644
--- a/tools/buildsteps/win32/make-addons.bat
+++ b/tools/buildsteps/win32/make-addons.bat
@@ -24,7 +24,7 @@ FOR %%b IN (%*) DO (
 SETLOCAL DisableDelayedExpansion
 
 rem set Visual C++ build environment
-call "%VS140COMNTOOLS%..\..\VC\bin\vcvars32.bat"
+call "%VS120COMNTOOLS%..\..\VC\bin\vcvars32.bat"
 
 SET WORKDIR=%WORKSPACE%
 
diff --git a/tools/buildsteps/win32/make-mingwlibs.bat b/tools/buildsteps/win32/make-mingwlibs.bat
index bf3dcf6..de634bc 100644
--- a/tools/buildsteps/win32/make-mingwlibs.bat
+++ b/tools/buildsteps/win32/make-mingwlibs.bat
@@ -4,7 +4,7 @@ SETLOCAL
 rem batch file to compile mingw libs via BuildSetup
 SET WORKDIR=%WORKSPACE%
 rem set M$ env
-call "%VS140COMNTOOLS%\..\..\VC\bin\vcvars32.bat" || exit /b 1
+call "%VS120COMNTOOLS%vsvars32.bat" || exit /b 1
 
 SET PROMPTLEVEL=prompt
 SET BUILDMODE=clean
diff --git a/tools/buildsteps/win32/make-mingwlibs.sh b/tools/buildsteps/win32/make-mingwlibs.sh
index 6c58b7d..075132e 100644
--- a/tools/buildsteps/win32/make-mingwlibs.sh
+++ b/tools/buildsteps/win32/make-mingwlibs.sh
@@ -81,7 +81,7 @@ echo " building FFmpeg $BITS"
 echo "-------------------------------------------------"
 runBackgroundProcess "./buildffmpeg.sh $MAKECLEAN"
 setfilepath /xbmc/system/players/VideoPlayer
-checkfiles avcodec-57.dll avformat-57.dll avutil-55.dll postproc-54.dll swscale-4.dll avfilter-6.dll swresample-2.dll
+checkfiles avcodec-56.dll avformat-56.dll avutil-54.dll postproc-53.dll swscale-3.dll avfilter-5.dll swresample-1.dll
 echo "-------------------------------------------------"
 echo " building of FFmpeg $BITS done..."
 echo "-------------------------------------------------"
diff --git a/tools/buildsteps/win32/make-xbmc.bat b/tools/buildsteps/win32/make-xbmc.bat
new file mode 100644
index 0000000..1be66c0
--- /dev/null
+++ b/tools/buildsteps/win32/make-xbmc.bat
@@ -0,0 +1,176 @@
+@ECHO OFF
+rem ----Usage----
+rem BuildSetup [clean|noclean]
+rem clean to force a full rebuild
+rem noclean to force a build without clean
+rem noprompt to avoid all prompts
+CLS
+COLOR 1B
+TITLE XBMC for Windows Build Script
+rem ----PURPOSE----
+rem - Create a working XBMC build with a single click
+rem -------------------------------------------------------------
+rem Config
+rem If you get an error that Visual studio was not found, SET your path for VSNET main executable.
+rem -------------------------------------------------------------
+rem	CONFIG START
+SET comp=vs2010
+SET buildconfig=Release (DirectX)
+SET buildmode=ask
+SET promptlevel=prompt
+SET buildmingwlibs=true
+SET exitcode=0
+FOR %%b in (%1, %2, %3, %4, %5) DO (
+	IF %%b==clean SET buildmode=clean
+	IF %%b==noclean SET buildmode=noclean
+	IF %%b==noprompt SET promptlevel=noprompt
+	IF %%b==nomingwlibs SET buildmingwlibs=false
+)
+
+IF $%Configuration%$ == $$ (
+  IF %Configuration%==Release SET buildconfig=Release (DirectX)
+  IF %Configuration%==Debug   SET buildconfig=Debug (DirectX)
+)
+
+SET BS_DIR=%WORKSPACE%\project\Win32BuildSetup
+cd %BS_DIR%
+
+IF %comp%==vs2010 (
+  IF "%VS100COMNTOOLS%"=="" (
+		set NET="%ProgramFiles%\Microsoft Visual Studio 10.0\Common7\IDE\VCExpress.exe"
+	) ELSE IF EXIST "%VS100COMNTOOLS%\..\IDE\VCExpress.exe" (
+		set NET="%VS100COMNTOOLS%\..\IDE\VCExpress.exe"
+	) ELSE IF EXIST "%VS100COMNTOOLS%\..\IDE\devenv.exe" (
+		set NET="%VS100COMNTOOLS%\..\IDE\devenv.exe"
+	)
+)
+
+IF NOT EXIST %NET% (
+ set DIETEXT=Visual Studio .NET 2010 Express was not found.
+ goto DIE
+)
+
+set OPTS_EXE="..\VS2010Express\XBMC for Windows.sln" /build "%buildconfig%"
+set CLEAN_EXE="..\VS2010Express\XBMC for Windows.sln" /clean "%buildconfig%"
+set EXE= "..\VS2010Express\XBMC\%buildconfig%\XBMC.exe"
+set PDB= "..\VS2010Express\XBMC\%buildconfig%\XBMC.pdb"
+
+rem	CONFIG END
+rem -------------------------------------------------------------
+
+echo                         :                                                  
+echo                        :::                                                 
+echo                        ::::                                                
+echo                        ::::                                                
+echo    :::::::       :::::::::::::::::        ::::::      ::::::        :::::::
+echo    :::::::::   ::::::::::::::::::::     ::::::::::  ::::::::::    :::::::::
+echo     ::::::::: ::::::::::::::::::::::   ::::::::::::::::::::::::  ::::::::: 
+echo          :::::::::     :::      ::::: :::::    ::::::::    :::: :::::      
+echo           ::::::      ::::       :::: ::::      :::::       :::::::        
+echo           :::::       ::::        :::::::       :::::       ::::::         
+echo           :::::       :::         ::::::         :::        ::::::         
+echo           ::::        :::         ::::::        ::::        ::::::         
+echo           ::::        :::        :::::::        ::::        ::::::         
+echo          :::::        ::::       :::::::        ::::        ::::::         
+echo         :::::::       ::::      ::::::::        :::         :::::::        
+echo     :::::::::::::::    :::::  ::::: :::         :::         :::::::::      
+echo  :::::::::  :::::::::  :::::::::::  :::         :::         ::: :::::::::  
+echo  ::::::::    :::::::::  :::::::::   :::         :::         :::  ::::::::  
+echo ::::::         :::::::    :::::     :            ::          ::    ::::::   
+echo Building %buildconfig%
+goto EXE_COMPILE
+
+:EXE_COMPILE
+  IF EXIST buildlog.html del buildlog.html /q
+  IF %buildmode%==clean goto COMPILE_EXE
+  IF %buildmode%==noclean goto COMPILE_NO_CLEAN_EXE
+  rem ---------------------------------------------
+  rem	check for existing exe
+  rem ---------------------------------------------
+  
+  IF EXIST %EXE% (
+    goto EXE_EXIST
+  )
+  goto COMPILE_EXE
+
+:EXE_EXIST
+  IF %promptlevel%==noprompt goto COMPILE_EXE
+  ECHO ------------------------------------------------------------
+  ECHO Found a previous Compiled WIN32 EXE!
+  ECHO [1] a NEW EXE will be compiled for the BUILD_WIN32
+  ECHO [2] existing EXE will be updated (quick mode compile) for the BUILD_WIN32
+  ECHO ------------------------------------------------------------
+  set /P APP_COMPILE_ANSWER=Compile a new EXE? [1/2]:
+  if /I %APP_COMPILE_ANSWER% EQU 1 goto COMPILE_EXE
+  if /I %APP_COMPILE_ANSWER% EQU 2 goto COMPILE_NO_CLEAN_EXE
+  
+:COMPILE_EXE
+  ECHO Wait while preparing the build.
+  ECHO ------------------------------------------------------------
+  ECHO Cleaning Solution...
+  %NET% %CLEAN_EXE%
+  ECHO Compiling XBMC...
+  %NET% %OPTS_EXE%
+  IF NOT EXIST %EXE% (
+  	set DIETEXT="XBMC.EXE failed to build!  See %WORKSPACE%\project\vs2010express\XBMC\%buildconfig%\objs\XBMC.log"
+	IF %promptlevel%==noprompt (
+		type "%WORKSPACE%\project\vs2010express\XBMC\%buildconfig%\objs\XBMC.log"
+	)
+  	goto DIE
+  )
+  ECHO Done!
+  ECHO ------------------------------------------------------------
+  set buildmode=clean
+  GOTO END
+  
+:COMPILE_NO_CLEAN_EXE
+  ECHO Wait while preparing the build.
+  ECHO ------------------------------------------------------------
+  ECHO Compiling Solution...
+  %NET% %OPTS_EXE%
+  IF NOT EXIST %EXE% (
+  	set DIETEXT="XBMC.EXE failed to build!  See %WORKSPACE%\project\vs2010express\XBMC\%buildconfig%\objs\XBMC.log"
+	IF %promptlevel%==noprompt (
+		type "%WORKSPACE%\project\vs2010express\XBMC\%buildconfig%\objs\XBMC.log"
+	)
+  	goto DIE
+  )
+  ECHO Done!
+  ECHO ------------------------------------------------------------
+  GOTO END
+  
+  
+:DIE
+  ECHO ------------------------------------------------------------
+  ECHO !-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-
+  ECHO    ERROR ERROR ERROR ERROR ERROR ERROR ERROR ERROR ERROR
+  ECHO !-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-
+  set DIETEXT=ERROR: %DIETEXT%
+  echo %DIETEXT%
+  SET exitcode=1
+  ECHO ------------------------------------------------------------
+
+:VIEWLOG_EXE
+  SET log="%WORKSPACE%\project\vs2010express\XBMC\%buildconfig%\objs\XBMC.log"
+  IF NOT EXIST %log% goto END
+  
+  copy %log% ./buildlog.html > NUL
+
+  IF %promptlevel%==noprompt (
+  goto END
+  )
+
+  set /P APP_BUILD_ANSWER=View the build log in your HTML browser? [y/n]
+  if /I %APP_BUILD_ANSWER% NEQ y goto END
+  
+  SET log="%WORKSPACE%\project\vs2010express\XBMC\%buildconfig%\objs\" XBMC.log
+  
+  start /D%log%
+  goto END
+
+:END
+  IF %promptlevel% NEQ noprompt (
+  ECHO Press any key to exit...
+  pause > NUL
+  )
+  EXIT /B %exitcode%
\ No newline at end of file
diff --git a/tools/buildsteps/win32/run-tests.bat b/tools/buildsteps/win32/run-tests.bat
index 4954bdc..c8cdde4 100644
--- a/tools/buildsteps/win32/run-tests.bat
+++ b/tools/buildsteps/win32/run-tests.bat
@@ -25,14 +25,14 @@ SET buildconfig=Debug Testsuite
 set WORKSPACE=%CD%\..\..
 
 
-  REM look for MSBuild.exe delivered with Visual Studio 2015
-  FOR /F "tokens=2,* delims= " %%A IN ('REG QUERY HKLM\SOFTWARE\Microsoft\MSBuild\ToolsVersions\14.0 /v MSBuildToolsRoot') DO SET MSBUILDROOT=%%B
-  SET NET="%MSBUILDROOT%14.0\bin\MSBuild.exe"
+  REM look for MSBuild.exe delivered with Visual Studio 2013
+  FOR /F "tokens=2,* delims= " %%A IN ('REG QUERY HKLM\SOFTWARE\Microsoft\MSBuild\ToolsVersions\12.0 /v MSBuildToolsRoot') DO SET MSBUILDROOT=%%B
+  SET NET="%MSBUILDROOT%12.0\bin\MSBuild.exe"
 
   IF EXIST "!NET!" (
     set msbuildemitsolution=1
-    set OPTS_EXE="..\VS2010Express\XBMC for Windows.sln" /t:Build /p:Configuration="%buildconfig%" /property:VCTargetsPath="%MSBUILDROOT%Microsoft.Cpp\v4.0\V140" /m
-    set CLEAN_EXE="..\VS2010Express\XBMC for Windows.sln" /t:Clean /p:Configuration="%buildconfig%" /property:VCTargetsPath="%MSBUILDROOT%Microsoft.Cpp\v4.0\V140"
+    set OPTS_EXE="..\VS2010Express\XBMC for Windows.sln" /t:Build /p:Configuration="%buildconfig%" /property:VCTargetsPath="%MSBUILDROOT%Microsoft.Cpp\v4.0\V120" /m
+    set CLEAN_EXE="..\VS2010Express\XBMC for Windows.sln" /t:Clean /p:Configuration="%buildconfig%" /property:VCTargetsPath="%MSBUILDROOT%Microsoft.Cpp\v4.0\V120"
   )
 
   IF NOT EXIST %NET% (
@@ -95,4 +95,4 @@ GOTO END
   ECHO ------------------------------------------------------------
 
 :END
-  EXIT /B %exitcode%
+  EXIT /B %exitcode%
\ No newline at end of file
diff --git a/tools/darwin/Configurations/App.xcconfig.in b/tools/darwin/Configurations/App.xcconfig.in
index 2ce132c..1a15305 100644
--- a/tools/darwin/Configurations/App.xcconfig.in
+++ b/tools/darwin/Configurations/App.xcconfig.in
@@ -25,7 +25,7 @@ HEADER_SEARCH_PATHS = $(inherited) $SRCROOT xbmc xbmc/linux xbmc/cores/VideoPlay
 LIBRARY_SEARCH_PATHS = $(inherited) $(SRCROOT) $(SRCROOT)/xbmc/interfaces/json-rpc "$(SRCROOT)/xbmc/interfaces/python" "$(SRCROOT)/xbmc/interfaces/legacy"
 FRAMEWORK_SEARCH_PATHS = $(inherited) "$(SDKROOT)/System/Library/PrivateFrameworks/" "$(SDKROOT)/System/Library/Frameworks/"
 
-XBMC_OTHER_LDFLAGS_COMMON = $(inherited) -Wl,-headerpad_max_install_names -Wl,-all_load -L$XBMC_DEPENDS/lib -lbz2 -lintl -lexpat -lssl -lgpg-error -lresolv -lffi -lssh -llzo2 -lpcre -lpcrecpp -lfribidi -lfreetype -lfontconfig -lsqlite3 -ltinyxml -lmicrohttpd -lsmbclient -lpython2.7 -lyajl -lcrypto -lgcrypt -lavdevice -lavfilter -lavcodec -lavformat -lpostproc -lavutil -lswresample -lswscale -ltag -L$XBMC_DEPENDS/lib/mysql -lmysqlclient -lxml2 -lxslt -lnettle -lgmp -lhogweed -lgnutls -lcrossguid -lz -lm -liconv
+XBMC_OTHER_LDFLAGS_COMMON = $(inherited) -Wl,-headerpad_max_install_names -Wl,-all_load -L$XBMC_DEPENDS/lib -lbz2 -lintl -lexpat -lssl -lgpg-error -lresolv -lffi -lssh -llzo2 -lpcre -lpcrecpp -lfribidi -lfreetype -lfontconfig -lsqlite3 -ltinyxml -lmicrohttpd -lsmbclient -lpython2.7 -lyajl -lcrypto -lgcrypt -lavdevice -lavfilter -lavcodec -lavformat -lpostproc -lavutil -ldcadec -lswresample -lswscale -ltag -L$XBMC_DEPENDS/lib/mysql -lmysqlclient -lxml2 -lxslt -lnettle -lgmp -lhogweed -lgnutls -lcrossguid -lz -lm -liconv
 
 CLANG_CXX_LANGUAGE_STANDARD = c++0x
 CLANG_CXX_LIBRARY = libc++
diff --git a/tools/depends/target/Makefile b/tools/depends/target/Makefile
index b4baaba..95e2d29 100644
--- a/tools/depends/target/Makefile
+++ b/tools/depends/target/Makefile
@@ -16,11 +16,11 @@ DEPENDS = \
 	libplist libcec libbluray tinyxml dummy-libxbmc \
 	libamplayer libssh taglib libusb libnfs \
 	pythonmodule-pil pythonmodule-setuptools \
-	libxslt ffmpeg platform crossguid \
+	libxslt ffmpeg platform crossguid libdcadec \
         libdvdread libdvdnav libdvdcss
 
 
-FFMPEG_DEPENDS = gnutls
+FFMPEG_DEPENDS = gnutls libdcadec
 
 ifeq ($(ENABLE_GPLV3),yes)
   DEPENDS+=samba-gplv3 libcdio-gplv3
diff --git a/tools/depends/target/ffmpeg/CMakeLists.txt b/tools/depends/target/ffmpeg/CMakeLists.txt
index a061fd5..3a06eb4 100644
--- a/tools/depends/target/ffmpeg/CMakeLists.txt
+++ b/tools/depends/target/ffmpeg/CMakeLists.txt
@@ -29,7 +29,7 @@ elseif(CORE_SYSTEM_NAME STREQUAL ios)
   if(NOT CPU MATCHES arm64)
     list(APPEND ffmpeg_conf --cpu=cortex-a8)
   endif()
-  list(APPEND ffmpeg_conf --disable-decoder=mpeg_xvmc --disable-vda --disable-crystalhd --disable-videotoolbox
+  list(APPEND ffmpeg_conf --disable-decoder=mpeg_xvmc --disable-vda --disable-crystalhd
                           --target-os=darwin)
 elseif(CORE_SYSTEM_NAME STREQUAL osx)
   list(APPEND ffmpeg_conf --disable-outdev=sdl
@@ -80,6 +80,7 @@ externalproject_add(ffmpeg
                       --enable-encoder=aac
                       --enable-encoder=wmav2
                       --enable-protocol=http
+                      --enable-libdcadec
                       --enable-encoder=png
                       --enable-encoder=mjpeg
                       ${ffmpeg_conf}
diff --git a/tools/depends/target/ffmpeg/FFMPEG-VERSION b/tools/depends/target/ffmpeg/FFMPEG-VERSION
index c38483e..bf14f65 100644
--- a/tools/depends/target/ffmpeg/FFMPEG-VERSION
+++ b/tools/depends/target/ffmpeg/FFMPEG-VERSION
@@ -1,5 +1,5 @@
 LIBNAME=ffmpeg
 BASE_URL=https://github.com/xbmc/FFmpeg/archive
-VERSION=release/3.0-xbmc
+VERSION=release/2.8-xbmc
 ARCHIVE=$(LIBNAME)-$(VERSION).tar.gz
 GNUTLS_VER=3.4.9
diff --git a/tools/depends/target/ffmpeg/Makefile b/tools/depends/target/ffmpeg/Makefile
index 277d281..b453f3d 100644
--- a/tools/depends/target/ffmpeg/Makefile
+++ b/tools/depends/target/ffmpeg/Makefile
@@ -19,6 +19,7 @@ ffmpg_config += --enable-muxer=asf --enable-muxer=ipod
 ffmpg_config += --enable-encoder=ac3 --enable-encoder=aac
 ffmpg_config += --enable-encoder=wmav2 --enable-protocol=http
 ffmpg_config += --enable-gnutls
+ffmpg_config += --enable-libdcadec
 ffmpg_config += --enable-encoder=png --enable-encoder=mjpeg
 
 ifeq ($(CROSS_COMPILING), yes)
@@ -42,7 +43,7 @@ ifeq ($(OS), ios)
     ffmpg_config += --cpu=cortex-a8
   endif
   ffmpg_config += --yasmexe=$(NATIVEPREFIX)/bin/yasm
-  ffmpg_config += --disable-decoder=mpeg_xvmc --disable-vda --disable-crystalhd --disable-videotoolbox
+  ffmpg_config += --disable-decoder=mpeg_xvmc --disable-vda --disable-crystalhd
   ffmpg_config += --target-os=darwin
 endif
 ifeq ($(OS), osx)
diff --git a/tools/depends/target/ffmpeg/autobuild.sh b/tools/depends/target/ffmpeg/autobuild.sh
index bf02e52..64224d9 100755
--- a/tools/depends/target/ffmpeg/autobuild.sh
+++ b/tools/depends/target/ffmpeg/autobuild.sh
@@ -160,8 +160,10 @@ CFLAGS="$CFLAGS" CXXFLAGS="$CXXFLAGS" LDFLAGS="$LDFLAGS" \
 	--enable-nonfree \
 	--enable-pthreads \
 	--enable-zlib \
-	--disable-mipsdsp \
+	--disable-mips32r2 \
+	--disable-mipsdspr1 \
 	--disable-mipsdspr2 \
+	--enable-libdcadec \
         ${FLAGS}
 
 make -j ${BUILDTHREADS} 
diff --git a/tools/depends/target/libdcadec/Makefile b/tools/depends/target/libdcadec/Makefile
new file mode 100644
index 0000000..6446781
--- /dev/null
+++ b/tools/depends/target/libdcadec/Makefile
@@ -0,0 +1,62 @@
+-include ../../Makefile.include
+DEPS= Makefile
+
+# lib name, version
+LIBNAME=libdcadec
+VERSION=git-2a9186e3
+SOURCE=$(LIBNAME)-$(VERSION)
+ARCHIVE=$(SOURCE).tar.gz
+
+ifeq ($(CROSS_COMPILING), yes)
+  DEPS += ../../Makefile.include libdcadec_android.patch
+  EXTRA_FLAGS = CC="$(CC)" CFLAGS="$(CFLAGS)" LDFLAGS="$(LDFLAGS)" AR="$(AR)"
+else
+  ROOT_DIR := $(shell dirname $(realpath $(lastword $(MAKEFILE_LIST))))
+
+  ifeq ($(PLATFORM),)
+    PLATFORM = native
+    TARBALLS_LOCATION = $(ROOT_DIR)
+    BASE_URL := http://mirrors.kodi.tv/build-deps/sources
+    RETRIEVE_TOOL := curl -Ls --create-dirs -f -O
+    ARCHIVE_TOOL := tar --strip-components=1 -xf
+  endif
+endif
+
+
+# configuration settings
+
+LIBDYLIB=$(PLATFORM)/.libs/$(LIBNAME).a
+
+CFLAGS += -std=gnu99
+
+all: $(LIBDYLIB) .installed-$(PLATFORM)
+
+$(TARBALLS_LOCATION)/$(ARCHIVE):
+	cd $(TARBALLS_LOCATION); $(RETRIEVE_TOOL) $(RETRIEVE_TOOL_FLAGS) $(BASE_URL)/$(ARCHIVE)
+
+$(PLATFORM): $(TARBALLS_LOCATION)/$(ARCHIVE) $(DEPS)
+ifeq ($(PREFIX),)
+	@echo
+	@echo "ERROR: please set PREFIX to the kodi install path e.g. make PREFIX=/usr/local"
+	@exit 1
+endif
+
+	rm -rf $(PLATFORM)/*; mkdir -p $(PLATFORM)
+	cd $(PLATFORM); $(ARCHIVE_TOOL) $(ARCHIVE_TOOL_FLAGS) $(TARBALLS_LOCATION)/$(ARCHIVE)
+ifeq ($(OS),android)
+	cd $(PLATFORM); patch -p1 < ../libdcadec_android.patch
+endif
+
+$(LIBDYLIB): $(PLATFORM)
+	$(MAKE) -C $(PLATFORM) PREFIX=$(PREFIX) $(EXTRA_FLAGS)
+
+.installed-$(PLATFORM): $(LIBDYLIB)
+	$(MAKE) -C $(PLATFORM) PREFIX=$(PREFIX) $(EXTRA_FLAGS) install
+	touch $@
+
+clean:
+	$(MAKE) -C $(PLATFORM) clean
+	rm -f .installed-$(PLATFORM)
+
+distclean::
+	rm -rf $(PLATFORM) .installed-$(PLATFORM) libdcadec-*.tar.gz
diff --git a/tools/depends/target/libdcadec/libdcadec_android.patch b/tools/depends/target/libdcadec/libdcadec_android.patch
new file mode 100644
index 0000000..6de9f35
--- /dev/null
+++ b/tools/depends/target/libdcadec/libdcadec_android.patch
@@ -0,0 +1,13 @@
+diff --git a/libdcadec/dca_stream.c b/libdcadec/dca_stream.c
+index 156f874..acbd139 100644
+--- a/libdcadec/dca_stream.c
++++ b/libdcadec/dca_stream.c
+@@ -37,7 +37,7 @@
+ #if (defined _WIN32)
+ #define DCA_FGETC   _fgetc_nolock
+ #elif (defined _BSD_SOURCE)
+-#define DCA_FGETC   fgetc_unlocked
++#define DCA_FGETC   fgetc
+ #else
+ #define DCA_FGETC   fgetc
+ #endif
diff --git a/xbmc/Application.cpp b/xbmc/Application.cpp
index 7c0c9d5..f74547a 100644
--- a/xbmc/Application.cpp
+++ b/xbmc/Application.cpp
@@ -153,6 +153,9 @@
 
 #include "epg/EpgContainer.h"
 
+// Game-related include files
+#include "games/GameManager.h"
+
 #include "video/dialogs/GUIDialogFullScreenInfo.h"
 #include "guilib/GUIControlFactory.h"
 #include "dialogs/GUIDialogCache.h"
@@ -198,7 +201,6 @@
 
 #ifdef TARGET_POSIX
 #include "XHandle.h"
-#include "XTimeUtils.h"
 #endif
 
 #if defined(TARGET_ANDROID)
@@ -639,14 +641,6 @@ bool CApplication::Create()
   CWIN32Util::SetThreadLocalLocale(true); // enable independent locale for each thread, see https://connect.microsoft.com/VisualStudio/feedback/details/794122
 #endif // TARGET_WINDOWS
 
-  // initialize the addon database (must be before the addon manager is init'd)
-  CDatabaseManager::GetInstance().Initialize(true);
-
-  if (!m_ServiceManager->Init2())
-  {
-    return false;
-  }
-
   // start the AudioEngine
   if (!CAEFactory::StartEngine())
   {
@@ -665,6 +659,14 @@ bool CApplication::Create()
   m_replayGainSettings.iNoGainPreAmp = CSettings::GetInstance().GetInt(CSettings::SETTING_MUSICPLAYER_REPLAYGAINNOGAINPREAMP);
   m_replayGainSettings.bAvoidClipping = CSettings::GetInstance().GetBool(CSettings::SETTING_MUSICPLAYER_REPLAYGAINAVOIDCLIPPING);
 
+  // initialize the addon database (must be before the addon manager is init'd)
+  CDatabaseManager::GetInstance().Initialize(true);
+
+  if (!m_ServiceManager->Init2())
+  {
+    return false;
+  }
+
   // Create the Mouse, Keyboard, Remote, and Joystick devices
   // Initialize after loading settings to get joystick deadzone setting
   CInputManager::GetInstance().InitializeInputs();
@@ -1163,6 +1165,7 @@ bool CApplication::Initialize()
       uiInitializationFinished = firstWindow != WINDOW_STARTUP_ANIM;
 
       CStereoscopicsManager::GetInstance().Initialize();
+      CApplicationMessenger::GetInstance().SendMsg(TMSG_SETAUDIODSPSTATE, ACTIVE_AE_DSP_STATE_ON, ACTIVE_AE_DSP_SYNC_ACTIVATE); // send a blocking message to active AudioDSP engine
 
       if (!m_ServiceManager->Init3())
       {
@@ -1217,6 +1220,8 @@ bool CApplication::Initialize()
     g_windowManager.SendThreadMessage(msg);
   }
 
+  GAME::CGameManager::GetInstance().Start();
+
   return true;
 }
 
@@ -2492,9 +2497,9 @@ void CApplication::OnApplicationMessage(ThreadMessage* pMsg)
 
   case TMSG_SETAUDIODSPSTATE:
     if(pMsg->param1 == ACTIVE_AE_DSP_STATE_ON)
-      CServiceBroker::GetADSP().Activate();
+      ActiveAE::CActiveAEDSP::GetInstance().Activate(pMsg->param2 == ACTIVE_AE_DSP_ASYNC_ACTIVATE);
     else if(pMsg->param1 == ACTIVE_AE_DSP_STATE_OFF)
-      CServiceBroker::GetADSP().Deactivate();
+      ActiveAE::CActiveAEDSP::GetInstance().Deactivate();
     break;
 
   case TMSG_START_ANDROID_ACTIVITY:
@@ -2896,13 +2901,14 @@ void CApplication::Stop(int exitCode)
     if (CVideoLibraryQueue::GetInstance().IsRunning())
       CVideoLibraryQueue::GetInstance().CancelAllJobs();
 
-    CServiceBroker::GetADSP().Deactivate();
+    CApplicationMessenger::GetInstance().SendMsg(TMSG_SETAUDIODSPSTATE, ACTIVE_AE_DSP_STATE_OFF); // send a blocking message to deactivate AudioDSP engine
     CApplicationMessenger::GetInstance().Cleanup();
 
     CLog::Log(LOGNOTICE, "stop player");
     m_pPlayer->ClosePlayer();
 
     StopPVRManager();
+    GAME::CGameManager::GetInstance().Stop();
     StopServices();
 
 #ifdef HAS_ZEROCONF
diff --git a/xbmc/ApplicationPlayer.cpp b/xbmc/ApplicationPlayer.cpp
index e20183f..390f8f9 100644
--- a/xbmc/ApplicationPlayer.cpp
+++ b/xbmc/ApplicationPlayer.cpp
@@ -827,6 +827,15 @@ float CApplicationPlayer::GetRenderAspectRatio()
     return 1.0;
 }
 
+RESOLUTION CApplicationPlayer::GetRenderResolution()
+{
+  std::shared_ptr<IPlayer> player = GetInternal();
+  if (player)
+    return player->GetRenderResolution();
+  else
+    return RES_INVALID;
+}
+
 void CApplicationPlayer::TriggerUpdateResolution()
 {
   std::shared_ptr<IPlayer> player = GetInternal();
diff --git a/xbmc/ApplicationPlayer.h b/xbmc/ApplicationPlayer.h
index f1f4910..aac8cb5 100644
--- a/xbmc/ApplicationPlayer.h
+++ b/xbmc/ApplicationPlayer.h
@@ -87,6 +87,7 @@ public:
   void FlushRenderer();
   void SetRenderViewMode(int mode);
   float GetRenderAspectRatio();
+  RESOLUTION GetRenderResolution();
   void TriggerUpdateResolution();
   bool IsRenderingVideo();
   bool IsRenderingGuiLayer();
diff --git a/xbmc/ContextMenuManager.cpp b/xbmc/ContextMenuManager.cpp
index e4ad14e..3f93f1b 100644
--- a/xbmc/ContextMenuManager.cpp
+++ b/xbmc/ContextMenuManager.cpp
@@ -29,8 +29,6 @@
 #include "video/ContextMenus.h"
 #include "utils/log.h"
 
-#include <iterator>
-
 using namespace ADDON;
 
 
diff --git a/xbmc/FileItem.cpp b/xbmc/FileItem.cpp
index ff36a16..912e047 100644
--- a/xbmc/FileItem.cpp
+++ b/xbmc/FileItem.cpp
@@ -58,6 +58,8 @@
 #include "utils/log.h"
 #include "utils/Variant.h"
 #include "utils/Mime.h"
+#include "games/GameManager.h"
+#include "games/tags/GameInfoTag.h"
 
 #include <assert.h>
 #include <algorithm>
@@ -67,6 +69,7 @@ using namespace PLAYLIST;
 using namespace MUSIC_INFO;
 using namespace PVR;
 using namespace EPG;
+using namespace GAME;
 
 CFileItem::CFileItem(const CSong& song)
 {
@@ -239,7 +242,8 @@ CFileItem::CFileItem(const CGenre& genre)
 CFileItem::CFileItem(const CFileItem& item)
 : m_musicInfoTag(NULL),
   m_videoInfoTag(NULL),
-  m_pictureInfoTag(NULL)
+  m_pictureInfoTag(NULL),
+  m_gameInfoTag(NULL)
 {
   *this = item;
 }
@@ -325,10 +329,12 @@ CFileItem::~CFileItem(void)
   delete m_musicInfoTag;
   delete m_videoInfoTag;
   delete m_pictureInfoTag;
+  delete m_gameInfoTag;
 
   m_musicInfoTag = NULL;
   m_videoInfoTag = NULL;
   m_pictureInfoTag = NULL;
+  m_gameInfoTag = NULL;
 }
 
 const CFileItem& CFileItem::operator=(const CFileItem& item)
@@ -385,6 +391,19 @@ const CFileItem& CFileItem::operator=(const CFileItem& item)
     m_pictureInfoTag = NULL;
   }
 
+  if (item.m_gameInfoTag)
+  {
+    if (m_gameInfoTag)
+      *m_gameInfoTag = *item.m_gameInfoTag;
+    else
+      m_gameInfoTag = new CGameInfoTag(*item.m_gameInfoTag);
+  }
+  else
+  {
+    delete m_gameInfoTag;
+    m_gameInfoTag = NULL;
+  }
+
   m_epgInfoTag = item.m_epgInfoTag;
   m_pvrChannelInfoTag = item.m_pvrChannelInfoTag;
   m_pvrRecordingInfoTag = item.m_pvrRecordingInfoTag;
@@ -417,6 +436,7 @@ void CFileItem::Initialize()
   m_musicInfoTag = NULL;
   m_videoInfoTag = NULL;
   m_pictureInfoTag = NULL;
+  m_gameInfoTag = NULL;
   m_bLabelPreformated = false;
   m_bIsAlbum = false;
   m_dwSize = 0;
@@ -463,6 +483,8 @@ void CFileItem::Reset()
   m_pvrRadioRDSInfoTag.reset();
   delete m_pictureInfoTag;
   m_pictureInfoTag=NULL;
+  delete m_gameInfoTag;
+  m_gameInfoTag = NULL;
   m_extrainfo.clear();
   ClearProperties();
 
@@ -528,6 +550,13 @@ void CFileItem::Archive(CArchive& ar)
     }
     else
       ar << 0;
+    if (m_gameInfoTag)
+    {
+      ar << 1;
+      ar << *m_gameInfoTag;
+    }
+    else
+      ar << 0;
   }
   else
   {
@@ -571,6 +600,9 @@ void CFileItem::Archive(CArchive& ar)
     ar >> iType;
     if (iType == 1)
       ar >> *GetPictureInfoTag();
+    ar >> iType;
+    if (iType == 1)
+      ar >> *GetGameInfoTag();
 
     SetInvalid();
   }
@@ -600,6 +632,9 @@ void CFileItem::Serialize(CVariant& value) const
 
   if (m_pictureInfoTag)
     (*m_pictureInfoTag).Serialize(value["pictureInfoTag"]);
+
+  if (m_gameInfoTag)
+    (*m_gameInfoTag).Serialize(value["gameInfoTag"]);
 }
 
 void CFileItem::ToSortable(SortItem &sortable, Field field) const
@@ -670,6 +705,9 @@ void CFileItem::ToSortable(SortItem &sortable, Field field) const
         break;
     }
   }
+
+  if (HasGameInfoTag())
+    GetGameInfoTag()->ToSortable(sortable, field);
 }
 
 void CFileItem::ToSortable(SortItem &sortable, const Fields &fields) const
@@ -726,6 +764,9 @@ bool CFileItem::IsVideo() const
   if (HasVideoInfoTag())
     return true;
 
+  if (HasGameInfoTag())
+    return false;
+
   if (HasMusicInfoTag())
     return false;
 
@@ -748,6 +789,11 @@ bool CFileItem::IsVideo() const
      return true;
   }
 
+  // If the file is a zip file, ask the game clients if any support this file
+  // before assuming it is video.
+  if (StringUtils::EqualsNoCase(URIUtils::GetExtension(m_strPath), ".zip") && CGameManager::GetInstance().IsGame(m_strPath))
+    return false;
+
   return URIUtils::HasExtension(m_strPath, g_advancedSettings.m_videoExtensions);
 }
 
@@ -812,6 +858,9 @@ bool CFileItem::IsAudio() const
   if (HasPictureInfoTag())
     return false;
 
+  if (HasGameInfoTag())
+    return false;
+
   if (IsCDDA())
     return true;
 
@@ -824,9 +873,31 @@ bool CFileItem::IsAudio() const
      return true;
   }
 
+  // If the file is a zip file, ask the game clients if any support this file
+  // before assuming it is audio.
+  if (StringUtils::EqualsNoCase(URIUtils::GetExtension(m_strPath), ".zip") && CGameManager::GetInstance().IsGame(m_strPath))
+    return false;
+
   return URIUtils::HasExtension(m_strPath, g_advancedSettings.GetMusicExtensions());
 }
 
+bool CFileItem::IsGame() const
+{
+  if (HasGameInfoTag())
+    return true;
+
+  if (HasVideoInfoTag())
+    return false;
+
+  if (HasMusicInfoTag())
+    return false;
+
+  if (HasPictureInfoTag())
+    return false;
+
+  return CGameManager::GetInstance().IsGame(m_strPath);
+}
+
 bool CFileItem::IsPicture() const
 {
   if(StringUtils::StartsWithNoCase(m_mimetype, "image/"))
@@ -835,6 +906,9 @@ bool CFileItem::IsPicture() const
   if (HasPictureInfoTag())
     return true;
 
+  if (HasGameInfoTag())
+    return false;
+
   if (HasMusicInfoTag())
     return false;
 
@@ -1354,15 +1428,6 @@ void CFileItem::FillInMimeType(bool lookup /*= true*/)
     StringUtils::Replace(m_strPath, "http:", "mms:");
 }
 
-void CFileItem::SetMimeTypeForInternetFile()
-{
-  if (m_doContentLookup && IsInternetStream())
-  {
-    SetMimeType("");
-    FillInMimeType(true);
-  }
-}
-
 bool CFileItem::IsSamePath(const CFileItem *item) const
 {
   if (!item)
@@ -1444,6 +1509,11 @@ void CFileItem::UpdateInfo(const CFileItem &item, bool replaceLabels /*=true*/)
     *GetPictureInfoTag() = *item.GetPictureInfoTag();
     SetInvalid();
   }
+  if (item.HasGameInfoTag())
+  {
+    *GetGameInfoTag() = *item.GetGameInfoTag();
+    SetInvalid();
+  }
   if (replaceLabels && !item.GetLabel().empty())
     SetLabel(item.GetLabel());
   if (replaceLabels && !item.GetLabel2().empty())
@@ -2710,7 +2780,7 @@ void CFileItemList::RemoveDiscCache(int windowID) const
   std::string cacheFile(GetDiscFileCache(windowID));
   if (CFile::Exists(cacheFile))
   {
-    CLog::Log(LOGDEBUG,"Clearing cached fileitems [%s]", CURL::GetRedacted(GetPath()).c_str());
+    CLog::Log(LOGDEBUG,"Clearing cached fileitems [%s]",GetPath().c_str());
     CFile::Delete(cacheFile);
   }
 }
@@ -3165,6 +3235,18 @@ bool CFileItem::LoadMusicTag()
   return false;
 }
 
+bool CFileItem::LoadGameTag()
+{
+  // Already loaded?
+  if (HasGameInfoTag() && m_gameInfoTag->IsLoaded())
+    return true;
+
+  // TODO
+  GetGameInfoTag();
+
+  return false;
+}
+
 void CFileItemList::Swap(unsigned int item1, unsigned int item2)
 {
   if (item1 != item2 && item1 < m_items.size() && item2 < m_items.size())
@@ -3249,6 +3331,14 @@ MUSIC_INFO::CMusicInfoTag* CFileItem::GetMusicInfoTag()
   return m_musicInfoTag;
 }
 
+CGameInfoTag* CFileItem::GetGameInfoTag()
+{
+  if (!m_gameInfoTag)
+    m_gameInfoTag = new CGameInfoTag;
+
+  return m_gameInfoTag;
+}
+
 std::string CFileItem::FindTrailer() const
 {
   std::string strFile2;
diff --git a/xbmc/FileItem.h b/xbmc/FileItem.h
index 252f6c3..ee991d7 100644
--- a/xbmc/FileItem.h
+++ b/xbmc/FileItem.h
@@ -60,6 +60,10 @@ namespace PVR
   typedef std::shared_ptr<PVR::CPVRRadioRDSInfoTag> CPVRRadioRDSInfoTagPtr;
 }
 class CPictureInfoTag;
+namespace GAME
+{
+  class CGameInfoTag;
+}
 
 class CAlbum;
 class CArtist;
@@ -143,19 +147,19 @@ public:
   virtual bool IsFileItem() const { return true; };
 
   bool Exists(bool bUseCache = true) const;
-
+  
   /*!
-   \brief Check whether an item is an optical media folder or its parent.
+   \brief Check whether an item is an optical media folder or its parent. 
     This will return the non-empty path to the playable entry point of the media
-    one or two levels down (VIDEO_TS.IFO for DVDs or index.bdmv for BDs).
+    one or two levels down (VIDEO_TS.IFO for DVDs or index.bdmv for BDs). 
     The returned path will be empty if folder does not meet this criterion.
-   \return non-empty string if item is optical media folder, empty otherwise.
+   \return non-empty string if item is optical media folder, empty otherwise. 
    */
   std::string GetOpticalMediaPath() const;
   /*!
    \brief Check whether an item is a video item. Note that this returns true for
     anything with a video info tag, so that may include eg. folders.
-   \return true if item is video, false otherwise.
+   \return true if item is video, false otherwise. 
    */
   bool IsVideo() const;
 
@@ -164,7 +168,7 @@ public:
   /*!
    \brief Check whether an item is a picture item. Note that this returns true for
     anything with a picture info tag, so that may include eg. folders.
-   \return true if item is picture, false otherwise.
+   \return true if item is picture, false otherwise. 
    */
   bool IsPicture() const;
   bool IsLyrics() const;
@@ -173,10 +177,11 @@ public:
   /*!
    \brief Check whether an item is an audio item. Note that this returns true for
     anything with a music info tag, so that may include eg. folders.
-   \return true if item is audio, false otherwise.
+   \return true if item is audio, false otherwise. 
    */
   bool IsAudio() const;
 
+  bool IsGame() const;
   bool IsCUESheet() const;
   bool IsInternetStream(const bool bStrictCheck = false) const;
   bool IsPlayList() const;
@@ -203,7 +208,7 @@ public:
   bool IsOnDVD() const;
   bool IsOnLAN() const;
   bool IsHD() const;
-  bool IsNfs() const;
+  bool IsNfs() const;  
   bool IsRemote() const;
   bool IsSmb() const;
   bool IsURL() const;
@@ -352,6 +357,18 @@ public:
   bool HasAddonInfo() const { return m_addonInfo != nullptr; }
   const std::shared_ptr<const ADDON::IAddon> GetAddonInfo() const { return m_addonInfo; }
 
+  inline bool HasGameInfoTag() const
+  {
+    return m_gameInfoTag != NULL;
+  }
+
+  GAME::CGameInfoTag* GetGameInfoTag();
+
+  inline const GAME::CGameInfoTag* GetGameInfoTag() const
+  {
+    return m_gameInfoTag;
+  }
+
   CPictureInfoTag* GetPictureInfoTag();
 
   /*!
@@ -422,6 +439,7 @@ public:
   std::string FindTrailer() const;
 
   virtual bool LoadMusicTag();
+  virtual bool LoadGameTag();
 
   /* Returns the content type of this item if known */
   const std::string& GetMimeType() const { return m_mimetype; }
@@ -437,18 +455,12 @@ public:
   void FillInMimeType(bool lookup = true);
 
   /*!
-  \brief Some sources do not support HTTP HEAD request to determine i.e. mime type
-  \return false if HEAD requests have to be avoided
-  */
-  bool ContentLookup() { return m_doContentLookup; };
-
-  /*!
-   \brief (Re)set the mime-type for internet files if allowed (m_doContentLookup)
-   Some sources do not support HTTP HEAD request to determine i.e. mime type
+   \brief Some sources do not support HTTP HEAD request to determine i.e. mime type
+   \return false if HEAD requests have to be avoided
    */
-  void SetMimeTypeForInternetFile();
+  bool ContentLookup() { return m_doContentLookup; };
 
-  /*!
+  /*! 
    *\brief Lookup via HTTP HEAD request might not be needed, use this setter to
    * disable ContentLookup.
    */
@@ -542,6 +554,7 @@ private:
   PVR::CPVRRadioRDSInfoTagPtr m_pvrRadioRDSInfoTag;
   CPictureInfoTag* m_pictureInfoTag;
   std::shared_ptr<const ADDON::IAddon> m_addonInfo;
+  GAME::CGameInfoTag* m_gameInfoTag;
   bool m_bIsAlbum;
 
   CCueDocumentPtr m_cueDocument;
@@ -656,7 +669,7 @@ public:
    The file list may be cached based on which window we're viewing in, as different
    windows will be listing different portions of the same URL (eg viewing music files
    versus viewing video files)
-
+   
    \param windowID id of the window that's loading this list (defaults to 0)
    \return true if we loaded from the cache, false otherwise.
    \sa Save,RemoveDiscCache
@@ -664,11 +677,11 @@ public:
   bool Load(int windowID = 0);
 
   /*! \brief save a CFileItemList to the cache
-
+   
    The file list may be cached based on which window we're viewing in, as different
    windows will be listing different portions of the same URL (eg viewing music files
    versus viewing video files)
-
+   
    \param windowID id of the window that's saving this list (defaults to 0)
    \return true if successful, false otherwise.
    \sa Load,RemoveDiscCache
@@ -678,11 +691,11 @@ public:
   bool CacheToDiscAlways() const { return m_cacheToDisc == CACHE_ALWAYS; }
   bool CacheToDiscIfSlow() const { return m_cacheToDisc == CACHE_IF_SLOW; }
   /*! \brief remove a previously cached CFileItemList from the cache
-
+   
    The file list may be cached based on which window we're viewing in, as different
    windows will be listing different portions of the same URL (eg viewing music files
    versus viewing video files)
-
+   
    \param windowID id of the window whose cache we which to remove (defaults to 0)
    \sa Save,Load
    */
diff --git a/xbmc/GUIInfoManager.cpp b/xbmc/GUIInfoManager.cpp
index 1a3e648..6c8e11b 100644
--- a/xbmc/GUIInfoManager.cpp
+++ b/xbmc/GUIInfoManager.cpp
@@ -104,10 +104,6 @@
 static CLinuxResourceCounter m_resourceCounter;
 #endif
 
-#ifdef TARGET_POSIX
-#include "linux/XMemUtils.h"
-#endif
-
 #define SYSHEATUPDATEINTERVAL 60000
 
 using namespace XFILE;
@@ -2205,7 +2201,6 @@ const infomap mediacontainer[] = {{ "hasfiles",         CONTAINER_HASFILES },
                                   { "folderpath",       CONTAINER_FOLDERPATH },
                                   { "foldername",       CONTAINER_FOLDERNAME },
                                   { "pluginname",       CONTAINER_PLUGINNAME },
-                                  { "plugincategory",   CONTAINER_PLUGINCATEGORY },
                                   { "viewmode",         CONTAINER_VIEWMODE },
                                   { "viewcount",        CONTAINER_VIEWCOUNT },
                                   { "totaltime",        CONTAINER_TOTALTIME },
@@ -3736,7 +3731,6 @@ const infomap listitem_labels[]= {{ "thumb",            LISTITEM_THUMB },
                                   { "castandrole",      LISTITEM_CAST_AND_ROLE },
                                   { "writer",           LISTITEM_WRITER },
                                   { "tagline",          LISTITEM_TAGLINE },
-                                  { "status",           LISTITEM_STATUS },
                                   { "top250",           LISTITEM_TOP250 },
                                   { "trailer",          LISTITEM_TRAILER },
                                   { "sortletter",       LISTITEM_SORT_LETTER },
@@ -5720,7 +5714,7 @@ std::string CGUIInfoManager::GetLabel(int info, int contextWindow, std::string *
   case ADSP_MASTER_INFO:
   case ADSP_MASTER_OWN_ICON:
   case ADSP_MASTER_OVERRIDE_ICON:
-    CServiceBroker::GetADSP().TranslateCharInfo(info, strLabel);
+    ActiveAE::CActiveAEDSP::GetInstance().TranslateCharInfo(info, strLabel);
     break;
   case WEATHER_CONDITIONS:
     strLabel = g_weatherManager.GetInfo(WEATHER_LABEL_CURRENT_COND);
@@ -6140,7 +6134,6 @@ std::string CGUIInfoManager::GetLabel(int info, int contextWindow, std::string *
     break;
   case CONTAINER_SHOWPLOT:
   case CONTAINER_SHOWTITLE:
-  case CONTAINER_PLUGINCATEGORY:
     {
       CGUIWindow *window = GetWindowWithCondition(contextWindow, WINDOW_CONDITION_IS_MEDIA_WINDOW);
       if (window)
@@ -6149,8 +6142,6 @@ std::string CGUIInfoManager::GetLabel(int info, int contextWindow, std::string *
           return ((CGUIMediaWindow *)window)->CurrentDirectory().GetProperty("showplot").asString();
         else if (info == CONTAINER_SHOWTITLE)
           return ((CGUIMediaWindow *)window)->CurrentDirectory().GetProperty("showtitle").asString();
-        else if (info == CONTAINER_PLUGINCATEGORY)
-          return ((CGUIMediaWindow *)window)->CurrentDirectory().GetProperty("plugincategory").asString();
       }
     }
     break;
@@ -6736,7 +6727,7 @@ bool CGUIInfoManager::GetBool(int condition1, int contextWindow, const CGUIListI
   else if (condition >= PVR_CONDITIONS_START && condition <= PVR_CONDITIONS_END)
     bReturn = g_PVRManager.TranslateBoolInfo(condition);
   else if (condition >= ADSP_CONDITIONS_START && condition <= ADSP_CONDITIONS_END)
-    bReturn = CServiceBroker::GetADSP().TranslateBoolInfo(condition);
+    bReturn = ActiveAE::CActiveAEDSP::GetInstance().TranslateBoolInfo(condition);
   else if (condition == SYSTEM_INTERNET_STATE)
   {
     g_sysinfo.GetInfo(condition);
@@ -7453,6 +7444,8 @@ bool CGUIInfoManager::GetMultiInfoBool(const GUIInfo &info, int contextWindow, c
             strContent = "episodes";
           if (m_currentFile->HasVideoInfoTag() && m_currentFile->GetVideoInfoTag()->m_type == MediaTypeMusicVideo)
             strContent = "musicvideos";
+          if (m_currentFile->HasVideoInfoTag() && m_currentFile->GetVideoInfoTag()->m_strStatus == "livetv")
+            strContent = "livetv";
           if (m_currentFile->HasPVRChannelInfoTag())
             strContent = "livetv";
           bReturn = StringUtils::EqualsNoCase(m_stringParameters[info.GetData1()], strContent);
@@ -9793,10 +9786,6 @@ std::string CGUIInfoManager::GetItemLabel(const CFileItem *item, int info, std::
     if (item->HasVideoInfoTag())
       return item->GetVideoInfoTag()->m_strTagLine;
     break;
-  case LISTITEM_STATUS:
-    if (item->HasVideoInfoTag())
-      return item->GetVideoInfoTag()->m_strStatus;
-    break;
   case LISTITEM_TRAILER:
     if (item->HasVideoInfoTag())
       return item->GetVideoInfoTag()->m_strTrailer;
diff --git a/xbmc/GUIPassword.cpp b/xbmc/GUIPassword.cpp
index bec47d7..ee2bd06 100644
--- a/xbmc/GUIPassword.cpp
+++ b/xbmc/GUIPassword.cpp
@@ -412,6 +412,9 @@ bool CGUIPassword::CheckMenuLock(int iWindowID)
     case WINDOW_PICTURES:       // Pictures
       bCheckPW = CProfilesManager::GetInstance().GetCurrentProfile().picturesLocked();
       break;
+    case WINDOW_GAMES:          // Games
+      bCheckPW = CProfilesManager::GetInstance().GetCurrentProfile().gamesLocked();
+      break;
     case WINDOW_SETTINGS_PROFILES:
       bCheckPW = true;
       break;
@@ -450,8 +453,8 @@ bool CGUIPassword::LockSource(const std::string& strType, const std::string& str
 void CGUIPassword::LockSources(bool lock)
 {
   // lock or unlock all sources (those with locks)
-  const char* strType[5] = {"programs","music","video","pictures","files"};
-  for (int i=0;i<5;++i)
+  const char* strType[] = {"programs", "music", "video", "pictures", "files", "games"};
+  for (unsigned int i = 0; i < sizeof(strType) / sizeof(*strType); ++i)
   {
     VECSOURCES *shares = CMediaSourceSettings::GetInstance().GetSources(strType[i]);
     for (IVECSOURCES it=shares->begin();it != shares->end();++it)
@@ -465,8 +468,8 @@ void CGUIPassword::LockSources(bool lock)
 void CGUIPassword::RemoveSourceLocks()
 {
   // remove lock from all sources
-  const char* strType[5] = {"programs","music","video","pictures","files"};
-  for (int i=0;i<5;++i)
+  const char* strType[] = {"programs", "music", "video", "pictures", "files", "games"};
+  for (unsigned int i = 0; i < sizeof(strType) / sizeof(*strType); ++i)
   {
     VECSOURCES *shares = CMediaSourceSettings::GetInstance().GetSources(strType[i]);
     for (IVECSOURCES it=shares->begin();it != shares->end();++it)
diff --git a/xbmc/NfoFile.cpp b/xbmc/NfoFile.cpp
index 02228e1..ebbb9cc 100644
--- a/xbmc/NfoFile.cpp
+++ b/xbmc/NfoFile.cpp
@@ -38,7 +38,7 @@ CNfoFile::NFOResult CNfoFile::Create(const std::string& strPath, const ScraperPt
 {
   m_info = info; // assume we can use these settings
   m_type = ScraperTypeFromContent(info->Content());
-  if (Load(strPath) != 0)
+  if (FAILED(Load(strPath)))
     return NO_NFO;
 
   CFileItemList items;
diff --git a/xbmc/ServiceBroker.cpp b/xbmc/ServiceBroker.cpp
index fff03c3..21963be 100644
--- a/xbmc/ServiceBroker.cpp
+++ b/xbmc/ServiceBroker.cpp
@@ -45,8 +45,3 @@ PVR::CPVRManager &CServiceBroker::GetPVRManager()
 {
   return g_application.m_ServiceManager->GetPVRManager();
 }
-
-ActiveAE::CActiveAEDSP &CServiceBroker::GetADSP()
-{
-  return g_application.m_ServiceManager->GetADSPManager();
-}
diff --git a/xbmc/ServiceBroker.h b/xbmc/ServiceBroker.h
index 32add30..653e0ff 100644
--- a/xbmc/ServiceBroker.h
+++ b/xbmc/ServiceBroker.h
@@ -25,10 +25,6 @@ class CAddonMgr;
 class CBinaryAddonCache;
 }
 
-namespace ActiveAE {
-class CActiveAEDSP;
-}
-
 namespace ANNOUNCEMENT
 {
   class CAnnouncementManager;
@@ -49,5 +45,4 @@ public:
   static ANNOUNCEMENT::CAnnouncementManager &GetAnnouncementManager();
   static XBPython &GetXBPython();
   static PVR::CPVRManager &GetPVRManager();
-  static ActiveAE::CActiveAEDSP& GetADSP();
 };
diff --git a/xbmc/ServiceManager.cpp b/xbmc/ServiceManager.cpp
index be05791..7b36413 100644
--- a/xbmc/ServiceManager.cpp
+++ b/xbmc/ServiceManager.cpp
@@ -19,7 +19,6 @@
  */
 
 #include "ServiceManager.h"
-#include "cores/AudioEngine/DSPAddons/ActiveAEDSP.h"
 #include "utils/log.h"
 #include "interfaces/AnnouncementManager.h"
 #include "interfaces/generic/ScriptInvocationManager.h"
@@ -43,8 +42,7 @@ bool CServiceManager::Init2()
     CLog::Log(LOGFATAL, "CServiceManager::Init: Unable to start CAddonMgr");
     return false;
   }
-
-  m_ADSPManager.reset(new ActiveAE::CActiveAEDSP());
+  
   m_PVRManager.reset(new PVR::CPVRManager());
 
   m_binaryAddonCache.reset( new ADDON::CBinaryAddonCache());
@@ -55,7 +53,6 @@ bool CServiceManager::Init2()
 
 bool CServiceManager::Init3()
 {
-  m_ADSPManager->Init();
   m_PVRManager->Init();
 
   return true;
@@ -65,7 +62,6 @@ void CServiceManager::Deinit()
 {
   m_binaryAddonCache.reset();
   m_PVRManager.reset();
-  m_ADSPManager.reset();
   m_addonMgr.reset();
   CScriptInvocationManager::GetInstance().UnregisterLanguageInvocationHandler(m_XBPython.get());
   m_XBPython.reset();
@@ -96,8 +92,3 @@ PVR::CPVRManager& CServiceManager::GetPVRManager()
 {
   return *m_PVRManager;
 }
-
-ActiveAE::CActiveAEDSP& CServiceManager::GetADSPManager()
-{
-  return *m_ADSPManager;
-}
diff --git a/xbmc/ServiceManager.h b/xbmc/ServiceManager.h
index cdb8399..3f68dfc 100644
--- a/xbmc/ServiceManager.h
+++ b/xbmc/ServiceManager.h
@@ -31,10 +31,6 @@ class CAddonMgr;
 class CBinaryAddonCache;
 }
 
-namespace ActiveAE {
-class CActiveAEDSP;
-}
-
 namespace ANNOUNCEMENT
 {
 class CAnnouncementManager;
@@ -57,7 +53,6 @@ public:
   ANNOUNCEMENT::CAnnouncementManager& GetAnnouncementManager();
   XBPython& GetXBPython();
   PVR::CPVRManager& GetPVRManager();
-  ActiveAE::CActiveAEDSP& GetADSPManager();
 
 protected:
   std::unique_ptr<ADDON::CAddonMgr> m_addonMgr;
@@ -65,5 +60,4 @@ protected:
   std::unique_ptr<ANNOUNCEMENT::CAnnouncementManager> m_announcementManager;
   std::unique_ptr<XBPython> m_XBPython;
   std::unique_ptr<PVR::CPVRManager> m_PVRManager;
-  std::unique_ptr<ActiveAE::CActiveAEDSP> m_ADSPManager;
 };
diff --git a/xbmc/XBApplicationEx.cpp b/xbmc/XBApplicationEx.cpp
index f6fffd8..048a6c1 100644
--- a/xbmc/XBApplicationEx.cpp
+++ b/xbmc/XBApplicationEx.cpp
@@ -28,9 +28,6 @@
 #define MEASURE_FUNCTION
 #endif
 #include "commons/Exception.h"
-#ifdef TARGET_POSIX
-#include "linux/XTimeUtils.h"
-#endif
 
 // Put this here for easy enable and disable
 #ifndef _DEBUG
diff --git a/xbmc/addons/Addon.cpp b/xbmc/addons/Addon.cpp
index 889935c..e491d13 100644
--- a/xbmc/addons/Addon.cpp
+++ b/xbmc/addons/Addon.cpp
@@ -30,6 +30,7 @@
 #include "ContextMenuManager.h"
 #include "filesystem/Directory.h"
 #include "filesystem/File.h"
+#include "filesystem/SpecialProtocol.h"
 #include "RepositoryUpdater.h"
 #include "settings/Settings.h"
 #include "system.h"
@@ -92,11 +93,13 @@ static const TypeMapping types[] =
    {"xbmc.webinterface",                 ADDON_WEB_INTERFACE,         199, "DefaultAddonWebSkin.png" },
    {"xbmc.addon.repository",             ADDON_REPOSITORY,          24011, "DefaultAddonRepository.png" },
    {"xbmc.pvrclient",                    ADDON_PVRDLL,              24019, "DefaultAddonPVRClient.png" },
+   {"kodi.gameclient",                   ADDON_GAMEDLL,             35049, "DefaultAddonGame.png" },
    {"kodi.peripheral",                   ADDON_PERIPHERALDLL,       35010, "DefaultAddonPeripheral.png" },
    {"xbmc.addon.video",                  ADDON_VIDEO,                1037, "DefaultAddonVideo.png" },
    {"xbmc.addon.audio",                  ADDON_AUDIO,                1038, "DefaultAddonMusic.png" },
    {"xbmc.addon.image",                  ADDON_IMAGE,                1039, "DefaultAddonPicture.png" },
    {"xbmc.addon.executable",             ADDON_EXECUTABLE,           1043, "DefaultAddonProgram.png" },
+   {"kodi.addon.game",                   ADDON_GAME,                35049, "DefaultAddonGame.png" },
    {"xbmc.audioencoder",                 ADDON_AUDIOENCODER,         200,  "DefaultAddonAudioEncoder.png" },
    {"kodi.audiodecoder",                 ADDON_AUDIODECODER,         201,  "DefaultAddonAudioDecoder.png" },
    {"xbmc.service",                      ADDON_SERVICE,             24018, "DefaultAddonService.png" },
@@ -327,7 +330,19 @@ const std::string CAddon::LibPath() const
 {
   if (m_props.libname.empty())
     return "";
-  return URIUtils::AddFileToFolder(m_props.path, m_props.libname);
+
+  std::string strLibPath = URIUtils::AddFileToFolder(m_props.path, m_props.libname);
+
+  // Check if add-on library has been installed to the binaries path instead
+  std::string strSharePath = CSpecialProtocol::TranslatePath("special://xbmc/");
+  const bool bIsInSharePath = StringUtils::StartsWith(strLibPath, strSharePath);
+  if (bIsInSharePath && !CFile::Exists(strLibPath))
+  {
+    std::string strBinPath = CSpecialProtocol::TranslatePath("special://xbmcbin/");
+    strLibPath.replace(0, strSharePath.length(), strBinPath);
+  }
+
+  return strLibPath;
 }
 
 AddonVersion CAddon::GetDependencyVersion(const std::string &dependencyID) const
diff --git a/xbmc/addons/AddonDatabase.cpp b/xbmc/addons/AddonDatabase.cpp
index d5eac2b..21eccf6 100644
--- a/xbmc/addons/AddonDatabase.cpp
+++ b/xbmc/addons/AddonDatabase.cpp
@@ -49,16 +49,6 @@ bool CAddonDatabase::Open()
   return CDatabase::Open();
 }
 
-int CAddonDatabase::GetMinSchemaVersion() const
-{
-  return 15;
-}
-
-int CAddonDatabase::GetSchemaVersion() const
-{
-  return 23;
-}
-
 void CAddonDatabase::CreateTables()
 {
   CLog::Log(LOGINFO, "create addon table");
@@ -195,14 +185,6 @@ void CAddonDatabase::UpdateTables(int version)
   {
     m_pDS->exec("DROP TABLE system");
   }
-  if (version < 23)
-  {
-    m_pDS->exec("DELETE FROM addon");
-    m_pDS->exec("DELETE FROM addonextra");
-    m_pDS->exec("DELETE FROM dependencies");
-    m_pDS->exec("DELETE FROM addonlinkrepo");
-    m_pDS->exec("DELETE FROM repo");
-  }
 }
 
 void CAddonDatabase::SyncInstalled(const std::set<std::string>& ids, const std::set<std::string>& enabled)
@@ -236,14 +218,11 @@ void CAddonDatabase::SyncInstalled(const std::set<std::string>& ids, const std::
     BeginTransaction();
     for (const auto& id : added)
       m_pDS->exec(PrepareSQL("INSERT INTO installed(addonID, enabled, installDate) "
-          "VALUES('%s', 0, '%s')", id.c_str(), now.c_str()));
+          "VALUES('%s', '%d', '%s')", id.c_str(), enabled.find(id) != enabled.end() ? 1 : 0, now.c_str()));
 
     for (const auto& id : removed)
       m_pDS->exec(PrepareSQL("DELETE FROM installed WHERE addonID='%s'", id.c_str()));
 
-    for (const auto& id : enabled)
-      m_pDS->exec(PrepareSQL("UPDATE installed SET enabled=1 WHERE addonID='%s'", id.c_str()));
-
     CommitTransaction();
   }
   catch (...)
@@ -317,7 +296,14 @@ bool CAddonDatabase::SetLastUsed(const std::string& addonId, const CDateTime& da
   return false;
 }
 
-int CAddonDatabase::AddAddon(const AddonPtr& addon, int idRepo)
+int CAddonDatabase::GetAddonId(const ADDON::AddonPtr& item)
+{
+  std::string value = GetSingleValue("addon", "id", StringUtils::Format("name = '%s'", item->Name().c_str()), "id desc");
+  return value.empty() || !StringUtils::IsInteger(value) ? -1 : atoi(value.c_str());
+}
+
+int CAddonDatabase::AddAddon(const AddonPtr& addon,
+                             int idRepo)
 {
   try
   {
diff --git a/xbmc/addons/AddonDatabase.h b/xbmc/addons/AddonDatabase.h
index da8e177..4820c0d 100644
--- a/xbmc/addons/AddonDatabase.h
+++ b/xbmc/addons/AddonDatabase.h
@@ -34,6 +34,8 @@ public:
   virtual ~CAddonDatabase();
   virtual bool Open();
 
+  int GetAddonId(const ADDON::AddonPtr& item);
+  int AddAddon(const ADDON::AddonPtr& item, int idRepo);
   bool GetAddon(const std::string& addonID, ADDON::AddonPtr& addon);
 
   /*! \brief Get an addon with a specific version and repository. */
@@ -142,12 +144,11 @@ protected:
   virtual void CreateTables();
   virtual void CreateAnalytics();
   virtual void UpdateTables(int version);
-  virtual int GetMinSchemaVersion() const;
-  virtual int GetSchemaVersion() const;
+  virtual int GetMinSchemaVersion() const { return 15; }
+  virtual int GetSchemaVersion() const { return 22; }
   const char *GetBaseDBName() const { return "Addons"; }
 
   bool GetAddon(int id, ADDON::AddonPtr& addon);
-  int AddAddon(const ADDON::AddonPtr& item, int idRepo);
 
   /* keep in sync with the addon table */
   enum AddonFields
diff --git a/xbmc/addons/AddonInstaller.cpp b/xbmc/addons/AddonInstaller.cpp
index b0a57b6..ad7d631 100644
--- a/xbmc/addons/AddonInstaller.cpp
+++ b/xbmc/addons/AddonInstaller.cpp
@@ -43,9 +43,6 @@
 #include "dialogs/GUIDialogOK.h"
 #include "dialogs/GUIDialogExtendedProgressBar.h"
 #include "URL.h"
-#ifdef TARGET_POSIX
-#include "linux/XTimeUtils.h"
-#endif
 
 #include <functional>
 
diff --git a/xbmc/addons/AddonManager.cpp b/xbmc/addons/AddonManager.cpp
index c4b2db7..ff1f8ea 100644
--- a/xbmc/addons/AddonManager.cpp
+++ b/xbmc/addons/AddonManager.cpp
@@ -751,23 +751,6 @@ bool CAddonMgr::IsBlacklisted(const std::string& id) const
   return m_updateBlacklist.find(id) != m_updateBlacklist.end();
 }
 
-static void ResolveDependencies(const std::string& addonId, std::vector<std::string>& needed, std::vector<std::string>& missing)
-{
-  if (std::find(needed.begin(), needed.end(), addonId) != needed.end())
-    return;
-
-  AddonPtr addon;
-  if (!CAddonMgr::GetInstance().GetAddon(addonId, addon, ADDON_UNKNOWN, false))
-    missing.push_back(addonId);
-  else
-  {
-    needed.push_back(addonId);
-    for (const auto& dep : addon->GetDeps())
-      if (!dep.second.second) // ignore 'optional'
-        ResolveDependencies(dep.first, needed, missing);
-  }
-}
-
 bool CAddonMgr::DisableAddon(const std::string& id)
 {
   CSingleLock lock(m_critSection);
@@ -789,34 +772,23 @@ bool CAddonMgr::DisableAddon(const std::string& id)
   return true;
 }
 
-bool CAddonMgr::EnableSingle(const std::string& id)
+bool CAddonMgr::EnableAddon(const std::string& id)
 {
   CSingleLock lock(m_critSection);
   if (m_disabled.find(id) == m_disabled.end())
     return true; //already enabled
+
   if (!m_database.DisableAddon(id, false))
     return false;
-  m_disabled.erase(id);
-  ADDON::OnEnabled(id);
+  if (m_disabled.erase(id) == 0)
+    return false;
 
   AddonPtr addon;
   if (GetAddon(id, addon, ADDON_UNKNOWN, false) && addon != NULL)
     CEventLog::GetInstance().Add(EventPtr(new CAddonManagementEvent(addon, 24064)));
 
-  CLog::Log(LOGDEBUG, "CAddonMgr: enabled %s", addon->ID().c_str());
-  return true;
-}
-
-bool CAddonMgr::EnableAddon(const std::string& id)
-{
-  std::vector<std::string> needed;
-  std::vector<std::string> missing;
-  ResolveDependencies(id, needed, missing);
-  for (const auto& dep : missing)
-    CLog::Log(LOGWARNING, "CAddonMgr: '%s' required by '%s' is missing. Add-on may not function "
-        "correctly", dep.c_str(), id.c_str());
-  for (auto it = needed.rbegin(); it != needed.rend(); ++it)
-    EnableSingle(*it);
+  //success
+  ADDON::OnEnabled(id);
   return true;
 }
 
@@ -872,7 +844,7 @@ bool CAddonMgr::CanAddonBeInstalled(const AddonPtr& addon)
 
 bool CAddonMgr::CanUninstall(const AddonPtr& addon)
 {
-  return addon && CanAddonBeDisabled(addon->ID()) &&
+  return addon && !IsSystemAddon(addon->ID()) &&
       !StringUtils::StartsWith(addon->Path(), CSpecialProtocol::TranslatePath("special://xbmc/addons"));
 }
 
diff --git a/xbmc/addons/AddonManager.h b/xbmc/addons/AddonManager.h
index d41cb68..7390c1d 100644
--- a/xbmc/addons/AddonManager.h
+++ b/xbmc/addons/AddonManager.h
@@ -264,7 +264,6 @@ namespace ADDON
     static bool PlatformSupportsAddon(const cp_plugin_info_t *info);
 
     bool GetAddonsInternal(const TYPE &type, VECADDONS &addons, bool enabledOnly);
-    bool EnableSingle(const std::string& id);
 
     std::set<std::string> m_disabled;
     std::set<std::string> m_updateBlacklist;
diff --git a/xbmc/addons/AudioDecoder.cpp b/xbmc/addons/AudioDecoder.cpp
index 2c35b3f..a89c51c 100644
--- a/xbmc/addons/AudioDecoder.cpp
+++ b/xbmc/addons/AudioDecoder.cpp
@@ -80,13 +80,12 @@ int CAudioDecoder::ReadPCM(uint8_t* buffer, int size, int* actualsize)
   return m_pStruct->ReadPCM(m_context, buffer, size, actualsize);
 }
 
-bool CAudioDecoder::Seek(int64_t time)
+int64_t CAudioDecoder::Seek(int64_t time)
 {
   if (!Initialized())
-    return false;
+    return 0;
 
-  m_pStruct->Seek(m_context, time);
-  return true;
+  return m_pStruct->Seek(m_context, time);
 }
 
 void CAudioDecoder::DeInit()
diff --git a/xbmc/addons/AudioDecoder.h b/xbmc/addons/AudioDecoder.h
index 30f1361..e3525a4 100644
--- a/xbmc/addons/AudioDecoder.h
+++ b/xbmc/addons/AudioDecoder.h
@@ -61,7 +61,7 @@ namespace ADDON
     // Things that MUST be supplied by the child classes
     bool Init(const std::string& strFile, unsigned int filecache);
     int ReadPCM(uint8_t* buffer, int size, int* actualsize);
-    bool Seek(int64_t time);
+    int64_t Seek(int64_t time);
     bool CanInit() { return true; }
     void DeInit();
     void Destroy();
diff --git a/xbmc/addons/DllGameClient.h b/xbmc/addons/DllGameClient.h
new file mode 100644
index 0000000..a34a1e1
--- /dev/null
+++ b/xbmc/addons/DllGameClient.h
@@ -0,0 +1,29 @@
+/*
+ *      Copyright (C) 2012-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+#include "DllAddon.h"
+#include "addons/kodi-addon-dev-kit/include/kodi/kodi_game_types.h"
+
+class DllGameClient : public DllAddon<GameClient, game_client_properties>
+{
+  // this is populated via macro calls in DllAddon.h
+};
+
diff --git a/xbmc/addons/GUIDialogAddonInfo.cpp b/xbmc/addons/GUIDialogAddonInfo.cpp
index cc80632..c650e51 100644
--- a/xbmc/addons/GUIDialogAddonInfo.cpp
+++ b/xbmc/addons/GUIDialogAddonInfo.cpp
@@ -26,6 +26,7 @@
 #include "AddonDatabase.h"
 #include "FileItem.h"
 #include "filesystem/Directory.h"
+#include "games/GameManager.h"
 #include "GUIDialogAddonSettings.h"
 #include "cores/AudioEngine/DSPAddons/ActiveAEDSP.h"
 #include "dialogs/GUIDialogContextMenu.h"
@@ -96,7 +97,7 @@ bool CGUIDialogAddonInfo::OnMessage(CGUIMessage& message)
       {
         if (m_localAddon)
         {
-          if (m_localAddon->Type() == ADDON_ADSPDLL && CServiceBroker::GetADSP().IsProcessing())
+          if (m_localAddon->Type() == ADDON_ADSPDLL && ActiveAE::CActiveAEDSP::GetInstance().IsProcessing())
           {
             CGUIDialogOK::ShowAndGetInput(24137, 0, 24138, 0);
             return true;
@@ -124,7 +125,7 @@ bool CGUIDialogAddonInfo::OnMessage(CGUIMessage& message)
         //FIXME: should be moved to somewhere appropriate (e.g CAddonMgs::CanAddonBeDisabled or IsInUse) and button should be disabled
         if (m_localAddon)
         {
-          if (m_localAddon->Type() == ADDON_ADSPDLL && CServiceBroker::GetADSP().IsProcessing())
+          if (m_localAddon->Type() == ADDON_ADSPDLL && ActiveAE::CActiveAEDSP::GetInstance().IsProcessing())
           {
             CGUIDialogOK::ShowAndGetInput(24137, 0, 24138, 0);
             return true;
@@ -190,16 +191,8 @@ void CGUIDialogAddonInfo::UpdateControls()
   CONTROL_ENABLE_ON_CONDITION(CONTROL_BTN_INSTALL, canInstall || canUninstall);
   SET_CONTROL_LABEL(CONTROL_BTN_INSTALL, isInstalled ? 24037 : 24038);
 
-  if (m_addonEnabled)
-  {
-    SET_CONTROL_LABEL(CONTROL_BTN_ENABLE, 24021);
-    CONTROL_ENABLE_ON_CONDITION(CONTROL_BTN_ENABLE, canDisable);
-  }
-  else
-  {
-    SET_CONTROL_LABEL(CONTROL_BTN_ENABLE, 24022);
-    CONTROL_ENABLE_ON_CONDITION(CONTROL_BTN_ENABLE, isInstalled);
-  }
+  CONTROL_ENABLE_ON_CONDITION(CONTROL_BTN_ENABLE, canDisable);
+  SET_CONTROL_LABEL(CONTROL_BTN_ENABLE, m_addonEnabled ? 24021 : 24022);
 
   CONTROL_ENABLE_ON_CONDITION(CONTROL_BTN_UPDATE, isInstalled);
 
@@ -415,6 +408,8 @@ void CGUIDialogAddonInfo::OnUninstall()
   if (!CGUIDialogYesNo::ShowAndGetInput(CVariant{24037}, CVariant{750}))
     return;
 
+  GAME::CGameManager::GetInstance().ClearAutoLaunch(); // Enabling before uninstalling might launch a queued game
+
   CJobManager::GetInstance().AddJob(new CAddonUnInstallJob(m_localAddon),
                                     &CAddonInstaller::GetInstance());
   Close();
diff --git a/xbmc/addons/GUIViewStateAddonBrowser.cpp b/xbmc/addons/GUIViewStateAddonBrowser.cpp
index a6ff7d8..3562140 100644
--- a/xbmc/addons/GUIViewStateAddonBrowser.cpp
+++ b/xbmc/addons/GUIViewStateAddonBrowser.cpp
@@ -38,11 +38,6 @@ CGUIViewStateAddonBrowser::CGUIViewStateAddonBrowser(const CFileItemList& items)
     AddSortMethod(SortByNone, 551, LABEL_MASKS("%F", "", "%L", ""));
     SetSortMethod(SortByNone);
   }
-  else if (URIUtils::PathEquals(items.GetPath(), "addons://recently_updated/", true))
-  {
-    AddSortMethod(SortByLastUpdated, 12014, LABEL_MASKS("%L", "%v", "%L", "%v"),
-        SortAttributeIgnoreFolders, SortOrderDescending);
-  }
   else
   {
     AddSortMethod(SortByLabel, SortAttributeIgnoreFolders, 551, LABEL_MASKS("%L", "%s", "%L", "%s"));
diff --git a/xbmc/addons/GUIWindowAddonBrowser.cpp b/xbmc/addons/GUIWindowAddonBrowser.cpp
index dfbef9e..ac7941a 100644
--- a/xbmc/addons/GUIWindowAddonBrowser.cpp
+++ b/xbmc/addons/GUIWindowAddonBrowser.cpp
@@ -28,6 +28,7 @@
 #include "dialogs/GUIDialogYesNo.h"
 #include "dialogs/GUIDialogSelect.h"
 #include "dialogs/GUIDialogFileBrowser.h"
+#include "games/GameManager.h"
 #include "GUIUserMessages.h"
 #include "guilib/GUIWindowManager.h"
 #include "utils/URIUtils.h"
@@ -379,6 +380,11 @@ int CGUIWindowAddonBrowser::SelectAddonID(const std::vector<ADDON::TYPE> &types,
         CAddonsDirectory::GetScriptsAndPlugins("image", typeAddons);
       else if (*type == ADDON_VIDEO)
         CAddonsDirectory::GetScriptsAndPlugins("video", typeAddons);
+      else if (*type == ADDON_GAME)
+      {
+        CAddonsDirectory::GetScriptsAndPlugins("game", typeAddons);
+        //GAME::CGameManager::GetInstance().GetStandaloneGames(typeAddons); // TODO
+      }
       else
         CAddonMgr::GetInstance().GetAddons(typeAddons, *type);
 
diff --git a/xbmc/addons/IAddon.h b/xbmc/addons/IAddon.h
index f91e80e..d4768ec 100644
--- a/xbmc/addons/IAddon.h
+++ b/xbmc/addons/IAddon.h
@@ -40,6 +40,7 @@ namespace ADDON
     ADDON_PVRDLL,
     ADDON_ADSPDLL,
     ADDON_INPUTSTREAM,
+    ADDON_GAMEDLL,
     ADDON_PERIPHERALDLL,
     ADDON_SCRIPT,
     ADDON_SCRIPT_WEATHER,
@@ -65,6 +66,7 @@ namespace ADDON
     ADDON_AUDIO,
     ADDON_IMAGE,
     ADDON_EXECUTABLE,
+    ADDON_GAME,
     ADDON_VIZ_LIBRARY,
     ADDON_SCRAPER_LIBRARY,
     ADDON_SCRIPT_LIBRARY,
diff --git a/xbmc/addons/InputStream.cpp b/xbmc/addons/InputStream.cpp
index 6751211..bde5df5 100644
--- a/xbmc/addons/InputStream.cpp
+++ b/xbmc/addons/InputStream.cpp
@@ -92,7 +92,7 @@ void CInputStream::UpdateConfig()
   m_hasConfig = true;
 }
 
-bool CInputStream::Supports(const CFileItem &fileitem)
+bool CInputStream::Supports(CFileItem &fileitem)
 {
   // check if a specific inputstream addon is requested
   CVariant addon = fileitem.GetProperty("inputstreamaddon");
@@ -548,17 +548,5 @@ bool CInputStream::IsRealTimeStream()
   return ret;
 }
 
-void CInputStream::SetVideoResolution(int width, int height)
-{
-  try
-  {
-    m_pStruct->SetVideoResolution(width, height);
-  }
-  catch (std::exception &e)
-  {
-    CLog::Log(LOGERROR, "CInputStream::SetVideoResolution - error. Reason: %s", e.what());
-  }
-}
-
 } /*namespace ADDON*/
 
diff --git a/xbmc/addons/InputStream.h b/xbmc/addons/InputStream.h
index b72e017..9e0a30a 100644
--- a/xbmc/addons/InputStream.h
+++ b/xbmc/addons/InputStream.h
@@ -47,7 +47,7 @@ namespace ADDON
 
     virtual void SaveSettings() override;
 
-    bool Supports(const CFileItem &fileitem);
+    bool Supports(CFileItem &fileitem);
     bool Open(CFileItem &fileitem);
     void Close();
 
@@ -76,7 +76,6 @@ namespace ADDON
     void SetSpeed(int iSpeed);
     void EnableStream(int iStreamId, bool enable);
     void EnableStreamAtPTS(int iStreamId, uint64_t pts);
-    void SetVideoResolution(int width, int height);
 
     // stream
     int ReadStream(uint8_t* buf, unsigned int size);
diff --git a/xbmc/addons/PVRClient.cpp b/xbmc/addons/PVRClient.cpp
index 23a1399..c9c5b3c 100644
--- a/xbmc/addons/PVRClient.cpp
+++ b/xbmc/addons/PVRClient.cpp
@@ -144,8 +144,6 @@ void CPVRClient::ResetProperties(int iClientId /* = PVR_INVALID_CLIENT_ID */)
   m_timertypes.clear();
   m_bReadyToUse           = false;
   m_connectionState       = PVR_CONNECTION_STATE_UNKNOWN;
-  m_prevConnectionState   = PVR_CONNECTION_STATE_UNKNOWN;
-  m_ignoreClient          = false;
   m_iClientId             = iClientId;
   m_strBackendVersion     = DEFAULT_INFO_STRING_VALUE;
   m_strConnectionString   = DEFAULT_INFO_STRING_VALUE;
@@ -229,27 +227,7 @@ PVR_CONNECTION_STATE CPVRClient::GetConnectionState(void) const
 void CPVRClient::SetConnectionState(PVR_CONNECTION_STATE state)
 {
   CSingleLock lock(m_critSection);
-
-  m_prevConnectionState = m_connectionState;
   m_connectionState = state;
-
-  if (m_connectionState == PVR_CONNECTION_STATE_CONNECTED)
-    m_ignoreClient = false;
-  else if (m_connectionState == PVR_CONNECTION_STATE_CONNECTING &&
-           m_prevConnectionState == PVR_CONNECTION_STATE_UNKNOWN)
-    m_ignoreClient = true;
-}
-
-PVR_CONNECTION_STATE CPVRClient::GetPreviousConnectionState(void) const
-{
-  CSingleLock lock(m_critSection);
-  return m_prevConnectionState;
-}
-
-bool CPVRClient::IgnoreClient(void) const
-{
-  CSingleLock lock(m_critSection);
-  return m_ignoreClient;
 }
 
 int CPVRClient::GetID(void) const
diff --git a/xbmc/addons/PVRClient.h b/xbmc/addons/PVRClient.h
index 4c3b1a4..565d129 100644
--- a/xbmc/addons/PVRClient.h
+++ b/xbmc/addons/PVRClient.h
@@ -118,18 +118,6 @@ namespace PVR
     void SetConnectionState(PVR_CONNECTION_STATE state);
 
     /*!
-     * @brief Gets the backend's previous connection state.
-     * @return the backend's previous  connection state.
-     */
-    PVR_CONNECTION_STATE GetPreviousConnectionState(void) const;
-
-    /*!
-     * @brief signal to PVRMananager this client should be ignored
-     * @return true if this client should be ignored
-     */
-    bool IgnoreClient(void) const;
-
-    /*!
      * @return The ID of this instance.
      */
     int GetID(void) const;
@@ -702,8 +690,6 @@ namespace PVR
 
     bool                   m_bReadyToUse;          /*!< true if this add-on is initialised (ADDON_Create returned true), false otherwise */
     PVR_CONNECTION_STATE   m_connectionState;      /*!< the backend connection state */
-    PVR_CONNECTION_STATE   m_prevConnectionState;  /*!< the previous backend connection state */
-    bool                   m_ignoreClient;         /*!< signals to PVRManager to ignore this client until it has been connected */
     PVR_MENUHOOKS          m_menuhooks;            /*!< the menu hooks for this add-on */
     CPVRTimerTypes         m_timertypes;           /*!< timer types supported by this backend */
     int                    m_iClientId;            /*!< database ID of the client */
diff --git a/xbmc/addons/PluginSource.cpp b/xbmc/addons/PluginSource.cpp
index 14ca09e..6946d3d 100644
--- a/xbmc/addons/PluginSource.cpp
+++ b/xbmc/addons/PluginSource.cpp
@@ -77,6 +77,8 @@ CPluginSource::Content CPluginSource::Translate(const std::string &content)
     return CPluginSource::EXECUTABLE;
   else if (content == "video")
     return CPluginSource::VIDEO;
+  else if (content == "game")
+    return CPluginSource::GAME;
   else
     return CPluginSource::UNKNOWN;
 }
@@ -100,6 +102,7 @@ bool CPluginSource::IsType(TYPE type) const
   return ((type == ADDON_VIDEO && Provides(VIDEO))
        || (type == ADDON_AUDIO && Provides(AUDIO))
        || (type == ADDON_IMAGE && Provides(IMAGE))
+       || (type == ADDON_GAME && Provides(GAME))
        || (type == ADDON_EXECUTABLE && Provides(EXECUTABLE)));
 }
 
diff --git a/xbmc/addons/PluginSource.h b/xbmc/addons/PluginSource.h
index eafc12b..bd059fd 100644
--- a/xbmc/addons/PluginSource.h
+++ b/xbmc/addons/PluginSource.h
@@ -28,7 +28,7 @@ class CPluginSource : public CAddon
 {
 public:
 
-  enum Content { UNKNOWN, AUDIO, IMAGE, EXECUTABLE, VIDEO };
+  enum Content { UNKNOWN, AUDIO, IMAGE, EXECUTABLE, VIDEO, GAME };
 
   static std::unique_ptr<CPluginSource> FromExtension(AddonProps props, const cp_extension_t* ext);
 
diff --git a/xbmc/addons/addon-bindings.mk b/xbmc/addons/addon-bindings.mk
index 71fe609..ddadcf6 100644
--- a/xbmc/addons/addon-bindings.mk
+++ b/xbmc/addons/addon-bindings.mk
@@ -1,6 +1,7 @@
 BINDINGS =xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_addon_cpp_dll.h
 BINDINGS+=xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_addon_dll.h
 BINDINGS+=xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_addon_types.h
+BINDINGS+=xbmc/addons/kodi-addon-dev-kit/include/kodi/kodi_addon_utils.hpp
 BINDINGS+=xbmc/addons/kodi-addon-dev-kit/include/kodi/kodi_adsp_dll.h
 BINDINGS+=xbmc/addons/kodi-addon-dev-kit/include/kodi/kodi_adsp_types.h
 BINDINGS+=xbmc/addons/kodi-addon-dev-kit/include/kodi/kodi_audiodec_dll.h
@@ -34,4 +35,6 @@ BINDINGS+=xbmc/addons/kodi-addon-dev-kit/include/kodi/libXBMC_pvr.h
 BINDINGS+=xbmc/addons/kodi-addon-dev-kit/include/kodi/libXBMC_codec.h
 BINDINGS+=xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxPacket.h
 BINDINGS+=xbmc/cores/AudioEngine/Utils/AEChannelData.h
+BINDINGS+=xbmc/cores/AudioEngine/Utils/AEChannelInfo.h
+BINDINGS+=xbmc/cores/AudioEngine/Utils/AEStreamData.h
 BINDINGS+=xbmc/filesystem/IFileTypes.h
diff --git a/xbmc/addons/binary/interfaces/AddonInterfaces.cpp b/xbmc/addons/binary/interfaces/AddonInterfaces.cpp
index e317b4f..dba7779 100644
--- a/xbmc/addons/binary/interfaces/AddonInterfaces.cpp
+++ b/xbmc/addons/binary/interfaces/AddonInterfaces.cpp
@@ -27,6 +27,7 @@
 #include "addons/binary/interfaces/api1/AudioDSP/AddonCallbacksAudioDSP.h"
 #include "addons/binary/interfaces/api1/AudioEngine/AddonCallbacksAudioEngine.h"
 #include "addons/binary/interfaces/api1/Codec/AddonCallbacksCodec.h"
+#include "addons/binary/interfaces/api1/Game/AddonCallbacksGame.h"
 #include "addons/binary/interfaces/api1/GUI/AddonCallbacksGUI.h"
 #include "addons/binary/interfaces/api1/GUI/AddonGUIWindow.h"
 #include "addons/binary/interfaces/api1/InputStream/AddonCallbacksInputStream.h"
@@ -51,7 +52,8 @@ CAddonInterfaces::CAddonInterfaces(CAddon* addon)
     m_helperADSP(nullptr),
     m_helperCODEC(nullptr),
     m_helperInputStream(nullptr),
-    m_helperPeripheral(nullptr)
+    m_helperPeripheral(nullptr),
+    m_helperGame(nullptr)
 {
   m_callbacks->libBasePath                  = strdup(CSpecialProtocol::TranslatePath("special://xbmcbin/addons").c_str());
   m_callbacks->addonData                    = this;
@@ -72,6 +74,8 @@ CAddonInterfaces::CAddonInterfaces(CAddon* addon)
   m_callbacks->INPUTSTREAMLib_UnRegisterMe  = CAddonInterfaces::INPUTSTREAMLib_UnRegisterMe;
   m_callbacks->PeripheralLib_RegisterMe     = CAddonInterfaces::PeripheralLib_RegisterMe;
   m_callbacks->PeripheralLib_UnRegisterMe   = CAddonInterfaces::PeripheralLib_UnRegisterMe;
+  m_callbacks->GameLib_RegisterMe           = CAddonInterfaces::GameLib_RegisterMe;
+  m_callbacks->GameLib_UnRegisterMe         = CAddonInterfaces::GameLib_UnRegisterMe;
 }
 
 CAddonInterfaces::~CAddonInterfaces()
@@ -255,6 +259,33 @@ void CAddonInterfaces::CodecLib_UnRegisterMe(void *addonData, void *cbTable)
 }
 /*\_____________________________________________________________________________
 \*/
+CB_GameLib* CAddonInterfaces::GameLib_RegisterMe(void *addonData)
+{
+  CAddonInterfaces* addon = static_cast<CAddonInterfaces*>(addonData);
+  if (addon == nullptr)
+  {
+    CLog::Log(LOGERROR, "CAddonInterfaces - %s - called with a null pointer", __FUNCTION__);
+    return nullptr;
+  }
+
+  addon->m_helperCODEC = new V1::KodiAPI::Game::CAddonCallbacksGame(addon->m_addon);
+  return static_cast<V1::KodiAPI::Game::CAddonCallbacksGame*>(addon->m_helperCODEC)->GetCallbacks();
+}
+
+void CAddonInterfaces::GameLib_UnRegisterMe(void *addonData, CB_GameLib *cbTable)
+{
+  CAddonInterfaces* addon = static_cast<CAddonInterfaces*>(addonData);
+  if (addon == nullptr)
+  {
+    CLog::Log(LOGERROR, "CAddonInterfaces - %s - called with a null pointer", __FUNCTION__);
+    return;
+  }
+
+  delete static_cast<V1::KodiAPI::Game::CAddonCallbacksGame*>(addon->m_helperCODEC);
+  addon->m_helperCODEC = nullptr;
+}
+/*\_____________________________________________________________________________
+\*/
 void* CAddonInterfaces::INPUTSTREAMLib_RegisterMe(void *addonData)
 {
   CAddonInterfaces* addon = static_cast<CAddonInterfaces*>(addonData);
diff --git a/xbmc/addons/binary/interfaces/AddonInterfaces.h b/xbmc/addons/binary/interfaces/AddonInterfaces.h
index 05149bc..3c7c56e 100644
--- a/xbmc/addons/binary/interfaces/AddonInterfaces.h
+++ b/xbmc/addons/binary/interfaces/AddonInterfaces.h
@@ -22,6 +22,7 @@
 
 #include "IAddonInterface.h"
 #include "addons/kodi-addon-dev-kit/include/kodi/kodi_peripheral_callbacks.h"
+#include "addons/kodi-addon-dev-kit/include/kodi/kodi_game_callbacks.h"
 
 #include <stdint.h>
 
@@ -49,6 +50,8 @@ typedef void* (*KODIINPUTSTREAMLib_RegisterMe)(void *addonData);
 typedef void (*KODIINPUTSTREAMLib_UnRegisterMe)(void *addonData, void *cbTable);
 typedef CB_PeripheralLib* (*KODIPeripheralLib_RegisterMe)(void *addonData);
 typedef void (*KODIPeripheralLib_UnRegisterMe)(void *addonData, CB_PeripheralLib *cbTable);
+typedef CB_GameLib* (*KODIGameLib_RegisterMe)(void *addonData);
+typedef void (*KODIGameLib_UnRegisterMe)(void *addonData, CB_GameLib *cbTable);
 
 typedef struct AddonCB
 {
@@ -70,6 +73,8 @@ typedef struct AddonCB
   KODIINPUTSTREAMLib_UnRegisterMe   INPUTSTREAMLib_UnRegisterMe;
   KODIPeripheralLib_RegisterMe      PeripheralLib_RegisterMe;
   KODIPeripheralLib_UnRegisterMe    PeripheralLib_UnRegisterMe;
+  KODIGameLib_RegisterMe            GameLib_RegisterMe;
+  KODIGameLib_UnRegisterMe          GameLib_UnRegisterMe;
 } AddonCB;
 
 
@@ -127,6 +132,11 @@ namespace ADDON
     static CB_PeripheralLib* PeripheralLib_RegisterMe  (void *addonData);
     static void         PeripheralLib_UnRegisterMe     (void *addonData, CB_PeripheralLib* cbTable);
     void*               GetHelperPeripheral()         { return m_helperPeripheral; }
+    /*\_________________________________________________________________________
+    \*/
+    static CB_GameLib*  GameLib_RegisterMe             (void *addonData);
+    static void         GameLib_UnRegisterMe           (void *addonData, CB_GameLib* cbTable);
+    void*               GetHelperGame()               { return m_helperGame; }
     /*
      * API level independent functions for Kodi
      */
@@ -144,6 +154,7 @@ namespace ADDON
     void*     m_helperCODEC;
     void*     m_helperInputStream;
     void*     m_helperPeripheral;
+    void*     m_helperGame;
   };
 
 } /* namespace ADDON */
diff --git a/xbmc/addons/binary/interfaces/api1/Addon/AddonCallbacksAddon.cpp b/xbmc/addons/binary/interfaces/api1/Addon/AddonCallbacksAddon.cpp
index ea974a0..4034d89 100644
--- a/xbmc/addons/binary/interfaces/api1/Addon/AddonCallbacksAddon.cpp
+++ b/xbmc/addons/binary/interfaces/api1/Addon/AddonCallbacksAddon.cpp
@@ -34,7 +34,6 @@
 #include "utils/XMLUtils.h"
 #include "URL.h"
 #include "addons/kodi-addon-dev-kit/include/kodi/kodi_vfs_types.h"
-#include "filesystem/SpecialProtocol.h"
 
 using namespace ADDON;
 using namespace XFILE;
@@ -56,7 +55,6 @@ CAddonCallbacksAddon::CAddonCallbacksAddon(CAddon* addon)
   m_callbacks->QueueNotification  = QueueNotification;
   m_callbacks->WakeOnLan          = WakeOnLan;
   m_callbacks->GetSetting         = GetAddonSetting;
-  m_callbacks->TranslateSpecialProtocol = TranslateSpecialProtocol;
   m_callbacks->UnknownToUTF8      = UnknownToUTF8;
   m_callbacks->GetLocalizedString = GetLocalizedString;
   m_callbacks->GetDVDMenuLanguage = GetDVDMenuLanguage;
@@ -277,22 +275,6 @@ bool CAddonCallbacksAddon::GetAddonSetting(void *addonData, const char *strSetti
   return false;
 }
 
-char* CAddonCallbacksAddon::TranslateSpecialProtocol(const char *strSource)
-{
-  try
-  {
-    if (strSource)
-      return strdup(CSpecialProtocol::TranslatePath(strSource).c_str());
-    else
-      return NULL;
-  }
-  catch (std::exception &e)
-  {
-    CLog::Log(LOGERROR, "CAddonCallbacksAddon - %s - exception '%s' caught", __FUNCTION__, e.what());
-    return NULL;
-  }
-}
-
 char* CAddonCallbacksAddon::UnknownToUTF8(const char *strSource)
 {
   std::string string;
diff --git a/xbmc/addons/binary/interfaces/api1/Addon/AddonCallbacksAddon.h b/xbmc/addons/binary/interfaces/api1/Addon/AddonCallbacksAddon.h
index c9d3bfe..58d59e8 100644
--- a/xbmc/addons/binary/interfaces/api1/Addon/AddonCallbacksAddon.h
+++ b/xbmc/addons/binary/interfaces/api1/Addon/AddonCallbacksAddon.h
@@ -49,7 +49,6 @@ typedef void (*AddOnLogCallback)(void *addonData, const ADDON::addon_log_t logle
 typedef void (*AddOnQueueNotification)(void *addonData, const ADDON::queue_msg_t type, const char *msg);
 typedef bool (*AddOnWakeOnLan)(const char* mac);
 typedef bool (*AddOnGetSetting)(void *addonData, const char *settingName, void *settingValue);
-typedef char* (*AddonTranslateSpecialProtocol)(const char *strSource);
 typedef char* (*AddOnUnknownToUTF8)(const char *sourceDest);
 typedef char* (*AddOnGetLocalizedString)(const void* addonData, long dwCode);
 typedef char* (*AddOnGetDVDMenuLanguage)(const void* addonData);
@@ -87,7 +86,6 @@ typedef struct CB_AddOn
   AddOnQueueNotification      QueueNotification;
   AddOnWakeOnLan              WakeOnLan;
   AddOnGetSetting             GetSetting;
-  AddonTranslateSpecialProtocol TranslateSpecialProtocol;
   AddOnUnknownToUTF8          UnknownToUTF8;
   AddOnGetLocalizedString     GetLocalizedString;
   AddOnGetDVDMenuLanguage     GetDVDMenuLanguage;
@@ -133,7 +131,6 @@ public:
 
   static void AddOnLog(void *addonData, const ADDON::addon_log_t addonLogLevel, const char *strMessage);
   static bool GetAddonSetting(void *addonData, const char *strSettingName, void *settingValue);
-  static char *TranslateSpecialProtocol(const char *strSource);
   static void QueueNotification(void *addonData, const ADDON::queue_msg_t type, const char *strMessage);
   static bool WakeOnLan(const char *mac);
   static char* UnknownToUTF8(const char *strSource);
diff --git a/xbmc/addons/binary/interfaces/api1/Game/AddonCallbacksGame.cpp b/xbmc/addons/binary/interfaces/api1/Game/AddonCallbacksGame.cpp
new file mode 100644
index 0000000..03ffed0
--- /dev/null
+++ b/xbmc/addons/binary/interfaces/api1/Game/AddonCallbacksGame.cpp
@@ -0,0 +1,267 @@
+/*
+ *      Copyright (C) 2012-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "AddonCallbacksGame.h"
+#include "cores/AudioEngine/Utils/AEChannelInfo.h"
+#include "games/addons/GameClient.h"
+#include "utils/log.h"
+
+//#include "libavutil/avconfig.h"
+
+#include <string>
+
+using namespace ADDON;
+using namespace GAME;
+
+namespace V1
+{
+namespace KodiAPI
+{
+
+namespace Game
+{
+
+CAddonCallbacksGame::CAddonCallbacksGame(CAddon* addon) :
+  ADDON::IAddonInterface(addon, 1, GAME_API_VERSION),
+  m_callbacks(new CB_GameLib)
+{
+  /* write Kodi game specific add-on function addresses to callback table */
+  m_callbacks->CloseGame                      = CloseGame;
+  m_callbacks->OpenVideoStream                = OpenVideoStream;
+  m_callbacks->AddVideoData                   = AddVideoData;
+  m_callbacks->CloseVideoStream               = CloseVideoStream;
+  m_callbacks->OpenAudioStream                = OpenAudioStream;
+  m_callbacks->AddAudioData                   = AddAudioData;
+  m_callbacks->CloseAudioStream               = CloseAudioStream;
+  m_callbacks->HwSetInfo                      = HwSetInfo;
+  m_callbacks->HwGetCurrentFramebuffer        = HwGetCurrentFramebuffer;
+  m_callbacks->HwGetProcAddress               = HwGetProcAddress;
+  m_callbacks->OpenPort                       = OpenPort;
+  m_callbacks->ClosePort                      = ClosePort;
+  m_callbacks->RumbleSetState                 = RumbleSetState;
+}
+
+CAddonCallbacksGame::~CAddonCallbacksGame()
+{
+  /* delete the callback table */
+  delete m_callbacks;
+}
+
+CGameClient* CAddonCallbacksGame::GetGameClient(void* addonData, const char* strFunction)
+{
+  CAddonInterfaces* addon = static_cast<CAddonInterfaces*>(addonData);
+  if (!addon || !addon->GetHelperGame())
+  {
+    CLog::Log(LOGERROR, "GAME - %s - called with a null pointer", strFunction);
+    return NULL;
+  }
+
+  return dynamic_cast<CGameClient*>(static_cast<CAddonCallbacksGame*>(addon->GetHelperGame())->m_addon);
+}
+
+void CAddonCallbacksGame::CloseGame(void* addonData)
+{
+  CGameClient* gameClient = GetGameClient(addonData, __FUNCTION__);
+  if (!gameClient)
+    return;
+
+  return gameClient->CloseFile();
+}
+
+int CAddonCallbacksGame::OpenVideoStream(void* addonData, GAME_VIDEO_FORMAT format, unsigned int width, unsigned int height)
+{
+  CGameClient* gameClient = GetGameClient(addonData, __FUNCTION__);
+  if (!gameClient)
+    return -1;
+
+  AVCodecID codec = AV_CODEC_ID_NONE;
+  AVPixelFormat pixelFormat = AV_PIX_FMT_NONE;
+
+  switch (format)
+  {
+    case GAME_VIDEO_FORMAT_YUV420P:
+      pixelFormat = AV_PIX_FMT_YUV420P;
+      break;
+    case GAME_VIDEO_FORMAT_0RGB8888:
+      pixelFormat = AV_PIX_FMT_0RGB32;
+      break;
+    case GAME_VIDEO_FORMAT_RGB565:
+      pixelFormat = AV_PIX_FMT_RGB565;
+      break;
+    case GAME_VIDEO_FORMAT_0RGB1555:
+      pixelFormat = AV_PIX_FMT_RGB555;
+      break;
+    case GAME_VIDEO_FORMAT_H264:
+      codec = AV_CODEC_ID_H264;
+      break;
+    case GAME_VIDEO_FORMAT_UNKNOWN:
+    default:
+      break;
+  }
+
+  if (codec == AV_CODEC_ID_NONE && pixelFormat == AV_PIX_FMT_NONE)
+    return -1;
+
+  return gameClient->OpenVideoStream(codec, pixelFormat, width, height) ? 0 : -1;
+}
+
+void CAddonCallbacksGame::AddVideoData(void* addonData, const uint8_t* data, unsigned int size)
+{
+  CGameClient* gameClient = GetGameClient(addonData, __FUNCTION__);
+  if (!gameClient)
+    return;
+
+  gameClient->AddVideoData(data, size);
+}
+
+void CAddonCallbacksGame::CloseVideoStream(void* addonData)
+{
+  CGameClient* gameClient = GetGameClient(addonData, __FUNCTION__);
+  if (!gameClient)
+    return;
+
+  gameClient->CloseVideoStream();
+}
+
+int CAddonCallbacksGame::OpenAudioStream(void* addonData, GAME_AUDIO_FORMAT format, unsigned int samplerate, GAME_AUDIO_CHANNEL_LAYOUT channels)
+{
+  CGameClient* gameClient = GetGameClient(addonData, __FUNCTION__);
+  if (!gameClient)
+    return -1;
+
+  AVCodecID codec = AV_CODEC_ID_NONE;
+  CAEChannelInfo channelLayout;
+
+  switch (format)
+  {
+    case GAME_AUDIO_FORMAT_S16NE:
+#if AV_HAVE_BIGENDIAN
+      codec = AV_CODEC_ID_PCM_S16BE;
+#else
+      codec = AV_CODEC_ID_PCM_S16LE;
+#endif
+      break;
+    case GAME_AUDIO_FORMAT_OPUS:
+      codec = AV_CODEC_ID_OPUS;
+      break;
+    case GAME_AUDIO_FORMAT_UNKNOWN:
+    default:
+      break;
+  }
+
+  switch (channels)
+  {
+    case CH_FL_FR:
+    {
+      static enum AEChannel layout[] = {AE_CH_FL, AE_CH_FR, AE_CH_NULL};
+      channelLayout = layout;
+      break;
+    }
+    case CH_FL_C_FR:
+    {
+      static enum AEChannel layout[] = {AE_CH_FL, AE_CH_FC, AE_CH_FR, AE_CH_NULL};
+      channelLayout = layout;
+      break;
+    }
+    case CH_FL_FR_RL_RR:
+    {
+      static enum AEChannel layout[] = {AE_CH_FL, AE_CH_FR, AE_CH_BL, AE_CH_BR, AE_CH_NULL};
+      channelLayout = layout;
+      break;
+    }
+    case CH_FL_C_FR_RL_RR_LFE:
+    {
+      static enum AEChannel layout[] = {AE_CH_FL, AE_CH_FC, AE_CH_FR, AE_CH_BL, AE_CH_BR, AE_CH_LFE, AE_CH_NULL};
+      channelLayout = layout;
+      break;
+    }
+    case GAME_AUDIO_CHANNEL_UNKNOWN:
+    default:
+      break;
+  }
+
+  if (codec == AV_CODEC_ID_NONE)
+    return -1;
+
+  return gameClient->OpenAudioStream(codec, samplerate, channelLayout) ? 0 : -1;
+}
+
+void CAddonCallbacksGame::AddAudioData(void* addonData, const uint8_t* data, unsigned int size)
+{
+  CGameClient* gameClient = GetGameClient(addonData, __FUNCTION__);
+  if (!gameClient)
+    return;
+
+  gameClient->AddAudioData(data, size);
+}
+
+void CAddonCallbacksGame::CloseAudioStream(void* addonData)
+{
+  CGameClient* gameClient = GetGameClient(addonData, __FUNCTION__);
+  if (!gameClient)
+    return;
+
+  gameClient->CloseAudioStream();
+}
+
+void CAddonCallbacksGame::HwSetInfo(void* addonData, const game_hw_info *hw_info)
+{
+  // TODO
+}
+
+uintptr_t CAddonCallbacksGame::HwGetCurrentFramebuffer(void* addonData)
+{
+  // TODO
+  return 0;
+}
+
+game_proc_address_t CAddonCallbacksGame::HwGetProcAddress(void* addonData, const char *sym)
+{
+  // TODO
+  return nullptr;
+}
+
+bool CAddonCallbacksGame::OpenPort(void* addonData, unsigned int port)
+{
+  CGameClient* gameClient = GetGameClient(addonData, __FUNCTION__);
+  if (!gameClient)
+    return false;
+
+  return gameClient->OpenPort(port);
+}
+
+void CAddonCallbacksGame::ClosePort(void* addonData, unsigned int port)
+{
+  CGameClient* gameClient = GetGameClient(addonData, __FUNCTION__);
+  if (!gameClient)
+    return;
+
+  gameClient->ClosePort(port);
+}
+
+void CAddonCallbacksGame::RumbleSetState(void* addonData, unsigned int port, GAME_RUMBLE_EFFECT effect, float strength)
+{
+  // TODO
+}
+
+} /* namespace Game */
+
+} /* namespace KodiAPI */
+} /* namespace V1 */
diff --git a/xbmc/addons/binary/interfaces/api1/Game/AddonCallbacksGame.h b/xbmc/addons/binary/interfaces/api1/Game/AddonCallbacksGame.h
new file mode 100644
index 0000000..05b38e8
--- /dev/null
+++ b/xbmc/addons/binary/interfaces/api1/Game/AddonCallbacksGame.h
@@ -0,0 +1,71 @@
+/*
+ *      Copyright (C) 2012-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+#include "addons/binary/interfaces/AddonInterfaces.h"
+
+namespace GAME { class CGameClient; }
+
+namespace V1
+{
+namespace KodiAPI
+{
+
+namespace Game
+{
+
+/*!
+ * Callbacks for a game add-on to Kodi
+ */
+class CAddonCallbacksGame : public ADDON::IAddonInterface
+{
+public:
+  CAddonCallbacksGame(ADDON::CAddon* addon);
+  ~CAddonCallbacksGame(void);
+
+  /*!
+   * @return The callback table.
+   */
+  CB_GameLib* GetCallbacks() const { return m_callbacks; }
+
+  static void CloseGame(void* addonData);
+  static int OpenVideoStream(void* addonData, GAME_VIDEO_FORMAT format, unsigned int width, unsigned int height);
+  static void AddVideoData(void* addonData, const uint8_t* data, unsigned int size);
+  static void CloseVideoStream(void* addonData);
+  static int OpenAudioStream(void* addonData, GAME_AUDIO_FORMAT format, unsigned int samplerate, GAME_AUDIO_CHANNEL_LAYOUT channels);
+  static void AddAudioData(void* addonData, const uint8_t* data, unsigned int size);
+  static void CloseAudioStream(void* addonData);
+  static void HwSetInfo(void* addonData, const game_hw_info* hw_info);
+  static uintptr_t HwGetCurrentFramebuffer(void* addonData);
+  static game_proc_address_t HwGetProcAddress(void* addonData, const char* sym);
+  static bool OpenPort(void* addonData, unsigned int port);
+  static void ClosePort(void* addonData, unsigned int port);
+  static void RumbleSetState(void* addonData, unsigned int port, GAME_RUMBLE_EFFECT effect, float strength);
+
+private:
+  static GAME::CGameClient* GetGameClient(void* addonData, const char* strFunction);
+
+  CB_GameLib*  m_callbacks; /*!< callback addresses */
+};
+
+} /* namespace Game */
+
+} /* namespace KoidAPI */
+} /* namespace V1 */
diff --git a/xbmc/addons/binary/interfaces/api1/Game/CMakeLists.txt b/xbmc/addons/binary/interfaces/api1/Game/CMakeLists.txt
new file mode 100644
index 0000000..48e3cfc
--- /dev/null
+++ b/xbmc/addons/binary/interfaces/api1/Game/CMakeLists.txt
@@ -0,0 +1,9 @@
+set(SOURCES AddonCallbacksGame.cpp)
+
+set(HEADERS AddonCallbacksGame.h)
+
+core_add_library(api1AddonCallbacks_Game)
+
+if(ENABLE_INTERNAL_FFMPEG)
+  add_dependencies(api1AddonCallbacks_Game ffmpeg)
+endif()
diff --git a/xbmc/addons/binary/interfaces/api1/Game/Makefile b/xbmc/addons/binary/interfaces/api1/Game/Makefile
new file mode 100644
index 0000000..460425b
--- /dev/null
+++ b/xbmc/addons/binary/interfaces/api1/Game/Makefile
@@ -0,0 +1,7 @@
+SRCS=AddonCallbacksGame.cpp \
+
+LIB=addon-callbacks-game.a
+
+include ../../../../../../Makefile.include
+-include $(patsubst %.cpp,%.P,$(patsubst %.c,%.P,$(SRCS)))
+
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/kodi_addon_utils.hpp b/xbmc/addons/kodi-addon-dev-kit/include/kodi/kodi_addon_utils.hpp
new file mode 100644
index 0000000..a44e788
--- /dev/null
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/kodi_addon_utils.hpp
@@ -0,0 +1,124 @@
+/*
+ *      Copyright (C) 2013-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+ #pragma once
+
+/*!
+ * @file kodi_addon_utils.hpp  C++ wrappers for add-on callbacks
+ */
+
+#include "libXBMC_addon.h"
+
+#include <cstring>
+#include <string>
+
+class AddonUtils
+{
+public:
+  /*!
+   * @brief Convert a string of unknown encoding to UTF8
+   * @param frontend   The add-on callback helper
+   * @param str        The string
+   * @return The UTF8 string, or empty if the add-on helper fails to return a string
+   */
+  static std::string UnknownToUTF8(ADDON::CHelper_libXBMC_addon* frontend, const std::string& str)
+  {
+    std::string strReturn;
+    if (frontend)
+    {
+      char* strMsg = frontend->UnknownToUTF8(str.c_str());
+      if (strMsg)
+      {
+        if (std::strlen(strMsg))
+          strReturn = strMsg;
+        frontend->FreeString(strMsg);
+      }
+    }
+    return strReturn;
+  }
+
+  /*!
+   * @brief Get a localized message
+   * @param frontend   The add-on callback helper
+   * @param dwCode     The code of the message to get
+   * @param strDefault The default message, also helps to identify the code that is used
+   * @return The localized message, or strDefault if the add-on helper fails to return a message
+   */
+  static std::string GetLocalizedString(ADDON::CHelper_libXBMC_addon* frontend, int dwCode, const std::string& strDefault = "")
+  {
+    std::string strReturn(strDefault);
+    if (frontend)
+    {
+      char* strMsg = frontend->GetLocalizedString(dwCode);
+      // frontend->GetLocalizedString() will return an empty string on invalid ID (such as 31000)
+      // If the default is non-empty, we were probably expecting a non-empty message, so
+      // return the default in this case
+      if (strMsg)
+      {
+        if (std::strlen(strMsg))
+          strReturn = strMsg;
+        frontend->FreeString(strMsg);
+      }
+    }
+    return strReturn;
+  }
+
+  /*!
+   * @brief Get the DVD menu language
+   * @param frontend   The add-on callback helper
+   * @return The DVD menu langauge, or empty if unknown
+   */
+  static std::string GetDVDMenuLanguage(ADDON::CHelper_libXBMC_addon* frontend)
+  {
+    std::string strReturn;
+    if (frontend)
+    {
+      char* strMsg = frontend->GetDVDMenuLanguage();
+      if (strMsg)
+      {
+        if (std::strlen(strMsg))
+          strReturn = strMsg;
+        frontend->FreeString(strMsg);
+      }
+    }
+    return strReturn;
+  }
+
+  /*!
+   * @brief Translate an add-on status return code into a human-readable string
+   * @param status The return code
+   * @return A human-readable string suitable for logging
+   */
+  static const char* TranslateAddonStatus(ADDON_STATUS status)
+  {
+    switch (status)
+    {
+      case ADDON_STATUS_OK:                 return "OK";
+      case ADDON_STATUS_LOST_CONNECTION:    return "Lost connection";
+      case ADDON_STATUS_NEED_RESTART:       return "Needs restart";
+      case ADDON_STATUS_NEED_SETTINGS:      return "Needs settngs";
+      case ADDON_STATUS_UNKNOWN:            return "Unknown";
+      case ADDON_STATUS_NEED_SAVEDSETTINGS: return "Needs saved settings";
+      case ADDON_STATUS_PERMANENT_FAILURE:  return "Permanent failure";
+      default:
+        break;
+    }
+    return "";
+  }
+};
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/kodi_game_callbacks.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/kodi_game_callbacks.h
new file mode 100644
index 0000000..df1c231
--- /dev/null
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/kodi_game_callbacks.h
@@ -0,0 +1,136 @@
+/*
+ *      Copyright (C) 2014-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#ifndef KODI_GAME_CALLBACKS_H_
+#define KODI_GAME_CALLBACKS_H_
+
+#include "kodi_game_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct CB_GameLib
+{
+  // --- Game callbacks --------------------------------------------------------
+
+  /*!
+   * \brief Requests the frontend to stop the current game
+   */
+  void (*CloseGame)(void* addonData);
+
+  /*!
+   * \brief Create a video stream
+   * \param format The type of data accepted by this stream
+   * \param width The frame width for raw frames or unused for encoded data
+   * \param width The frame height for raw frames or unused for encoded data
+   * \return 0 on success or -1 if a video stream is already created
+   */
+  int (*OpenVideoStream)(void* addonData, GAME_VIDEO_FORMAT format, unsigned int width, unsigned int height);
+
+  /*!
+   * \brief Add video data to a video stream
+   * \param data The video stream data
+   * \param size The size of the data
+   */
+  void (*AddVideoData)(void* addonData, const uint8_t* data, unsigned int size);
+
+  /*!
+   * \brief Free the video stream
+   */
+  void (*CloseVideoStream)(void* addonData);
+
+  /*!
+   * \brief Create an audio stream
+   * \param format The type of data accepted by this stream
+   * \param samplerate The sample rate or unused for encoded data
+   * \param channels The channel layout or unused for encoded data
+   * \return 0 on success or -1 if an audio stream is already created
+   */
+  int (*OpenAudioStream)(void* addonData, GAME_AUDIO_FORMAT format, unsigned int samplerate, GAME_AUDIO_CHANNEL_LAYOUT channels);
+
+  /*!
+   * \brief Add audio data to an audio stream
+   * \param data The audio stream data
+   * \param size The size of the data
+   */
+  void (*AddAudioData)(void* addonData, const uint8_t* data, unsigned int size);
+
+  /*!
+   * \brief Free the audio stream
+   */
+  void (*CloseAudioStream)(void* addonData);
+
+  // -- Hardware rendering callbacks -------------------------------------------
+
+  /*!
+   * \brief Set info for hardware rendering
+   *
+   * \param hw_info A struct of properties for the hardware rendering system
+   */
+  void (*HwSetInfo)(void* addonData, const game_hw_info* hw_info);
+
+  /*!
+   * \brief Get the framebuffer for rendering
+   *
+   * \return The framebuffer
+   */
+  uintptr_t (*HwGetCurrentFramebuffer)(void* addonData);
+
+  /*!
+   * \brief Get a symbol from the hardware context
+   *
+   * \param symbol The symbol's name
+   *
+   * \return A function pointer for the specified symbol
+   */
+  game_proc_address_t (*HwGetProcAddress)(void* addonData, const char* symbol);
+
+  // --- Input callbacks -------------------------------------------------------
+
+  /*!
+   * \brief Begin reporting events for the specified port
+   *
+   * \param port The zero-indexed port number
+   */
+  bool (*OpenPort)(void* addonData, unsigned int port);
+
+  /*!
+   * \brief End reporting events for the specified port
+   *
+   * \param port The port number passed to OpenPort()
+   */
+  void (*ClosePort)(void* addonData, unsigned int port);
+
+  /*!
+   * \brief Set the rumble state of a controller
+   *
+   * \param port The number passed when opening the port
+   * \param effect Apply the rumble to the strong motor or the weak motor
+   * \param strength The magnitude of the feedback in the closed interval [0.0, 1.0]
+   */
+  void (*RumbleSetState)(void* addonData, unsigned int port, GAME_RUMBLE_EFFECT effect, float strength);
+
+} CB_GameLib;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // KODI_GAME_CALLBACKS_H_
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/kodi_game_dll.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/kodi_game_dll.h
new file mode 100644
index 0000000..a04e46c
--- /dev/null
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/kodi_game_dll.h
@@ -0,0 +1,268 @@
+/*
+ *      Copyright (C) 2014-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#ifndef KODI_GAME_DLL_H_
+#define KODI_GAME_DLL_H_
+
+#include "kodi_game_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// --- Game API operations -----------------------------------------------------
+
+/*!
+ * \brief Return GAME_API_VERSION_STRING
+ *
+ * The add-on is backwards compatible with the frontend if this API version is
+ * is at least the frontend's minimum API version.
+ *
+ * \return Must be GAME_API_VERSION_STRING
+ */
+const char* GetGameAPIVersion(void);
+
+/*!
+ * \brief Return GAME_MIN_API_VERSION_STRING
+ *
+ * The add-on is forwards compatible with the frontend if this minimum version
+ * is no more than the frontend's API version.
+ *
+ * \return Must be GAME_MIN_API_VERSION_STRING
+ */
+const char* GetMininumGameAPIVersion(void);
+
+// --- Game operations ---------------------------------------------------------
+
+/*!
+ * \brief Load a game
+ *
+ * \param url The URL to load
+ *
+ * return the error, or GAME_ERROR_NO_ERROR if the game was loaded
+ */
+GAME_ERROR LoadGame(const char* url);
+
+/*!
+ * \brief Load a game that requires multiple files
+ *
+ * \param type The game stype
+ * \param urls An array of urls
+ * \param urlCount The number of urls in the array
+ *
+ * \return the error, or GAME_ERROR_NO_ERROR if the game was loaded
+ */
+GAME_ERROR LoadGameSpecial(SPECIAL_GAME_TYPE type, const char** urls, size_t urlCount);
+
+/*!
+ * \brief Begin playing without a game file
+ *
+ * If the add-on supports standalone mode, it must add the <supports_standalone>
+ * tag to the extension point in addon.xml:
+ *
+ *     <supports_no_game>false</supports_no_game>
+ *
+ * \return the error, or GAME_ERROR_NO_ERROR if the game add-on was loaded
+ */
+GAME_ERROR LoadStandalone(void);
+
+/*!
+ * \brief Unload the current game
+ *
+ * \return the error, or GAME_ERROR_NO_ERROR if the game was unloaded
+ */
+/*! Unloads a currently loaded game */
+GAME_ERROR UnloadGame(void);
+
+/*!
+ * \brief Get information about the loaded game
+ *
+ * \param info The info structure to fill
+ *
+ * \return the error, or GAME_ERROR_NO_ERROR if info was filled
+ */
+GAME_ERROR GetGameInfo(game_system_av_info* info);
+
+/*!
+ * \brief Get region of the loaded game
+ *
+ * \return the region, or GAME_REGION_UNKNOWN if unknown or no game is loaded
+ */
+GAME_REGION GetRegion(void);
+
+/*!
+ * \brief Reset the current game
+ *
+ * \return the error, or GAME_ERROR_NO_ERROR if the game was reset
+ */
+GAME_ERROR Reset(void);
+
+// --- Hardware rendering operations -------------------------------------------
+
+/*!
+ * \brief Invalidates the current HW context and reinitializes GPU resources
+ *
+ * Any GL state is lost, and must not be deinitialized explicitly.
+ *
+ * \return the error, or GAME_ERROR_NO_ERROR if the HW context was reset
+ */
+GAME_ERROR HwContextReset(void);
+
+/*!
+ * \brief Called before the context is destroyed
+ *
+ * Resources can be deinitialized at this step.
+ *
+ * \return the error, or GAME_ERROR_NO_ERROR if the HW context was destroyed
+ */
+GAME_ERROR HwContextDestroy(void);
+
+// --- Input operations --------------------------------------------------------
+
+/*!
+ * \brief Notify the add-on of a status change on an open port
+ *
+ * Ports can be opened using the OpenPort() callback
+ *
+ * \param port The port number passed to OpenPort()
+ * \param collected True if a controller was connected, false if disconnected
+ * \param controller The connected controller
+ */
+void UpdatePort(unsigned int port, bool connected, const game_controller* controller);
+
+/*!
+ * \brief Check if input is accepted for a feature on the controller
+ *
+ * If only a subset of the controller profile is used, this can return false
+ * for unsupported features to not absorb their input.
+ *
+ * If the entire controller profile is used, this should always return true.
+ *
+ * \param controller_id The ID of the controller profile
+ * \param feature_name The name of a feature in that profile
+ * \return true if input is accepted for the feature, false otherwise
+ */
+bool HasFeature(const char* controller_id, const char* feature_name);
+
+/*!
+ * \brief Notify the add-on of an input event
+ *
+ * \param port The port number passed to OpenPort()
+ * \param event The input event
+ *
+ * \return true if the event was handled, false otherwise
+ */
+bool InputEvent(unsigned int port, const game_input_event* event);
+
+// --- Serialization operations ------------------------------------------------
+
+/*!
+ * \brief Get the number of bytes required to serialize the game
+ *
+ * \return the number of bytes, or 0 if serialization is not supported
+ */
+size_t SerializeSize(void);
+
+/*!
+ * \brief Serialize the state of the game
+ *
+ * \param data The buffer receiving the serialized game data
+ * \param size The size of the buffer
+ *
+ * \return the error, or GAME_ERROR_NO_ERROR if the game was serialized into the buffer
+ */
+GAME_ERROR Serialize(uint8_t* data, size_t size);
+
+/*!
+ * \brief Deserialize the game from the given state
+ *
+ * \param data A buffer containing the game's new state
+ * \param size The size of the buffer
+ *
+ * \return the error, or GAME_ERROR_NO_ERROR if the game deserialized
+ */
+GAME_ERROR Deserialize(const uint8_t* data, size_t size);
+
+// --- Cheat operations --------------------------------------------------------
+
+/*!
+ * \brief Reset the cheat system
+ *
+ * \return the error, or GAME_ERROR_NO_ERROR if the cheat system was reset
+ */
+GAME_ERROR CheatReset(void);
+
+/*!
+ * \brief Get a region of memory
+ *
+ * \param type The type of memory to retrieve
+ * \param data Set to the region of memory; must remain valid until UnloadGame() is called
+ * \param size Set to the size of the region of memory
+ *
+ * \return the error, or GAME_ERROR_NO_ERROR if data was set to a valid buffer
+ */
+GAME_ERROR GetMemory(GAME_MEMORY type, const uint8_t** data, size_t* size);
+
+/*!
+ * \brief Set a cheat code
+ *
+ * \param index
+ * \param enabled
+ * \param code
+ *
+ * \return the error, or GAME_ERROR_NO_ERROR if the cheat was set
+ */
+GAME_ERROR SetCheat(unsigned int index, bool enabled, const char* code);
+
+// --- Add-on helper implementation --------------------------------------------
+
+/*!
+ * \brief Called by Kodi to assign the function pointers of this add-on to pClient
+ *
+ * Note that get_addon() is defined here, so it will be available in all
+ * compiled game clients.
+ */
+void __declspec(dllexport) get_addon(GameClient* pClient)
+{
+  pClient->GetGameAPIVersion        = GetGameAPIVersion;
+  pClient->GetMininumGameAPIVersion = GetMininumGameAPIVersion;
+  pClient->LoadGame                 = LoadGame;
+  pClient->LoadGameSpecial          = LoadGameSpecial;
+  pClient->LoadStandalone           = LoadStandalone;
+  pClient->UnloadGame               = UnloadGame;
+  pClient->GetGameInfo              = GetGameInfo;
+  pClient->GetRegion                = GetRegion;
+  pClient->Reset                    = Reset;
+  pClient->HwContextReset           = HwContextReset;
+  pClient->HwContextDestroy         = HwContextDestroy;
+  pClient->UpdatePort               = UpdatePort;
+  pClient->InputEvent               = InputEvent;
+  pClient->SerializeSize            = SerializeSize;
+  pClient->Serialize                = Serialize;
+  pClient->Deserialize              = Deserialize;
+  pClient->CheatReset               = CheatReset;
+  pClient->GetMemory                = GetMemory;
+  pClient->SetCheat                 = SetCheat;
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // KODI_GAME_DLL_H_
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/kodi_game_types.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/kodi_game_types.h
new file mode 100644
index 0000000..96b9e70
--- /dev/null
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/kodi_game_types.h
@@ -0,0 +1,424 @@
+/*
+ *      Copyright (C) 2014-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#ifndef KODI_GAME_TYPES_H_
+#define KODI_GAME_TYPES_H_
+
+/* current game API version */
+#define GAME_API_VERSION                "1.0.15"
+
+/* min. game API version */
+#define GAME_MIN_API_VERSION            "1.0.15"
+
+#include <stddef.h>
+#include <stdint.h>
+
+#ifdef TARGET_WINDOWS
+  #include <windows.h>
+#else
+  #ifndef __cdecl
+    #define __cdecl
+  #endif
+  #ifndef __declspec
+    #define __declspec(X)
+  #endif
+#endif
+
+#undef ATTRIBUTE_PACKED
+#undef PRAGMA_PACK_BEGIN
+#undef PRAGMA_PACK_END
+
+#if defined(__GNUC__)
+  #if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 95)
+    #define ATTRIBUTE_PACKED __attribute__ ((packed))
+    #define PRAGMA_PACK 0
+  #endif
+#endif
+
+#if !defined(ATTRIBUTE_PACKED)
+  #define ATTRIBUTE_PACKED
+  #define PRAGMA_PACK 1
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*! Game add-on error codes */
+typedef enum GAME_ERROR
+{
+  GAME_ERROR_NO_ERROR,               // no error occurred
+  GAME_ERROR_UNKNOWN,                // an unknown error occurred
+  GAME_ERROR_NOT_IMPLEMENTED,        // the method that the frontend called is not implemented
+  GAME_ERROR_REJECTED,               // the command was rejected by the game client
+  GAME_ERROR_INVALID_PARAMETERS,     // the parameters of the method that was called are invalid for this operation
+  GAME_ERROR_FAILED,                 // the command failed
+  GAME_ERROR_NOT_LOADED,             // no game is loaded
+} GAME_ERROR;
+
+typedef enum GAME_VIDEO_FORMAT
+{
+  GAME_VIDEO_FORMAT_UNKNOWN = 0,
+
+  // Frame formats (data is pixels)
+  GAME_VIDEO_FORMAT_YUV420P = 1,
+  GAME_VIDEO_FORMAT_0RGB8888 = 2,
+  GAME_VIDEO_FORMAT_RGB565 = 3,
+  GAME_VIDEO_FORMAT_0RGB1555 = 4,
+
+  // Encoded formats (data is encoded packets)
+  GAME_VIDEO_FORMAT_H264 = 101,
+} GAME_VIDEO_FORMAT;
+
+typedef enum GAME_AUDIO_FORMAT
+{
+  GAME_AUDIO_FORMAT_UNKNOWN = 0,
+
+  // PCM formats
+  GAME_AUDIO_FORMAT_S16NE = 1,
+
+  // Encoded formats
+  GAME_AUDIO_FORMAT_OPUS = 101,
+} GAME_AUDIO_FORMAT;
+
+typedef enum GAME_AUDIO_CHANNEL_LAYOUT
+{
+  GAME_AUDIO_CHANNEL_UNKNOWN,
+
+  CH_FL_FR,                 // Front left, front right
+  CH_FL_C_FR,               // Front left, center, front right
+  CH_FL_FR_RL_RR,           // Front left, front right, rear left, rear right
+  CH_FL_C_FR_RL_RR_LFE,     // Front left, center, front right, rear left, rear right, LFE
+} GAME_AUDIO_CHANNEL_LAYOUT;
+
+typedef enum GAME_INPUT_EVENT_SOURCE
+{
+  GAME_INPUT_EVENT_DIGITAL_BUTTON,
+  GAME_INPUT_EVENT_ANALOG_BUTTON,
+  GAME_INPUT_EVENT_ANALOG_STICK,
+  GAME_INPUT_EVENT_ACCELEROMETER,
+  GAME_INPUT_EVENT_KEY,
+  GAME_INPUT_EVENT_RELATIVE_POINTER,
+  GAME_INPUT_EVENT_ABSOLUTE_POINTER,
+} GAME_INPUT_EVENT_SOURCE;
+
+/*! Returned from game_get_region() */
+typedef enum GAME_REGION
+{
+  GAME_REGION_UNKNOWN,
+  GAME_REGION_NTSC,
+  GAME_REGION_PAL,
+} GAME_REGION;
+
+typedef enum GAME_MEMORY
+{
+  /*!
+   * Passed to game_get_memory_data/size(). If the memory type doesn't apply
+   * to the implementation NULL/0 can be returned.
+   */
+  GAME_MEMORY_MASK                   = 0xff,
+
+  /*!
+   * Regular save ram. This ram is usually found on a game cartridge, backed
+   * up by a battery. If save game data is too complex for a single memory
+   * buffer, the SYSTEM_DIRECTORY environment callback can be used.
+   */
+  GAME_MEMORY_SAVE_RAM               = 0,
+
+  /*!
+   * Some games have a built-in clock to keep track of time. This memory is
+   * usually just a couple of bytes to keep track of time.
+   */
+  GAME_MEMORY_RTC                    = 1,
+
+  /*! System ram lets a frontend peek into a game systems main RAM */
+  GAME_MEMORY_SYSTEM_RAM             = 2,
+
+  /*! Video ram lets a frontend peek into a game systems video RAM (VRAM) */
+  GAME_MEMORY_VIDEO_RAM              = 3,
+
+  /*! Special memory types */
+  GAME_MEMORY_SNES_BSX_RAM           = ((1 << 8) | GAME_MEMORY_SAVE_RAM),
+  GAME_MEMORY_SNES_BSX_PRAM          = ((2 << 8) | GAME_MEMORY_SAVE_RAM),
+  GAME_MEMORY_SNES_SUFAMI_TURBO_A_RAM= ((3 << 8) | GAME_MEMORY_SAVE_RAM),
+  GAME_MEMORY_SNES_SUFAMI_TURBO_B_RAM= ((4 << 8) | GAME_MEMORY_SAVE_RAM),
+  GAME_MEMORY_SNES_GAME_BOY_RAM      = ((5 << 8) | GAME_MEMORY_SAVE_RAM),
+  GAME_MEMORY_SNES_GAME_BOY_RTC      = ((6 << 8) | GAME_MEMORY_RTC),
+} GAME_MEMORY;
+
+/*!
+ * Special game types passed into game_load_game_special(). Only used when
+ * multiple ROMs are required.
+ */
+typedef enum SPECIAL_GAME_TYPE
+{
+  SPECIAL_GAME_TYPE_BSX,
+  SPECIAL_GAME_TYPE_BSX_SLOTTED,
+  SPECIAL_GAME_TYPE_SUFAMI_TURBO,
+  SPECIAL_GAME_TYPE_SUPER_GAME_BOY,
+} SPECIAL_GAME_TYPE;
+
+typedef enum GAME_KEY_MOD
+{
+  GAME_KEY_MOD_NONE                  = 0x00,
+
+  GAME_KEY_MOD_SHIFT                 = 0x01,
+  GAME_KEY_MOD_CTRL                  = 0x02,
+  GAME_KEY_MOD_ALT                   = 0x04,
+  GAME_KEY_MOD_RALT                  = 0x08,
+  GAME_KEY_MOD_META                  = 0x10,
+
+  GAME_KEY_MOD_NUMLOCK               = 0x20,
+  GAME_KEY_MOD_CAPSLOCK              = 0x40,
+  GAME_KEY_MOD_SCROLLOCK             = 0x80,
+} GAME_KEY_MOD;
+
+/*! ID values for SIMD CPU features */
+typedef enum GAME_SIMD
+{
+  GAME_SIMD_SSE                      = (1 << 0),
+  GAME_SIMD_SSE2                     = (1 << 1),
+  GAME_SIMD_VMX                      = (1 << 2),
+  GAME_SIMD_VMX128                   = (1 << 3),
+  GAME_SIMD_AVX                      = (1 << 4),
+  GAME_SIMD_NEON                     = (1 << 5),
+  GAME_SIMD_SSE3                     = (1 << 6),
+  GAME_SIMD_SSSE3                    = (1 << 7),
+  GAME_SIMD_MMX                      = (1 << 8),
+  GAME_SIMD_MMXEXT                   = (1 << 9),
+  GAME_SIMD_SSE4                     = (1 << 10),
+  GAME_SIMD_SSE42                    = (1 << 11),
+  GAME_SIMD_AVX2                     = (1 << 12),
+  GAME_SIMD_VFPU                     = (1 << 13),
+} GAME_SIMD;
+
+typedef enum GAME_RUMBLE_EFFECT
+{
+  GAME_RUMBLE_STRONG,
+  GAME_RUMBLE_WEAK,
+} GAME_RUMBLE_EFFECT;
+
+// TODO
+typedef enum GAME_HW_FRAME_BUFFER
+{
+  GAME_HW_FRAME_BUFFER_VALID,     // Pass this to game_video_refresh if rendering to hardware
+  GAME_HW_FRAME_BUFFER_DUPLICATE, // Passing NULL to game_video_refresh is still a frame dupe as normal
+  GAME_HW_FRAME_BUFFER_RENDER,
+} GAME_HW_FRAME_BUFFER;
+
+typedef enum GAME_HW_CONTEXT_TYPE
+{
+  GAME_HW_CONTEXT_NONE,
+  GAME_HW_CONTEXT_OPENGL,      // OpenGL 2.x. Latest version available before 3.x+. Driver can choose to use latest compatibility context
+  GAME_HW_CONTEXT_OPENGLES2,   // GLES 2.0
+  GAME_HW_CONTEXT_OPENGL_CORE, // Modern desktop core GL context. Use major/minor fields to set GL version
+  GAME_HW_CONTEXT_OPENGLES3,   // GLES 3.0
+} GAME_HW_CONTEXT_TYPE;
+
+typedef enum GAME_ROTATION
+{
+  GAME_ROTATION_0_CW,
+  GAME_ROTATION_90_CW,
+  GAME_ROTATION_180_CW,
+  GAME_ROTATION_270_CW,
+} GAME_ROTATION;
+
+typedef struct game_controller
+{
+  const char*  controller_id;
+  unsigned int digital_button_count;
+  unsigned int analog_button_count;
+  unsigned int analog_stick_count;
+  unsigned int accelerometer_count;
+  unsigned int key_count;
+  unsigned int rel_pointer_count;
+  unsigned int abs_pointer_count;
+} ATTRIBUTE_PACKED game_controller;
+
+typedef struct game_digital_button_event
+{
+  bool         pressed;
+} ATTRIBUTE_PACKED game_digital_button_event;
+
+typedef struct game_analog_button_event
+{
+  float        magnitude;
+} ATTRIBUTE_PACKED game_analog_button_event;
+
+typedef struct game_analog_stick_event
+{
+  float        x;
+  float        y;
+} ATTRIBUTE_PACKED game_analog_stick_event;
+
+typedef struct game_accelerometer_event
+{
+  float        x;
+  float        y;
+  float        z;
+} ATTRIBUTE_PACKED game_accelerometer_event;
+
+typedef struct game_key_event
+{
+  bool         pressed;
+  uint32_t     character; // text character of the pressed key (UTF-32)
+  GAME_KEY_MOD modifiers;
+} ATTRIBUTE_PACKED game_key_event;
+
+typedef struct game_rel_pointer_event
+{
+  int          x;
+  int          y;
+} ATTRIBUTE_PACKED game_rel_pointer_event;
+
+typedef struct game_abs_pointer_event
+{
+  bool         pressed;
+  float        x;
+  float        y;
+} ATTRIBUTE_PACKED game_abs_pointer_event;
+
+typedef struct game_input_event
+{
+  GAME_INPUT_EVENT_SOURCE type;
+  int                     port;
+  const char*             controller_id;
+  const char*             feature_name;
+  union
+  {
+    struct game_digital_button_event digital_button;
+    struct game_analog_button_event  analog_button;
+    struct game_analog_stick_event   analog_stick;
+    struct game_accelerometer_event  accelerometer;
+    struct game_key_event            key;
+    struct game_rel_pointer_event    rel_pointer;
+    struct game_abs_pointer_event    abs_pointer;
+  };
+} ATTRIBUTE_PACKED game_input_event;
+
+struct game_geometry
+{
+  unsigned base_width;          // Nominal video width of game
+  unsigned base_height;         // Nominal video height of game
+  unsigned max_width;           // Maximum possible width of game
+  unsigned max_height;          // Maximum possible height of game
+  float    aspect_ratio;        // Nominal aspect ratio of game. If aspect_ratio is <= 0.0,
+                                // an aspect ratio of base_width / base_height is assumed.
+                                // A frontend could override this setting if desired.
+};
+
+struct game_system_timing
+{
+  double fps;                   // FPS of video content.
+  double sample_rate;           // Sampling rate of audio.
+};
+
+struct game_system_av_info
+{
+  struct game_geometry geometry;
+  struct game_system_timing timing;
+};
+
+typedef void (*game_proc_address_t)(void);
+
+struct game_hw_info
+{
+  GAME_HW_CONTEXT_TYPE context_type;        // Which API to use. Set by game client
+  bool                 depth;               // Set if render buffers should have depth component attached
+  bool                 stencil;             // Set if stencil buffers should be attached
+                                            // If depth and stencil are true, a packed 24/8 buffer will be added. Only attaching stencil is invalid and will be ignored
+  bool                 bottom_left_origin;  // Use conventional bottom-left origin convention. Is false, standard top-left origin semantics are used
+  unsigned             version_major;       // Major version number for core GL context
+  unsigned             version_minor;       // Minor version number for core GL context
+  bool                 cache_context;       // If this is true, the frontend will go very far to avoid resetting context in scenarios like toggling fullscreen, etc.
+                                            // The reset callback might still be called in extreme situations such as if the context is lost beyond recovery
+                                            // For optimal stability, set this to false, and allow context to be reset at any time
+  bool                 debug_context;       // Creates a debug context
+};
+
+/*! Properties passed to the ADDON_Create() method of a game client */
+typedef struct game_client_properties
+{
+  /*!
+   * The path of the game client being loaded.
+   */
+  const char* game_client_dll_path;
+
+  /*!
+   * Paths to proxy DLLs used to load the game client.
+   */
+  const char** proxy_dll_paths;
+
+  /*!
+   * Number of proxy DLL paths provided.
+   */
+  unsigned int proxy_dll_count;
+
+  /*!
+   * The "system" directory of the frontend. This directory can be used to
+   * store system-specific ROMs such as BIOSes, configuration data, etc.
+   */
+  const char* system_directory;
+
+  /*!
+   * The "content" directory of the frontend. This directory can be used to
+   * store specific assets that the core relies upon, such as art assets, input
+   * data, etc.
+   */
+  const char* content_directory;
+
+  /*!
+   * The "save" directory of the frontend. This directory can be used to store
+   * SRAM, memory cards, high scores, etc, if the game client cannot use the
+   * regular memory interface, GetMemoryData().
+   */
+  const char* save_directory;
+
+} game_client_properties;
+
+/*! Structure to transfer the methods from kodi_game_dll.h to Kodi */
+typedef struct GameClient
+{
+  const char* (__cdecl* GetGameAPIVersion)(void);
+  const char* (__cdecl* GetMininumGameAPIVersion)(void);
+  GAME_ERROR  (__cdecl* LoadGame)(const char*);
+  GAME_ERROR  (__cdecl* LoadGameSpecial)(SPECIAL_GAME_TYPE, const char**, size_t);
+  GAME_ERROR  (__cdecl* LoadStandalone)(void);
+  GAME_ERROR  (__cdecl* UnloadGame)(void);
+  GAME_ERROR  (__cdecl* GetGameInfo)(game_system_av_info*);
+  GAME_REGION (__cdecl* GetRegion)(void);
+  GAME_ERROR  (__cdecl* Reset)(void);
+  GAME_ERROR  (__cdecl* HwContextReset)(void);
+  GAME_ERROR  (__cdecl* HwContextDestroy)(void);
+  void        (__cdecl* UpdatePort)(unsigned int, bool, const game_controller*);
+  bool        (__cdecl* HasFeature)(const char* controller_id, const char* feature_name);
+  bool        (__cdecl* InputEvent)(unsigned int, const game_input_event*);
+  size_t      (__cdecl* SerializeSize)(void);
+  GAME_ERROR  (__cdecl* Serialize)(uint8_t*, size_t);
+  GAME_ERROR  (__cdecl* Deserialize)(const uint8_t*, size_t);
+  GAME_ERROR  (__cdecl* CheatReset)(void);
+  GAME_ERROR  (__cdecl* GetMemory)(GAME_MEMORY, const uint8_t**, size_t*);
+  GAME_ERROR  (__cdecl* SetCheat)(unsigned int, bool, const char*);
+} GameClient;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // KODI_GAME_TYPES_H_
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/kodi_inputstream_dll.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/kodi_inputstream_dll.h
index bb9a2d4..6ecf566 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/kodi_inputstream_dll.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/kodi_inputstream_dll.h
@@ -139,11 +139,6 @@ extern "C"
    */
   void DemuxSetSpeed(int speed);
 
-  /*!
-   * Sets desired width / height
-   * @param width / hight
-   */
-  void SetVideoResolution(int width, int height);
 
   /*!
    * Totel time in ms
@@ -243,7 +238,6 @@ extern "C"
     pClient->DemuxRead = DemuxRead;
     pClient->DemuxSeekTime = DemuxSeekTime;
     pClient->DemuxSetSpeed = DemuxSetSpeed;
-    pClient->SetVideoResolution = SetVideoResolution;
 
     pClient->GetTotalTime = GetTotalTime;
     pClient->GetTime = GetTime;
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/kodi_inputstream_types.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/kodi_inputstream_types.h
index 3a2e2da..fae05fa 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/kodi_inputstream_types.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/kodi_inputstream_types.h
@@ -140,7 +140,6 @@ extern "C" {
     DemuxPacket* (__cdecl* DemuxRead)(void);
     bool (__cdecl* DemuxSeekTime)(int, bool, double*);
     void (__cdecl* DemuxSetSpeed)(int);
-    void (__cdecl* SetVideoResolution)(int, int);
 
     // IDisplayTime
     int (__cdecl* GetTotalTime)(void);
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/libKODI_audioengine.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/libKODI_audioengine.h
index be3b93d..6c4e8c8 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/libKODI_audioengine.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/libKODI_audioengine.h
@@ -27,9 +27,9 @@
 
 #include "kodi_audioengine_types.h"
 #ifdef BUILD_KODI_ADDON
-  #include "kodi/AudioEngine/AEChannelData.h"
-  #include "kodi/AudioEngine/AEChannelInfo.h"
-  #include "kodi/AudioEngine/AEStreamData.h"
+  #include "kodi/AEChannelData.h"
+  #include "kodi/AEChannelInfo.h"
+  #include "kodi/AEStreamData.h"
 #else
   #include "cores/AudioEngine/Utils/AEChannelData.h"
   #include "cores/AudioEngine/Utils/AEChannelInfo.h"
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/libKODI_game.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/libKODI_game.h
new file mode 100644
index 0000000..b4aa42a
--- /dev/null
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/libKODI_game.h
@@ -0,0 +1,230 @@
+/*
+ *      Copyright (C) 2014-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+#include "libXBMC_addon.h"
+#include "kodi_game_callbacks.h"
+
+#include <string>
+#include <stdio.h>
+
+#if defined(ANDROID)
+  #include <sys/stat.h>
+#endif
+
+#ifdef _WIN32
+  #define GAME_HELPER_DLL "\\library.kodi.game\\libKODI_game" ADDON_HELPER_EXT
+#else
+  #define GAME_HELPER_DLL_NAME "libKODI_game-" ADDON_HELPER_ARCH ADDON_HELPER_EXT
+  #define GAME_HELPER_DLL "/library.kodi.game/" GAME_HELPER_DLL_NAME
+#endif
+
+#define GAME_REGISTER_SYMBOL(dll, functionPtr) \
+  CHelper_libKODI_game::RegisterSymbol(dll, functionPtr, #functionPtr)
+
+class CHelper_libKODI_game
+{
+public:
+  CHelper_libKODI_game(void) :
+    GAME_register_me(nullptr),
+    GAME_unregister_me(nullptr),
+    GAME_close_game(nullptr),
+    GAME_open_video_stream(nullptr),
+    GAME_add_video_data(nullptr),
+    GAME_close_video_stream(nullptr),
+    GAME_open_audio_stream(nullptr),
+    GAME_add_audio_data(nullptr),
+    GAME_close_audio_stream(nullptr),
+    GAME_hw_set_info(nullptr),
+    GAME_hw_get_current_framebuffer(nullptr),
+    GAME_hw_get_proc_address(nullptr),
+    GAME_open_port(nullptr),
+    GAME_close_port(nullptr),
+    GAME_rumble_set_state(nullptr),
+    m_handle(nullptr),
+    m_callbacks(nullptr),
+    m_libKODI_game(nullptr)
+  {
+  }
+
+  ~CHelper_libKODI_game(void)
+  {
+    if (m_libKODI_game)
+    {
+      GAME_unregister_me(m_handle, m_callbacks);
+      dlclose(m_libKODI_game);
+    }
+  }
+
+  template <typename T>
+  static bool RegisterSymbol(void* dll, T& functionPtr, const char* strFunctionPtr)
+  {
+    return (functionPtr = (T)dlsym(dll, strFunctionPtr)) != NULL;
+  }
+
+  /*!
+    * @brief Resolve all callback methods
+    * @param handle Pointer to the add-on
+    * @return True when all methods were resolved, false otherwise.
+    */
+  bool RegisterMe(void* handle)
+  {
+    m_handle = handle;
+
+    std::string libBasePath;
+    libBasePath  = ((cb_array*)m_handle)->libBasePath;
+    libBasePath += GAME_HELPER_DLL;
+
+#if defined(ANDROID)
+      struct stat st;
+      if (stat(libBasePath.c_str(),&st) != 0)
+      {
+        std::string tempbin = getenv("XBMC_ANDROID_LIBS");
+        libBasePath = tempbin + "/" + GAME_HELPER_DLL_NAME;
+      }
+#endif
+
+    m_libKODI_game = dlopen(libBasePath.c_str(), RTLD_LAZY);
+    if (m_libKODI_game == NULL)
+    {
+      fprintf(stderr, "Unable to load %s\n", dlerror());
+      return false;
+    }
+
+    try
+    {
+      if (!GAME_REGISTER_SYMBOL(m_libKODI_game, GAME_register_me)) throw false;
+      if (!GAME_REGISTER_SYMBOL(m_libKODI_game, GAME_unregister_me)) throw false;
+      if (!GAME_REGISTER_SYMBOL(m_libKODI_game, GAME_close_game)) throw false;
+      if (!GAME_REGISTER_SYMBOL(m_libKODI_game, GAME_open_video_stream)) throw false;
+      if (!GAME_REGISTER_SYMBOL(m_libKODI_game, GAME_add_video_data)) throw false;
+      if (!GAME_REGISTER_SYMBOL(m_libKODI_game, GAME_close_video_stream)) throw false;
+      if (!GAME_REGISTER_SYMBOL(m_libKODI_game, GAME_open_audio_stream)) throw false;
+      if (!GAME_REGISTER_SYMBOL(m_libKODI_game, GAME_add_audio_data)) throw false;
+      if (!GAME_REGISTER_SYMBOL(m_libKODI_game, GAME_close_audio_stream)) throw false;
+      if (!GAME_REGISTER_SYMBOL(m_libKODI_game, GAME_hw_set_info)) throw false;
+      if (!GAME_REGISTER_SYMBOL(m_libKODI_game, GAME_hw_get_current_framebuffer)) throw false;
+      if (!GAME_REGISTER_SYMBOL(m_libKODI_game, GAME_hw_get_proc_address)) throw false;
+      if (!GAME_REGISTER_SYMBOL(m_libKODI_game, GAME_open_port)) throw false;
+      if (!GAME_REGISTER_SYMBOL(m_libKODI_game, GAME_close_port)) throw false;
+      if (!GAME_REGISTER_SYMBOL(m_libKODI_game, GAME_rumble_set_state)) throw false;
+    }
+    catch (const bool& bSuccess)
+    {
+      fprintf(stderr, "ERROR: Unable to assign function %s\n", dlerror());
+      return bSuccess;
+    }
+
+    m_callbacks = GAME_register_me(m_handle);
+    return m_callbacks != NULL;
+  }
+
+  void CloseGame(void)
+  {
+    return GAME_close_game(m_handle, m_callbacks);
+  }
+
+  bool OpenVideoStream(GAME_VIDEO_FORMAT format, unsigned int width, unsigned int height)
+  {
+    return GAME_open_video_stream(m_handle, m_callbacks, format, width, height) == 0;
+  }
+
+  void AddVideoData(const uint8_t* data, unsigned int size)
+  {
+    GAME_add_video_data(m_handle, m_callbacks, data, size);
+  }
+
+  void CloseVideoStream()
+  {
+    GAME_close_video_stream(m_handle, m_callbacks);
+  }
+
+  bool OpenAudioStream(GAME_AUDIO_FORMAT format, unsigned int samplerate, GAME_AUDIO_CHANNEL_LAYOUT channels)
+  {
+    return GAME_open_audio_stream(m_handle, m_callbacks, format, samplerate, channels) == 0;
+  }
+
+  void AddAudioData(const uint8_t* data, unsigned int size)
+  {
+    GAME_add_audio_data(m_handle, m_callbacks, data, size);
+  }
+
+  void CloseAudioStream()
+  {
+    GAME_close_audio_stream(m_handle, m_callbacks);
+  }
+
+  void HwSetInfo(const struct game_hw_info* hw_info)
+  {
+    return GAME_hw_set_info(m_handle, m_callbacks, hw_info);
+  }
+
+  uintptr_t HwGetCurrentFramebuffer(void)
+  {
+    return GAME_hw_get_current_framebuffer(m_handle, m_callbacks);
+  }
+
+  game_proc_address_t HwGetProcAddress(const char* sym)
+  {
+    return GAME_hw_get_proc_address(m_handle, m_callbacks, sym);
+  }
+
+  bool OpenPort(unsigned int port)
+  {
+    return GAME_open_port(m_handle, m_callbacks, port);
+  }
+
+  void ClosePort(unsigned int port)
+  {
+    return GAME_close_port(m_handle, m_callbacks, port);
+  }
+
+  void RumbleSetState(unsigned int port, GAME_RUMBLE_EFFECT effect, float strength)
+  {
+    return GAME_rumble_set_state(m_handle, m_callbacks, port, effect, strength);
+  }
+
+protected:
+  CB_GameLib* (*GAME_register_me)(void* handle);
+  void (*GAME_unregister_me)(void* handle, CB_GameLib* cb);
+  void (*GAME_close_game)(void* handle, CB_GameLib* cb);
+  int (*GAME_open_video_stream)(void* handle, CB_GameLib* cb, GAME_VIDEO_FORMAT, unsigned int, unsigned int);
+  int (*GAME_add_video_data)(void* handle, CB_GameLib* cb, const uint8_t*, unsigned int);
+  int (*GAME_close_video_stream)(void* handle, CB_GameLib* cb);
+  int (*GAME_open_audio_stream)(void* handle, CB_GameLib* cb, GAME_AUDIO_FORMAT, unsigned int, GAME_AUDIO_CHANNEL_LAYOUT);
+  int (*GAME_add_audio_data)(void* handle, CB_GameLib* cb, const uint8_t*, unsigned int);
+  int (*GAME_close_audio_stream)(void* handle, CB_GameLib* cb);
+  void (*GAME_hw_set_info)(void* handle, CB_GameLib* cb, const struct game_hw_info*);
+  uintptr_t (*GAME_hw_get_current_framebuffer)(void* handle, CB_GameLib* cb);
+  game_proc_address_t (*GAME_hw_get_proc_address)(void* handle, CB_GameLib* cb, const char*);
+  bool (*GAME_open_port)(void* handle, CB_GameLib* cb, unsigned int);
+  void (*GAME_close_port)(void* handle, CB_GameLib* cb, unsigned int);
+  void (*GAME_rumble_set_state)(void* handle, CB_GameLib* cb, unsigned int, GAME_RUMBLE_EFFECT, float);
+
+private:
+  void*        m_handle;
+  CB_GameLib*  m_callbacks;
+  void*        m_libKODI_game;
+
+  struct cb_array
+  {
+    const char* libBasePath;
+  };
+};
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/libXBMC_addon.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/libXBMC_addon.h
index ddeb1db..499d1f5 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/libXBMC_addon.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/libXBMC_addon.h
@@ -82,11 +82,6 @@ typedef intptr_t      ssize_t;
 #define ADDON_DLL_NAME "libXBMC_addon-" ADDON_HELPER_ARCH ADDON_HELPER_EXT
 #define ADDON_DLL "/library.xbmc.addon/" ADDON_DLL_NAME
 #endif
-#if defined(ANDROID)
-#include <sys/stat.h>
-#endif
-
-struct __stat64;
 
 #ifdef LOG_DEBUG
 #undef LOG_DEBUG
@@ -101,6 +96,21 @@ struct __stat64;
 #undef LOG_ERROR
 #endif
 
+#include <sys/stat.h>
+#if !defined(__stat64)
+  #if defined(TARGET_DARWIN) || defined(TARGET_FREEBSD)
+    #define stat64 stat
+    #define __stat64 stat
+    #define fstat64 fstat
+    typedef int64_t off64_t;
+    #if defined(TARGET_FREEBSD)
+      #define statfs64 statfs
+    #endif
+  #else
+    #define __stat64 stat64
+  #endif
+#endif
+
 /* current addon API version */
 #define KODI_ADDON_API_VERSION "1.0.0"
 
@@ -179,10 +189,6 @@ namespace ADDON
         dlsym(m_libXBMC_addon, "XBMC_get_setting");
       if (XBMC_get_setting == NULL) { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
 
-      XBMC_translate_special = (char* (*)(void* HANDLE, void* CB, const char* source))
-        dlsym(m_libXBMC_addon, "XBMC_translate_special");
-      if (XBMC_translate_special == NULL) { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
-
       XBMC_queue_notification = (void (*)(void* HANDLE, void* CB, const queue_msg_t loglevel, const char *msg))
         dlsym(m_libXBMC_addon, "XBMC_queue_notification");
       if (XBMC_queue_notification == NULL) { fprintf(stderr, "Unable to assign function %s\n", dlerror()); return false; }
@@ -338,16 +344,6 @@ namespace ADDON
     }
 
     /*!
-    * @brief Translates a special protocol folder.
-    * @param source The file / folder to translate.
-    * @return The string translated to resolved path. Must be freed by calling FreeString() when done.
-    */
-    char *TranslateSpecialProtocol(const char *source)
-    {
-      return XBMC_translate_special(m_Handle, m_Callbacks, source);
-    }
-
-    /*!
      * @brief Queue a notification in the GUI.
      * @param type The message type.
      * @param format The format of the message to pass to display in XBMC.
@@ -685,7 +681,6 @@ namespace ADDON
     void (*XBMC_unregister_me)(void *HANDLE, void* CB);
     void (*XBMC_log)(void *HANDLE, void* CB, const addon_log_t loglevel, const char *msg);
     bool (*XBMC_get_setting)(void *HANDLE, void* CB, const char* settingName, void *settingValue);
-    char*(*XBMC_translate_special)(void *HANDLE, void* CB, const char* source);
     void (*XBMC_queue_notification)(void *HANDLE, void* CB, const queue_msg_t type, const char *msg);
     bool (*XBMC_wake_on_lan)(void *HANDLE, void* CB, const char* mac);
     char* (*XBMC_unknown_to_utf8)(void *HANDLE, void* CB, const char* str);
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/libXBMC_pvr.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/libXBMC_pvr.h
index 700f912..3e3d479 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/libXBMC_pvr.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/libXBMC_pvr.h
@@ -35,9 +35,7 @@
 #endif
 
 #define DVD_TIME_BASE 1000000
-
-//TODO original definition is in DVDClock.h
-#define DVD_NOPTS_VALUE 0xFFF0000000000000
+#define DVD_NOPTS_VALUE    (-1LL<<52) // should be possible to represent in both double and __int64
 
 class CHelper_libXBMC_pvr
 {
diff --git a/xbmc/cdrip/EncoderFFmpeg.cpp b/xbmc/cdrip/EncoderFFmpeg.cpp
index bdd28db..81e9c63 100644
--- a/xbmc/cdrip/EncoderFFmpeg.cpp
+++ b/xbmc/cdrip/EncoderFFmpeg.cpp
@@ -316,13 +316,16 @@ bool CEncoderFFmpeg::WriteFrame()
 
   if (got_output)
   {
+    if (m_CodecCtx->coded_frame && m_CodecCtx->coded_frame->pts != AV_NOPTS_VALUE)
+      m_Pkt.pts = av_rescale_q(m_CodecCtx->coded_frame->pts, m_Stream->time_base, m_CodecCtx->time_base);
+
     if (av_write_frame(m_Format, &m_Pkt) < 0) {
       CLog::Log(LOGERROR, "CEncoderFFMmpeg::WriteFrame - Failed to write the frame data");
       return false;
     }
   }
 
-  av_packet_unref(&m_Pkt);
+  av_free_packet(&m_Pkt);
 
   return true;
 }
diff --git a/xbmc/cores/AudioEngine/DSPAddons/ActiveAEDSP.cpp b/xbmc/cores/AudioEngine/DSPAddons/ActiveAEDSP.cpp
index ab78f20..2c78a56 100644
--- a/xbmc/cores/AudioEngine/DSPAddons/ActiveAEDSP.cpp
+++ b/xbmc/cores/AudioEngine/DSPAddons/ActiveAEDSP.cpp
@@ -21,7 +21,6 @@
 #include "ActiveAEDSP.h"
 
 #include <utility>
-#include <functional>
 
 extern "C" {
 #include "libavutil/channel_layout.h"
@@ -64,7 +63,9 @@ using KODI::MESSAGING::HELPERS::DialogResponse;
 /*! @name Master audio dsp control class */
 //@{
 CActiveAEDSP::CActiveAEDSP()
-  : m_isActive(false)
+  : CThread("ActiveAEDSP")
+  , m_isActive(false)
+  , m_noAddonWarningDisplayed(false)
   , m_usedProcessesCnt(0)
   , m_activeProcessId(-1)
   , m_isValidAudioDSPSettings(false)
@@ -74,31 +75,42 @@ CActiveAEDSP::CActiveAEDSP()
 
 CActiveAEDSP::~CActiveAEDSP()
 {
+  /* Deactivate all present dsp addons */
   Deactivate();
-  CAddonMgr::GetInstance().UnregisterAddonMgrCallback(ADDON_ADSPDLL);
-  CSettings::GetInstance().UnregisterCallback(this);
   CLog::Log(LOGDEBUG, "ActiveAE DSP - destroyed");
 }
 
-void CActiveAEDSP::Init(void)
+CActiveAEDSP &CActiveAEDSP::GetInstance()
 {
-  std::set<std::string> settingSet;
-  settingSet.insert(CSettings::SETTING_AUDIOOUTPUT_DSPADDONSENABLED);
-  settingSet.insert(CSettings::SETTING_AUDIOOUTPUT_DSPSETTINGS);
-  settingSet.insert(CSettings::SETTING_AUDIOOUTPUT_DSPRESETDB);
-  CSettings::GetInstance().RegisterCallback(this, settingSet);
-
-  CAddonMgr::GetInstance().RegisterAddonMgrCallback(ADDON_ADSPDLL, this);
-
-  if (CSettings::GetInstance().GetBool(CSettings::SETTING_AUDIOOUTPUT_DSPADDONSENABLED))
-    Activate();
+  static CActiveAEDSP activeAEDSPManagerInstance;
+  return activeAEDSPManagerInstance;
 }
 //@}
 
 /*! @name initialization and configuration methods */
 //@{
-void CActiveAEDSP::Activate(void)
+class CActiveAEDSPStartJob : public CJob
 {
+public:
+  CActiveAEDSPStartJob() {}
+  ~CActiveAEDSPStartJob(void) {}
+
+  bool DoWork(void)
+  {
+    CActiveAEDSP::GetInstance().Activate(false);
+    return true;
+  }
+};
+
+void CActiveAEDSP::Activate(bool bAsync /* = false */)
+{
+  if (bAsync)
+  {
+    CActiveAEDSPStartJob *job = new CActiveAEDSPStartJob();
+    CJobManager::GetInstance().AddJob(job, NULL);
+    return;
+  }
+
   /* first stop and remove any audio dsp add-on's */
   Deactivate();
 
@@ -106,8 +118,17 @@ void CActiveAEDSP::Activate(void)
 
   CLog::Log(LOGNOTICE, "ActiveAE DSP - starting");
 
-  UpdateAddons();
-  m_isActive = true;
+  /* don't start if Settings->System->Audio->Audio DSP isn't checked */
+  if (!CSettings::GetInstance().GetBool(CSettings::SETTING_AUDIOOUTPUT_DSPADDONSENABLED))
+    return;
+
+  Cleanup();
+
+  /* create and open database */
+  m_databaseDSP.Open();
+
+  Create();
+  SetPriority(-1);
 }
 
 class CActiveAEDSPModeUpdateJob : public CJob
@@ -118,7 +139,7 @@ public:
 
   bool DoWork(void)
   {
-    CServiceBroker::GetADSP().TriggerModeUpdate(false);
+    CActiveAEDSP::GetInstance().TriggerModeUpdate(false);
     return true;
   }
 };
@@ -162,10 +183,17 @@ void CActiveAEDSP::Deactivate(void)
   if (!m_isActive)
     return;
 
+  /* stop thread */
+  StopThread();
+
   CSingleLock lock(m_critSection);
 
   CLog::Log(LOGNOTICE, "ActiveAE DSP - stopping");
 
+  /* destroy all addons */
+  for (AE_DSP_ADDONMAP_ITR itr = m_addonMap.begin(); itr != m_addonMap.end(); ++itr)
+    itr->second->Destroy();
+
   m_addonMap.clear();
 
   /* unload all data */
@@ -185,6 +213,8 @@ void CActiveAEDSP::Cleanup(void)
   m_isActive                  = false;
   m_usedProcessesCnt          = 0;
   m_isValidAudioDSPSettings   = false;
+  m_noAddonWarningDisplayed   = false;
+  m_outdatedAddons.clear();
 
   for (unsigned int i = 0; i < AE_DSP_MODE_TYPE_MAX; ++i)
     m_modes[i].clear();
@@ -197,6 +227,26 @@ bool CActiveAEDSP::InstallAddonAllowed(const std::string &strAddonId) const
          m_usedProcessesCnt == 0;
 }
 
+void CActiveAEDSP::MarkAsOutdated(const std::string& strAddonId)
+{
+  if (IsActivated() && CSettings::GetInstance().GetInt(CSettings::SETTING_ADDONS_AUTOUPDATES) == AUTO_UPDATES_ON)
+  {
+    CSingleLock lock(m_critSection);
+    m_outdatedAddons.push_back(strAddonId);
+  }
+}
+
+bool CActiveAEDSP::HasOutdatedAddons(std::vector<std::string> &outdatedAddons)
+{
+  CSingleLock lock(m_critSection);
+  if (!m_outdatedAddons.empty())
+  {
+    outdatedAddons = m_outdatedAddons;
+    return true;
+  }
+  return false;
+}
+
 void CActiveAEDSP::ResetDatabase(void)
 {
   CLog::Log(LOGNOTICE, "ActiveAE DSP - clearing the audio DSP database");
@@ -207,7 +257,7 @@ void CActiveAEDSP::ResetDatabase(void)
     CApplicationMessenger::GetInstance().PostMsg(TMSG_MEDIA_STOP);
   }
 
-  /* stop the system */
+  /* stop the thread */
   Deactivate();
 
   if (m_databaseDSP.Open())
@@ -221,10 +271,13 @@ void CActiveAEDSP::ResetDatabase(void)
 
   CLog::Log(LOGNOTICE, "ActiveAE DSP - database cleared");
 
-  CLog::Log(LOGNOTICE, "ActiveAE DSP - restarting the audio DSP handler");
-  m_databaseDSP.Open();
-  Cleanup();
-  Activate();
+  if (CSettings::GetInstance().GetBool(CSettings::SETTING_AUDIOOUTPUT_DSPADDONSENABLED))
+  {
+    CLog::Log(LOGNOTICE, "ActiveAE DSP - restarting the audio DSP handler");
+    m_databaseDSP.Open();
+    Cleanup();
+    Activate();
+  }
 }
 //@}
 
@@ -236,7 +289,6 @@ void CActiveAEDSP::OnSettingAction(const CSetting *setting)
     return;
 
   const std::string &settingId = setting->GetId();
-
   if (settingId == CSettings::SETTING_AUDIOOUTPUT_DSPSETTINGS)
   {
     if (IsActivated())
@@ -290,12 +342,10 @@ int CActiveAEDSP::GetAudioDSPAddonId(const AddonPtr &addon) const
 {
   CSingleLock lock(m_critUpdateSection);
 
-  for (auto &entry : m_addonMap)
+  for (AE_DSP_ADDONMAP_CITR citr = m_addonMap.begin(); citr != m_addonMap.end(); ++citr)
   {
-    if (entry.second->ID() == addon->ID())
-    {
-      return entry.first;
-    }
+    if (citr->second->ID() == addon->ID())
+      return citr->first;
   }
 
   return -1;
@@ -370,7 +420,7 @@ bool CActiveAEDSP::TranslateCharInfo(DWORD dwInfo, std::string &strValue) const
       int modeId = activeMaster->ModeID();
       if (modeId == AE_DSP_MASTER_MODE_ID_PASSOVER || modeId >= AE_DSP_MASTER_MODE_ID_INTERNAL_TYPES)
         strValue = g_localizeStrings.Get(activeMaster->ModeName());
-      else if (CServiceBroker::GetADSP().GetAudioDSPAddon(activeMaster->AddonID(), addon))
+      else if (CActiveAEDSP::GetInstance().GetAudioDSPAddon(activeMaster->AddonID(), addon))
         strValue = g_localizeStrings.GetAddonString(addon->ID(), activeMaster->ModeName());
     }
     break;
@@ -559,57 +609,244 @@ bool CActiveAEDSP::StopAudioDSPAddon(AddonPtr addon, bool bRestart)
   return false;
 }
 
-void CActiveAEDSP::UpdateAddons()
+bool CActiveAEDSP::UpdateAndInitialiseAudioDSPAddons(bool bInitialiseAllAudioDSPAddons /* = false */)
 {
-  VECADDONS addons;
-  AE_DSP_ADDON dspAddon;
-
-  CAddonMgr::GetInstance().GetAddons(addons, ADDON_ADSPDLL);
+  bool bReturn(true);
+  VECADDONS map;
+  VECADDONS disableAddons;
+  {
+    CSingleLock lock(m_critUpdateSection);
+    map = m_addons;
+  }
 
-  if (addons.empty())
-    return;
+  if (map.empty())
+    return false;
 
-  for (auto &addon : addons)
+  for (unsigned iAddonPtr = 0; iAddonPtr < map.size(); ++iAddonPtr)
   {
-    bool bEnabled = !CAddonMgr::GetInstance().IsAddonDisabled(addon->ID());
-    if (bEnabled && (!IsKnownAudioDSPAddon(addon) || !IsReadyAudioDSPAddon(addon)))
+    const AddonPtr dspAddon = map.at(iAddonPtr);
+    bool bEnabled = !CAddonMgr::GetInstance().IsAddonDisabled(dspAddon->ID());
+
+    if (!bEnabled && IsKnownAudioDSPAddon(dspAddon))
     {
-      std::hash<std::string> hasher;
-      int iAddonId = static_cast<int>(hasher(addon->ID()));
-      if (iAddonId < 0)
-        iAddonId = -iAddonId;
+      CSingleLock lock(m_critUpdateSection);
+      /* stop the dsp addon and remove it from the db */
+      StopAudioDSPAddon(dspAddon, false);
+      VECADDONS::iterator addonPtr = std::find(m_addons.begin(), m_addons.end(), dspAddon);
+      if (addonPtr != m_addons.end())
+        m_addons.erase(addonPtr);
 
-      /* create and open database */
-      if (!m_databaseDSP.IsOpen())
-        m_databaseDSP.Open();
+    }
+    else if (bEnabled && (bInitialiseAllAudioDSPAddons || !IsKnownAudioDSPAddon(dspAddon) || !IsReadyAudioDSPAddon(dspAddon)))
+    {
+      bool bDisabled(false);
 
-      if (IsKnownAudioDSPAddon(addon))
+      /* register the add-on in the audio dsp db, and create the CActiveAEDSPAddon instance */
+      int iAddonId = RegisterAudioDSPAddon(dspAddon);
+      if (iAddonId < 0)
       {
-        AE_DSP_ADDON dspAddon;
-        GetAudioDSPAddon(iAddonId, dspAddon);
-        dspAddon->Create(iAddonId);
+        /* failed to register or create the add-on, disable it */
+        CLog::Log(LOGWARNING, "ActiveAE DSP - %s - failed to register add-on %s, disabling it", __FUNCTION__, dspAddon->Name().c_str());
+        disableAddons.push_back(dspAddon);
+        bDisabled = true;
       }
       else
       {
-        AE_DSP_ADDON dspAddon = std::dynamic_pointer_cast<CActiveAEDSPAddon>(addon);
-        if (!dspAddon)
+        ADDON_STATUS status(ADDON_STATUS_UNKNOWN);
+        AE_DSP_ADDON addon;
         {
-          CLog::Log(LOGERROR, "CActiveAEDSP::UpdateAndInitialiseAddons - severe error, incorrect add type");
-          continue;
+          CSingleLock lock(m_critUpdateSection);
+          if (!GetAudioDSPAddon(iAddonId, addon))
+          {
+            CLog::Log(LOGWARNING, "ActiveAE DSP - %s - failed to find add-on %s, disabling it", __FUNCTION__, dspAddon->Name().c_str());
+            disableAddons.push_back(dspAddon);
+            bDisabled = true;
+          }
         }
 
-        dspAddon.get()->Create(iAddonId);
-        // register the add-on
-        if (m_addonMap.find(iAddonId) == m_addonMap.end())
+        /* re-check the enabled status. newly installed dsps get disabled when they're added to the db */
+        if (!bDisabled && !CAddonMgr::GetInstance().IsAddonDisabled(addon->ID()) && (status = addon->Create(iAddonId)) != ADDON_STATUS_OK)
         {
-          m_addonMap.insert(std::make_pair(iAddonId, dspAddon));
-          m_addonNameIds.insert(make_pair(addon->ID(), iAddonId));
+          CLog::Log(LOGWARNING, "ActiveAE DSP - %s - failed to create add-on %s, status = %d", __FUNCTION__, dspAddon->Name().c_str(), status);
+          if (!addon.get() || !addon->DllLoaded() || status == ADDON_STATUS_PERMANENT_FAILURE)
+          {
+            /* failed to load the dll of this add-on, disable it */
+            CLog::Log(LOGWARNING, "ActiveAE DSP - %s - failed to load the dll for add-on %s, disabling it", __FUNCTION__, dspAddon->Name().c_str());
+            disableAddons.push_back(dspAddon);
+            bDisabled = true;
+          }
         }
       }
+
+      if (bDisabled && IsActivated())
+        CGUIDialogOK::ShowAndGetInput(24070, 24071, 16029, 0);
+    }
+  }
+
+  /* disable add-ons that failed to initialise */
+  if (!disableAddons.empty())
+  {
+    CSingleLock lock(m_critUpdateSection);
+    for (VECADDONS::iterator itr = disableAddons.begin(); itr != disableAddons.end(); ++itr)
+    {
+      /* disable in the add-on db */
+      CAddonMgr::GetInstance().DisableAddon((*itr)->ID());
+
+      /* remove from the audio dsp add-on list */
+      VECADDONS::iterator addonPtr = std::find(m_addons.begin(), m_addons.end(), *itr);
+      if (addonPtr != m_addons.end())
+        m_addons.erase(addonPtr);
     }
   }
 
-  TriggerModeUpdate();
+  return bReturn;
+}
+
+bool CActiveAEDSP::UpdateAddons(void)
+{
+  VECADDONS addons;
+  AE_DSP_ADDON dspAddon;
+  bool bReturn(CAddonMgr::GetInstance().GetAddons(addons, ADDON_ADSPDLL));
+  size_t usableAddons;
+
+  if (bReturn)
+  {
+    CSingleLock lock(m_critUpdateSection);
+    m_addons = addons;
+  }
+
+  usableAddons = m_addons.size();
+
+  /* handle "new" addons which aren't yet in the db - these have to be added first */
+  for (VECADDONS::const_iterator itr = addons.begin(); itr != addons.end(); ++itr)
+  {
+    dspAddon = std::dynamic_pointer_cast<CActiveAEDSPAddon>(*itr);
+
+    if (RegisterAudioDSPAddon(dspAddon) < 0)
+    {
+      CAddonMgr::GetInstance().DisableAddon(dspAddon->ID());
+      --usableAddons;
+    }
+  }
+
+  if ((!bReturn || usableAddons == 0) && !m_noAddonWarningDisplayed &&
+      !CAddonMgr::GetInstance().HasInstalledAddons(ADDON_ADSPDLL) &&
+      IsActivated())
+  {
+    // No audio DSP add-ons could be found
+    // You need a add-on installed for the process of audio DSP signal. System becomes disabled.
+    m_noAddonWarningDisplayed = true;
+    CGUIDialogOK::ShowAndGetInput(CVariant{19273}, CVariant{19274});
+    CSettings::GetInstance().SetBool(CSettings::SETTING_AUDIOOUTPUT_DSPADDONSENABLED, false);
+    CGUIMessage msg(GUI_MSG_UPDATE, WINDOW_SETTINGS_SYSTEM, 0);
+    CApplicationMessenger::GetInstance().SendGUIMessage(msg);
+    CApplicationMessenger::GetInstance().PostMsg(TMSG_SETAUDIODSPSTATE, ACTIVE_AE_DSP_STATE_OFF);
+  }
+
+  return bReturn;
+}
+
+void CActiveAEDSP::Notify(const Observable &obs, const ObservableMessage msg)
+{
+  if (msg == ObservableMessageAddons)
+    UpdateAddons();
+}
+
+void CActiveAEDSP::Process(void)
+{
+  bool bCheckedEnabledAddonsOnStartup(false);
+
+  CAddonMgr::GetInstance().RegisterAddonMgrCallback(ADDON_ADSPDLL, this);
+  CAddonMgr::GetInstance().RegisterObserver(this);
+
+  m_isActive = true;
+
+  UpdateAddons();
+
+  while (!g_application.m_bStop && !m_bStop)
+  {
+    UpdateAndInitialiseAudioDSPAddons();
+
+    if (!bCheckedEnabledAddonsOnStartup)
+    {
+      bCheckedEnabledAddonsOnStartup = true;
+      if (HasEnabledAudioDSPAddons())
+        TriggerModeUpdate(false);
+      else if (!m_noAddonWarningDisplayed)
+        ShowDialogNoAddonsEnabled();
+    }
+    else
+    {
+      Sleep(1000);
+    }
+  }
+
+  m_isActive = false;
+}
+
+void CActiveAEDSP::ShowDialogNoAddonsEnabled(void)
+{
+  if (!IsActivated())
+    return;
+
+  CGUIDialogOK::ShowAndGetInput(15048, 15049, 0, 0);
+
+  std::vector<std::string> params;
+  params.push_back("addons://disabled/kodi.adsp");
+  params.push_back("return");
+  g_windowManager.ActivateWindow(WINDOW_ADDON_BROWSER, params);
+}
+
+int CActiveAEDSP::RegisterAudioDSPAddon(AddonPtr addon)
+{
+  int iAddonId(-1);
+
+  if (CAddonMgr::GetInstance().IsAddonDisabled(addon->ID()))
+    return -1;
+
+  CLog::Log(LOGDEBUG, "ActiveAE DSP - %s - registering add-on '%s'", __FUNCTION__, addon->Name().c_str());
+
+  if (!m_databaseDSP.IsOpen())
+  {
+    CLog::Log(LOGERROR, "ActiveAE DSP - %s - failed to get the database", __FUNCTION__);
+    return -1;
+  }
+
+  /* check whether we already know this dsp addon */
+  iAddonId = m_databaseDSP.GetAudioDSPAddonId(addon->ID());
+
+  /* try to register the new dsp addon in the db */
+  if (iAddonId < 0)
+  {
+    if ((iAddonId = m_databaseDSP.Persist(addon)) < 0)
+    {
+      CLog::Log(LOGERROR, "ActiveAE DSP - %s - can't add dsp addon '%s' to the database", __FUNCTION__, addon->Name().c_str());
+      return -1;
+    }
+  }
+
+  AE_DSP_ADDON dspAddon;
+  /* load and initialise the dsp addon libraries */
+  {
+    CSingleLock lock(m_critSection);
+    AE_DSP_ADDONMAP_CITR existingAddon = m_addonMap.find(iAddonId);
+    if (existingAddon != m_addonMap.end())
+    {
+      /* return existing addon */
+      dspAddon = existingAddon->second;
+    }
+    else
+    {
+      /* create a new addon instance */
+      dspAddon = std::dynamic_pointer_cast<CActiveAEDSPAddon> (addon);
+      m_addonMap.insert(std::make_pair(iAddonId, dspAddon));
+    }
+  }
+
+  if (iAddonId < 0)
+    CLog::Log(LOGERROR, "ActiveAE DSP - %s - can't register dsp add-on '%s'", __FUNCTION__, addon->Name().c_str());
+
+  return iAddonId;
 }
 //@}
 
@@ -727,11 +964,21 @@ bool CActiveAEDSP::IsReadyAudioDSPAddon(const AddonPtr &addon)
   return false;
 }
 
-int CActiveAEDSP::GetAddonId(const std::string& strId) const
+int CActiveAEDSP::GetReadyAddons(AE_DSP_ADDONMAP &addons) const
 {
+  int iReturn(0);
   CSingleLock lock(m_critSection);
-  std::map<std::string, int>::const_iterator it = m_addonNameIds.find(strId);
-  return it != m_addonNameIds.end() ? it->second : -1;
+
+  for (AE_DSP_ADDONMAP_CITR citr = m_addonMap.begin(); citr != m_addonMap.end(); ++citr)
+  {
+    if (citr->second->ReadyToUse())
+    {
+      addons.insert(std::make_pair(citr->second->GetID(), citr->second));
+      ++iReturn;
+    }
+  }
+
+  return iReturn;
 }
 
 bool CActiveAEDSP::GetReadyAudioDSPAddon(int iAddonId, AE_DSP_ADDON &addon) const
diff --git a/xbmc/cores/AudioEngine/DSPAddons/ActiveAEDSP.h b/xbmc/cores/AudioEngine/DSPAddons/ActiveAEDSP.h
index cd3b4ed..f023ee1 100644
--- a/xbmc/cores/AudioEngine/DSPAddons/ActiveAEDSP.h
+++ b/xbmc/cores/AudioEngine/DSPAddons/ActiveAEDSP.h
@@ -19,7 +19,7 @@
  *
  */
 
-#include "ServiceBroker.h"
+#include "addons/AddonDatabase.h"
 #include "cores/AudioEngine/Utils/AEAudioFormat.h"
 #include "cores/AudioEngine/Interfaces/AE.h"
 #include "threads/CriticalSection.h"
@@ -53,35 +53,44 @@ namespace ActiveAE
   typedef std::map< int, AE_DSP_ADDON >::iterator         AE_DSP_ADDONMAP_ITR;
   typedef std::map< int, AE_DSP_ADDON >::const_iterator   AE_DSP_ADDONMAP_CITR;
 
+  #define g_AEDSPManager       CActiveAEDSP::GetInstance()
+
   //@{
   /*!
    * Static dsp handling class
    */
   class CActiveAEDSP : public ADDON::IAddonMgrCallback,
-                       public ISettingCallback
+                       public ISettingCallback,
+                       public Observer,
+                       private CThread
   {
   /*! @name Master audio dsp control class */
   //@{
-  public:
+  private:
     /*!
      * @brief Create a new CActiveAEDSP instance, which handles all audio DSP related operations in KODI.
      */
     CActiveAEDSP(void);
 
+  public:
     /*!
      * @brief Stop the ActiveAEDSP and destroy all objects it created.
      */
     virtual ~CActiveAEDSP();
 
-    void Init(void);
+    /*!
+     * @brief Get the instance of the ActiveAEDSP.
+     * @return The ActiveAEDSP instance.
+     */
+    static CActiveAEDSP &GetInstance();
   //@}
 
   /*! @name initialization and configuration methods */
   //@{
     /*!
-     * @brief Activate the addon dsp processing.
+     * @brief Activate the addon dsp processing and start the backend info update thread.
      */
-    void Activate(void);
+    void Activate(bool bAsync = false);
 
     /*!
      * @brief Stops dsp processing and the backend info update thread.
@@ -106,6 +115,19 @@ namespace ActiveAE
     bool InstallAddonAllowed(const std::string& strAddonId) const;
 
     /*!
+     * @brief Mark an add-on as outdated so it will be upgrade when it's possible again
+     * @param strAddonId The add-on to mark as outdated
+     */
+    void MarkAsOutdated(const std::string& strAddonId);
+
+    /*!
+     * @brief Mark an add-on as outdated so it will be upgrade when it's possible again
+     * @param outdatedAddons The generated list of outdated add-on's
+     * @return True when outdated addons are present.
+     */
+    bool HasOutdatedAddons(std::vector<std::string> &outdatedAddons);
+
+    /*!
      * @brief Get the audio dsp database pointer.
      * @return The audio dsp database.
      */
@@ -128,6 +150,13 @@ namespace ActiveAE
      * @return True when processing is active
      */
     bool IsProcessing(void) const;
+
+    /*!
+     * @brief Get all ready audio dsp addons.
+     * @param addons Store the active addons in this map.
+     * @return The amount of added audio dsp addons.
+     */
+    int GetReadyAddons(AE_DSP_ADDONMAP &addons) const;
   //@}
 
   /*! @name addon installation callback methods */
@@ -163,6 +192,13 @@ namespace ActiveAE
     bool StopAudioDSPAddon(ADDON::AddonPtr addon, bool bRestart);
 
     /*!
+     * @brief Notify about required messages
+     * @param obs
+     * @param msg The observed message type
+     */
+    void Notify(const Observable &obs, const ObservableMessage msg) override;
+
+    /*!
      * @return The amount of enabled audio dsp addons.
      */
     int EnabledAudioDSPAddonAmount(void) const;
@@ -227,13 +263,6 @@ namespace ActiveAE
      * @return True if it was found, false otherwise.
      */
     bool GetAudioDSPAddonName(int iAddonId, std::string &strName) const;
-
-    /*!
-     * @brief Update add-ons from the AddonManager
-     */
-    void UpdateAddons(void);
-
-    int GetAddonId(const std::string& strId) const;
   //@}
 
   /*! @name GUIInfoManager calls */
@@ -367,6 +396,23 @@ namespace ActiveAE
 
   protected:
     /*!
+     * @brief Thread to which updates the backend information
+     */
+    virtual void Process(void) override;
+
+  private:
+    /*!
+     * @brief Update add-ons from the AddonManager
+     * @return True when updated, false otherwise
+     */
+    bool UpdateAddons(void);
+
+    /*!
+     * @brief Show a dialog to guide new users who have no dsp addons enabled.
+     */
+    void ShowDialogNoAddonsEnabled(void);
+
+    /*!
      * @brief Check whether a dsp addon is registered.
      * @param addon The dsp addon to check.
      * @return True if this addon is registered, false otherwise.
@@ -374,6 +420,21 @@ namespace ActiveAE
     bool IsKnownAudioDSPAddon(const ADDON::AddonPtr& addon) const;
 
     /*!
+     * @brief Check whether there are any new audio dsp add-ons enabled or whether any of the known addons has been disabled.
+     * @param bInitialiseAllAudioDSPAddons True to initialise all dsp addons, false to only initialise new dsp addons.
+     * @return True if all addons were updated successfully, false otherwise.
+     */
+    bool UpdateAndInitialiseAudioDSPAddons(bool bInitialiseAllAudioDSPAddons = false);
+
+    /*!
+     * @brief Initialise and connect a dsp addon.
+     * @param addon The dsp addon to initialise.
+     * @param newRegistration pass in pointer to bool to return whether the client was newly registered.
+     * @return The id of the addon if it was created or found in the existing addon map, -1 otherwise.
+     */
+    int RegisterAudioDSPAddon(ADDON::AddonPtr addon);
+
+    /*!
      * @brief Get the instance of the dsp addon, if it's ready.
      * @param iAddonId The id of the dsp addon to get.
      * @param addon The addon data pointer.
@@ -388,10 +449,11 @@ namespace ActiveAE
      */
     int GetAudioDSPAddonId(const ADDON::AddonPtr& addon) const;
 
-
     static const int        m_StreamTypeNameTable[];                    /*!< Table for stream type strings related to type id */
     bool                    m_isActive;                                 /*!< set to true if all available dsp addons are loaded */
+    ADDON::VECADDONS        m_addons;                                   /*!< List of all currently usable addons */
     AE_DSP_ADDONMAP         m_addonMap;                                 /*!< a map of all known audio dsp addons */
+    bool                    m_noAddonWarningDisplayed;                  /*!< true when a warning was displayed that no add-ons were found, false otherwise */
     CActiveAEDSPDatabase    m_databaseDSP;                              /*!< the database for all audio DSP related data */
     CCriticalSection        m_critSection;                              /*!< Critical lock for control functions */
     CCriticalSection        m_critUpdateSection;                        /*!< Critical lock for update thread related functions */
@@ -400,7 +462,7 @@ namespace ActiveAE
     unsigned int            m_activeProcessId;                          /*!< The currently active audio stream id of a playing file source */
     bool                    m_isValidAudioDSPSettings;                  /*!< if settings load was successfull it becomes true */
     AE_DSP_MODELIST         m_modes[AE_DSP_MODE_TYPE_MAX];              /*!< list of currently used dsp processing calls */
-    std::map<std::string, int> m_addonNameIds; /*!< map add-on names to IDs */
+    std::vector<std::string> m_outdatedAddons;
   };
   //@}
 }
diff --git a/xbmc/cores/AudioEngine/DSPAddons/ActiveAEDSPAddon.cpp b/xbmc/cores/AudioEngine/DSPAddons/ActiveAEDSPAddon.cpp
index 62542fc..3f0b6c0 100644
--- a/xbmc/cores/AudioEngine/DSPAddons/ActiveAEDSPAddon.cpp
+++ b/xbmc/cores/AudioEngine/DSPAddons/ActiveAEDSPAddon.cpp
@@ -49,20 +49,23 @@ CActiveAEDSPAddon::~CActiveAEDSPAddon(void)
 
 void CActiveAEDSPAddon::OnDisabled()
 {
-  CServiceBroker::GetADSP().UpdateAddons();
+  // restart the ADSP manager if we're disabling a client
+  if (CActiveAEDSP::GetInstance().IsActivated())
+    CActiveAEDSP::GetInstance().Activate(true);
 }
 
 void CActiveAEDSPAddon::OnEnabled()
 {
-  CServiceBroker::GetADSP().UpdateAddons();
+  // restart the ADSP manager if we're enabling a client
+  CActiveAEDSP::GetInstance().Activate(true);
 }
 
 AddonPtr CActiveAEDSPAddon::GetRunningInstance() const
 {
-  if (CServiceBroker::GetADSP().IsActivated())
+  if (CActiveAEDSP::GetInstance().IsActivated())
   {
     AddonPtr adspAddon;
-    if (CServiceBroker::GetADSP().GetAudioDSPAddon(ID(), adspAddon))
+    if (CActiveAEDSP::GetInstance().GetAudioDSPAddon(ID(), adspAddon))
       return adspAddon;
   }
   return CAddon::GetRunningInstance();
@@ -70,29 +73,33 @@ AddonPtr CActiveAEDSPAddon::GetRunningInstance() const
 
 void CActiveAEDSPAddon::OnPreInstall()
 {
-  CServiceBroker::GetADSP().UpdateAddons();
+  // stop the ADSP manager, so running ADSP add-ons are stopped and closed
+  CActiveAEDSP::GetInstance().Deactivate();
 }
 
 void CActiveAEDSPAddon::OnPostInstall(bool restart, bool update)
 {
-  CServiceBroker::GetADSP().UpdateAddons();
+  // (re)start the ADSP manager
+  CActiveAEDSP::GetInstance().Activate(true);
 }
 
 void CActiveAEDSPAddon::OnPreUnInstall()
 {
   // stop the ADSP manager, so running ADSP add-ons are stopped and closed
-  CServiceBroker::GetADSP().Deactivate();
+  CActiveAEDSP::GetInstance().Deactivate();
 }
 
 void CActiveAEDSPAddon::OnPostUnInstall()
 {
-  CServiceBroker::GetADSP().UpdateAddons();
+  if (CSettings::GetInstance().GetBool(CSettings::SETTING_AUDIOOUTPUT_DSPADDONSENABLED))
+    CActiveAEDSP::GetInstance().Activate(true);
 }
 
 bool CActiveAEDSPAddon::CanInstall()
 {
-  if (!CServiceBroker::GetADSP().InstallAddonAllowed(ID()))
+  if (!CActiveAEDSP::GetInstance().InstallAddonAllowed(ID()))
   {
+    CActiveAEDSP::GetInstance().MarkAsOutdated(ID());
     return false;
   }
   return CAddon::CanInstall();
diff --git a/xbmc/cores/AudioEngine/DSPAddons/ActiveAEDSPDatabase.cpp b/xbmc/cores/AudioEngine/DSPAddons/ActiveAEDSPDatabase.cpp
index 0ec4094..baafc75 100644
--- a/xbmc/cores/AudioEngine/DSPAddons/ActiveAEDSPDatabase.cpp
+++ b/xbmc/cores/AudioEngine/DSPAddons/ActiveAEDSPDatabase.cpp
@@ -335,7 +335,7 @@ int CActiveAEDSPDatabase::GetModes(AE_DSP_MODELIST &results, int modeType)
         CLog::Log(LOGDEBUG, "Audio DSP - %s - mode '%s' loaded from the database", __FUNCTION__, mode->m_strModeName.c_str());
 #endif
         AE_DSP_ADDON addon;
-        if (CServiceBroker::GetADSP().GetAudioDSPAddon(mode->m_iAddonId, addon))
+        if (CActiveAEDSP::GetInstance().GetAudioDSPAddon(mode->m_iAddonId, addon))
           results.push_back(AE_DSP_MODEPAIR(mode, addon));
 
         m_pDS->next();
diff --git a/xbmc/cores/AudioEngine/DSPAddons/ActiveAEDSPMode.cpp b/xbmc/cores/AudioEngine/DSPAddons/ActiveAEDSPMode.cpp
index 738e494..0959b3a 100644
--- a/xbmc/cores/AudioEngine/DSPAddons/ActiveAEDSPMode.cpp
+++ b/xbmc/cores/AudioEngine/DSPAddons/ActiveAEDSPMode.cpp
@@ -338,7 +338,7 @@ int CActiveAEDSPMode::AddUpdate(bool force)
       return m_iModeId;
   }
 
-  CActiveAEDSPDatabase *database = CServiceBroker::GetADSP().GetADSPDatabase();
+  CActiveAEDSPDatabase *database = CActiveAEDSP::GetInstance().GetADSPDatabase();
   if (!database || !database->IsOpen())
   {
     CLog::Log(LOGERROR, "ActiveAE DSP - failed to open the database");
@@ -353,7 +353,7 @@ int CActiveAEDSPMode::AddUpdate(bool force)
 
 bool CActiveAEDSPMode::Delete(void)
 {
-  CActiveAEDSPDatabase *database = CServiceBroker::GetADSP().GetADSPDatabase();
+  CActiveAEDSPDatabase *database = CActiveAEDSP::GetInstance().GetADSPDatabase();
   if (!database || !database->IsOpen())
   {
     CLog::Log(LOGERROR, "ActiveAE DSP - failed to open the database");
@@ -365,7 +365,7 @@ bool CActiveAEDSPMode::Delete(void)
 
 bool CActiveAEDSPMode::IsKnown(void) const
 {
-  CActiveAEDSPDatabase *database = CServiceBroker::GetADSP().GetADSPDatabase();
+  CActiveAEDSPDatabase *database = CActiveAEDSP::GetInstance().GetADSPDatabase();
   if (!database || !database->IsOpen())
   {
     CLog::Log(LOGERROR, "ActiveAE DSP - failed to open the database");
diff --git a/xbmc/cores/AudioEngine/DSPAddons/ActiveAEDSPProcess.cpp b/xbmc/cores/AudioEngine/DSPAddons/ActiveAEDSPProcess.cpp
index d8aecf8..8fcd39c 100644
--- a/xbmc/cores/AudioEngine/DSPAddons/ActiveAEDSPProcess.cpp
+++ b/xbmc/cores/AudioEngine/DSPAddons/ActiveAEDSPProcess.cpp
@@ -305,7 +305,7 @@ bool CActiveAEDSPProcess::Create(const AEAudioFormat &inputFormat, const AEAudio
    * Load all selected processing types, stored in a database and available from addons
    */
   AE_DSP_ADDONMAP addonMap;
-  if (CServiceBroker::GetADSP().GetEnabledAudioDSPAddons(addonMap) > 0)
+  if (CActiveAEDSP::GetInstance().GetEnabledAudioDSPAddons(addonMap) > 0)
   {
     int foundInputResamplerId = -1; /*!< Used to prevent double call of StreamCreate if input stream resampling is together with outer processing types */
 
@@ -314,7 +314,7 @@ bool CActiveAEDSPProcess::Create(const AEAudioFormat &inputFormat, const AEAudio
      * load one allowed before master processing & final resample addon
      */
     CLog::Log(LOGDEBUG, "  ---- DSP input resample addon ---");
-    const AE_DSP_MODELIST listInputResample = CServiceBroker::GetADSP().GetAvailableModes(AE_DSP_MODE_TYPE_INPUT_RESAMPLE);
+    const AE_DSP_MODELIST listInputResample = CActiveAEDSP::GetInstance().GetAvailableModes(AE_DSP_MODE_TYPE_INPUT_RESAMPLE);
     if (listInputResample.empty())
       CLog::Log(LOGDEBUG, "  | - no input resample addon present or enabled");
     for (unsigned int i = 0; i < listInputResample.size(); ++i)
@@ -406,7 +406,7 @@ bool CActiveAEDSPProcess::Create(const AEAudioFormat &inputFormat, const AEAudio
      * Load all required pre process dsp addon functions
      */
     CLog::Log(LOGDEBUG, "  ---- DSP active pre process modes ---");
-    const AE_DSP_MODELIST listPreProcess = CServiceBroker::GetADSP().GetAvailableModes(AE_DSP_MODE_TYPE_PRE_PROCESS);
+    const AE_DSP_MODELIST listPreProcess = CActiveAEDSP::GetInstance().GetAvailableModes(AE_DSP_MODE_TYPE_PRE_PROCESS);
     for (unsigned int i = 0; i < listPreProcess.size(); ++i)
     {
       CActiveAEDSPModePtr pMode = listPreProcess[i].first;
@@ -436,7 +436,7 @@ bool CActiveAEDSPProcess::Create(const AEAudioFormat &inputFormat, const AEAudio
      * Load all available master modes from addons and put together with database
      */
     CLog::Log(LOGDEBUG, "  ---- DSP active master process modes ---");
-    const AE_DSP_MODELIST listMasterProcess = CServiceBroker::GetADSP().GetAvailableModes(AE_DSP_MODE_TYPE_MASTER_PROCESS);
+    const AE_DSP_MODELIST listMasterProcess = CActiveAEDSP::GetInstance().GetAvailableModes(AE_DSP_MODE_TYPE_MASTER_PROCESS);
     for (unsigned int i = 0; i < listMasterProcess.size(); ++i)
     {
       CActiveAEDSPModePtr pMode = listMasterProcess[i].first;
@@ -510,7 +510,7 @@ bool CActiveAEDSPProcess::Create(const AEAudioFormat &inputFormat, const AEAudio
      * Load all required post process dsp addon functions
      */
     CLog::Log(LOGDEBUG, "  ---- DSP active post process modes ---");
-    const AE_DSP_MODELIST listPostProcess = CServiceBroker::GetADSP().GetAvailableModes(AE_DSP_MODE_TYPE_POST_PROCESS);
+    const AE_DSP_MODELIST listPostProcess = CActiveAEDSP::GetInstance().GetAvailableModes(AE_DSP_MODE_TYPE_POST_PROCESS);
     for (unsigned int i = 0; i < listPostProcess.size(); ++i)
     {
       CActiveAEDSPModePtr pMode = listPostProcess[i].first;
@@ -543,7 +543,7 @@ bool CActiveAEDSPProcess::Create(const AEAudioFormat &inputFormat, const AEAudio
     CLog::Log(LOGDEBUG, "  ---- DSP post resample addon ---");
     if (m_addonSettings.iProcessSamplerate != m_outputFormat.m_sampleRate)
     {
-      const AE_DSP_MODELIST listOutputResample = CServiceBroker::GetADSP().GetAvailableModes(AE_DSP_MODE_TYPE_OUTPUT_RESAMPLE);
+      const AE_DSP_MODELIST listOutputResample = CActiveAEDSP::GetInstance().GetAvailableModes(AE_DSP_MODE_TYPE_OUTPUT_RESAMPLE);
       if (listOutputResample.empty())
         CLog::Log(LOGDEBUG, "  | - no final post resample addon present or enabled, becomes performed by KODI");
       for (unsigned int i = 0; i < listOutputResample.size(); ++i)
@@ -820,7 +820,7 @@ void CActiveAEDSPProcess::Destroy()
 {
   CSingleLock lock(m_restartSection);
 
-  if (!CServiceBroker::GetADSP().IsActivated())
+  if (!CActiveAEDSP::GetInstance().IsActivated())
     return;
 
   for (AE_DSP_ADDONMAP_ITR itr = m_usedMap.begin(); itr != m_usedMap.end(); ++itr)
diff --git a/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.cpp b/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.cpp
index 90474a5..8f24a5d 100644
--- a/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.cpp
+++ b/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.cpp
@@ -296,7 +296,7 @@ int CAEEncoderFFmpeg::Encode(uint8_t *in, int in_size, uint8_t *out, int out_siz
   int size = m_Pkt.size;
 
   /* free the packet */
-  av_packet_unref(&m_Pkt);
+  av_free_packet(&m_Pkt);
 
   /* return the number of frames used */
   return size;
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
index f401c6e..e3c8813 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
@@ -1657,7 +1657,7 @@ void CActiveAE::ApplySettingsToFormat(AEAudioFormat &format, AudioSettings &sett
       CAEChannelInfo stdLayout(stdChannelLayout);
 
       if (m_settings.config == AE_CONFIG_FIXED || settings.dspaddonsenabled || (settings.stereoupmix && format.m_channelLayout.Count() <= 2))
-        format.m_channelLayout = CServiceBroker::GetADSP().GetInternalChannelLayout(stdChannelLayout);
+        format.m_channelLayout = CActiveAEDSP::GetInstance().GetInternalChannelLayout(stdChannelLayout);
       else if (m_extKeepConfig && (settings.config == AE_CONFIG_AUTO) && (oldMode != MODE_RAW))
         format.m_channelLayout = m_internalFormat.m_channelLayout;
       else
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEBuffer.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEBuffer.cpp
index ff26118..7460457 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEBuffer.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEBuffer.cpp
@@ -182,7 +182,7 @@ CActiveAEBufferPoolResample::~CActiveAEBufferPoolResample()
 {
   delete m_resampler;
   if (m_useDSP)
-    CServiceBroker::GetADSP().DestroyDSPs(m_streamId);
+    CActiveAEDSP::GetInstance().DestroyDSPs(m_streamId);
   if (m_dspBuffer)
     delete m_dspBuffer;
 }
@@ -216,12 +216,12 @@ bool CActiveAEBufferPoolResample::Create(unsigned int totaltime, bool remap, boo
    * stream with the basic data to have best quality like for surround upmix.
    *
    * The value m_streamId and address pointer m_processor are passed a pointers
-   * to CServiceBroker::GetADSP().CreateDSPs and set from it.
+   * to CActiveAEDSP::GetInstance().CreateDSPs and set from it.
    */
   if ((useDSP || m_changeDSP) && !m_bypassDSP)
   {
     m_dspFormat = m_inputFormat;
-    m_useDSP = CServiceBroker::GetADSP().CreateDSPs(m_streamId, m_processor, m_dspFormat, m_format, upmix, m_resampleQuality, m_MatrixEncoding, m_AudioServiceType, m_Profile);
+    m_useDSP = CActiveAEDSP::GetInstance().CreateDSPs(m_streamId, m_processor, m_dspFormat, m_format, upmix, m_resampleQuality, m_MatrixEncoding, m_AudioServiceType, m_Profile);
     if (m_useDSP)
     {
 
@@ -330,7 +330,7 @@ void CActiveAEBufferPoolResample::ChangeAudioDSP()
     wasActive = true;
   }
 
-  m_useDSP = CServiceBroker::GetADSP().CreateDSPs(m_streamId, m_processor, m_dspFormat, m_format, m_stereoUpmix, m_resampleQuality, m_MatrixEncoding, m_AudioServiceType, m_Profile, wasActive);
+  m_useDSP = CActiveAEDSP::GetInstance().CreateDSPs(m_streamId, m_processor, m_dspFormat, m_format, m_stereoUpmix, m_resampleQuality, m_MatrixEncoding, m_AudioServiceType, m_Profile, wasActive);
   if (m_useDSP)
   {
     m_inputFormat.m_channelLayout = m_processor->GetChannelLayout();    /* Overide input format with DSP's supported format */
@@ -360,7 +360,7 @@ void CActiveAEBufferPoolResample::ChangeAudioDSP()
       m_changeResampler = true;
 
     m_useDSP = false;
-    CServiceBroker::GetADSP().DestroyDSPs(m_streamId);
+    CActiveAEDSP::GetInstance().DestroyDSPs(m_streamId);
   }
   else
   {
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp
index 1598900..cbc8e88 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp
@@ -34,10 +34,6 @@
 #include <new> // for std::bad_alloc
 #include <algorithm>
 
-#ifdef TARGET_POSIX
-#include "linux/XMemUtils.h"
-#endif
-
 using namespace ActiveAE;
 
 CActiveAESink::CActiveAESink(CEvent *inMsgEvent) :
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
index 95db8cf..fbccce0 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
@@ -40,12 +40,8 @@
 #include "utils/AMLUtils.h"
 #endif
 
-#ifdef TARGET_POSIX
-#include "linux/XTimeUtils.h"
-#endif
 
 #define AE_MIN_PERIODSIZE 256
-
 #define ALSA_CHMAP_KERNEL_BLACKLIST
 
 #define ALSA_OPTIONS (SND_PCM_NO_AUTO_FORMAT | SND_PCM_NO_AUTO_CHANNELS | SND_PCM_NO_AUTO_RESAMPLE)
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkDARWINOSX.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkDARWINOSX.cpp
index 31f7946..75c9b92 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkDARWINOSX.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkDARWINOSX.cpp
@@ -27,7 +27,6 @@
 #include "utils/log.h"
 #include "utils/StringUtils.h"
 #include "utils/TimeUtils.h"
-#include "linux/XMemUtils.h"
 
 static void EnumerateDevices(CADeviceList &list)
 {
diff --git a/xbmc/cores/AudioEngine/Sinks/osx/CoreAudioDevice.cpp b/xbmc/cores/AudioEngine/Sinks/osx/CoreAudioDevice.cpp
index 46bb3d9..1b385ca 100644
--- a/xbmc/cores/AudioEngine/Sinks/osx/CoreAudioDevice.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/osx/CoreAudioDevice.cpp
@@ -24,7 +24,6 @@
 #include "CoreAudioHardware.h"
 #include "utils/log.h"
 #include "platform/darwin/DarwinUtils.h"
-#include <unistd.h>
 
 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 // CCoreAudioDevice
@@ -202,7 +201,7 @@ bool CCoreAudioDevice::RemoveIOProc()
 
   m_IoProc = NULL; // Clear the reference no matter what
 
-  usleep(100000);
+  Sleep(100);
 
   return true;
 }
diff --git a/xbmc/cores/AudioEngine/Utils/AEBuffer.cpp b/xbmc/cores/AudioEngine/Utils/AEBuffer.cpp
index 87daf3d..6eb4770 100644
--- a/xbmc/cores/AudioEngine/Utils/AEBuffer.cpp
+++ b/xbmc/cores/AudioEngine/Utils/AEBuffer.cpp
@@ -20,9 +20,6 @@
 
 #include "AEBuffer.h"
 #include <algorithm>
-#ifdef TARGET_POSIX
-#include "linux/XMemUtils.h"
-#endif
 
 CAEBuffer::CAEBuffer() :
   m_buffer    (NULL),
diff --git a/xbmc/cores/AudioEngine/Utils/AERingBuffer.h b/xbmc/cores/AudioEngine/Utils/AERingBuffer.h
index 91eaecc..7e60605 100644
--- a/xbmc/cores/AudioEngine/Utils/AERingBuffer.h
+++ b/xbmc/cores/AudioEngine/Utils/AERingBuffer.h
@@ -28,9 +28,6 @@
 
 #include "utils/log.h"  //CLog
 #include <string.h>     //memset, memcpy
-#ifdef TARGET_POSIX
-#include "linux/XMemUtils.h"
-#endif
 
 /**
  * This buffer can be used by one read and one write thread at any one time
diff --git a/xbmc/cores/DllLoader/exports/emu_kernel32.cpp b/xbmc/cores/DllLoader/exports/emu_kernel32.cpp
index 948c09a..aad5fb0 100644
--- a/xbmc/cores/DllLoader/exports/emu_kernel32.cpp
+++ b/xbmc/cores/DllLoader/exports/emu_kernel32.cpp
@@ -34,10 +34,7 @@
 #include "filesystem/SpecialProtocol.h"
 
 #ifdef TARGET_POSIX
-#include "linux/PlatformInclude.h"
-#include "linux/XFileUtils.h"
-#include "linux/XTimeUtils.h"
-#include "linux/ConvUtils.h"
+#include "../../../linux/PlatformInclude.h"
 #define __except catch
 #endif
 
@@ -83,14 +80,12 @@ extern "C" ATOM WINAPI dllDeleteAtomA(ATOM nAtom)
 {
 }*/
 
-#ifdef TARGET_WINDOWS
-
 extern "C" BOOL WINAPI dllFindClose(HANDLE hFile)
 {
   return FindClose(hFile);
 }
 
-
+#ifdef TARGET_WINDOWS
 #define CORRECT_SEP_STR(str) \
   if (strstr(str, "://") == NULL) \
   { \
@@ -158,6 +153,7 @@ static void to_WIN32_FIND_DATAW(LPWIN32_FIND_DATA data, LPWIN32_FIND_DATAW wdata
   wdata->dwReserved0 = data->dwReserved0;
   wdata->dwReserved1 = data->dwReserved1;
 }
+#endif
 
 extern "C" HANDLE WINAPI dllFindFirstFileA(LPCTSTR lpFileName, LPWIN32_FIND_DATA lpFindFileData)
 {
@@ -224,7 +220,6 @@ extern "C" DWORD WINAPI dllGetFileAttributesA(LPCSTR lpFileName)
   return GetFileAttributes(str);
 #endif
 }
-#endif
 
 extern "C" void WINAPI dllSleep(DWORD dwTime)
 {
diff --git a/xbmc/cores/DllLoader/exports/emu_kernel32.h b/xbmc/cores/DllLoader/exports/emu_kernel32.h
index 74de063..aaa0572 100644
--- a/xbmc/cores/DllLoader/exports/emu_kernel32.h
+++ b/xbmc/cores/DllLoader/exports/emu_kernel32.h
@@ -590,11 +590,9 @@ typedef long LONG_PTR;
 //All kernel32 function should use WINAPI calling convention.
 //When doing emulation or interception, the calling convention should
 //match exactly the target dlls suppose to use.   Monkeyhappy
-#ifdef TARGET_WINDOWS
 extern "C" HANDLE WINAPI dllFindFirstFileA(LPCTSTR lpFileName, LPWIN32_FIND_DATA lpFindFileData);
 extern "C" BOOL WINAPI dllFindNextFileA(HANDLE hFindFile, LPWIN32_FIND_DATA lpFindFileData);
 extern "C" BOOL WINAPI dllFindClose(HANDLE hFile);
-#endif
 extern "C" UINT WINAPI dllGetAtomNameA( ATOM nAtom, LPTSTR lpBuffer, int nSize);
 extern "C" ATOM WINAPI dllFindAtomA( LPCTSTR lpString);
 extern "C" ATOM WINAPI dllAddAtomA( LPCTSTR lpString);
diff --git a/xbmc/cores/DllLoader/exports/emu_msvcrt.cpp b/xbmc/cores/DllLoader/exports/emu_msvcrt.cpp
index 514bc2b..b3501ec 100644
--- a/xbmc/cores/DllLoader/exports/emu_msvcrt.cpp
+++ b/xbmc/cores/DllLoader/exports/emu_msvcrt.cpp
@@ -26,7 +26,6 @@
 #include <io.h>
 #include <direct.h>
 #include <process.h>
-#include <errno.h>
 #else
 #if !defined(TARGET_DARWIN) && !defined(TARGET_FREEBSD)
 #include <mntent.h>
@@ -53,8 +52,6 @@
 #include <signal.h>
 #ifdef TARGET_POSIX
 #include "PlatformDefs.h" // for __stat64
-#include "XFileUtils.h"
-#include "XTimeUtils.h"
 #endif
 #include "Util.h"
 #include "filesystem/SpecialProtocol.h"
@@ -575,12 +572,12 @@ extern "C"
     CFile* pFile = g_emuFileWrapper.GetFileXbmcByDescriptor(fd);
     if (pFile != NULL)
     {
-      errno = 0;
+      errno = NOERROR;
       const ssize_t ret = pFile->Read(buffer, uiSize);
       if (ret < 0)
       {
         const int err = errno; // help compiler to optimize, "errno" can be macro
-        if (err == 0 ||
+        if (err == NOERROR ||
             (err != EAGAIN && err != EINTR && err != EIO && err != EOVERFLOW && err != EWOULDBLOCK &&
              err != ECONNRESET && err != ENOTCONN && err != ETIMEDOUT &&
              err != ENOBUFS && err != ENOMEM && err != ENXIO))
@@ -606,12 +603,12 @@ extern "C"
     CFile* pFile = g_emuFileWrapper.GetFileXbmcByDescriptor(fd);
     if (pFile != NULL)
     {
-      errno = 0;
+      errno = NOERROR;
       const ssize_t ret = pFile->Write(buffer, uiSize);
       if (ret < 0)
       {
         const int err = errno; // help compiler to optimize, "errno" can be macro
-        if (err == 0 ||
+        if (err == NOERROR ||
             (err != EAGAIN && err != EFBIG && err != EINTR && err != EIO && err != ENOSPC && err != EPIPE && err != EWOULDBLOCK &&
              err != ECONNRESET &&
              err != ENOBUFS && err != ENXIO &&
diff --git a/xbmc/cores/IPlayer.h b/xbmc/cores/IPlayer.h
index 694aacc..45f25b5 100644
--- a/xbmc/cores/IPlayer.h
+++ b/xbmc/cores/IPlayer.h
@@ -404,6 +404,8 @@ public:
 
   virtual float GetRenderAspectRatio() { return 1.0; };
 
+  virtual RESOLUTION GetRenderResolution() { return RES_INVALID; };
+
   virtual void TriggerUpdateResolution() {};
 
   virtual bool IsRenderingVideo() { return false; };
diff --git a/xbmc/cores/VideoPlayer/DVDAudio.cpp b/xbmc/cores/VideoPlayer/DVDAudio.cpp
index a91ab08..bbea8c1 100644
--- a/xbmc/cores/VideoPlayer/DVDAudio.cpp
+++ b/xbmc/cores/VideoPlayer/DVDAudio.cpp
@@ -18,17 +18,15 @@
  *
  */
 
-#include "DVDAudio.h"
 #include "threads/SingleLock.h"
 #include "utils/log.h"
+#include "DVDAudio.h"
 #include "DVDClock.h"
 #include "DVDCodecs/Audio/DVDAudioCodec.h"
 #include "cores/AudioEngine/AEFactory.h"
+#include "cores/AudioEngine/Interfaces/AEStream.h"
 #include "cores/AudioEngine/Utils/AEAudioFormat.h"
 #include "settings/MediaSettings.h"
-#ifdef TARGET_POSIX
-#include "linux/XTimeUtils.h"
-#endif
 
 CDVDAudio::CDVDAudio(CDVDClock *clock) : m_pClock(clock)
 {
diff --git a/xbmc/cores/VideoPlayer/DVDClock.cpp b/xbmc/cores/VideoPlayer/DVDClock.cpp
index 73c72ce..0b96e31 100644
--- a/xbmc/cores/VideoPlayer/DVDClock.cpp
+++ b/xbmc/cores/VideoPlayer/DVDClock.cpp
@@ -25,8 +25,6 @@
 #include "threads/SingleLock.h"
 #include "utils/log.h"
 
-#include <inttypes.h>
-
 int64_t CDVDClock::m_systemOffset;
 int64_t CDVDClock::m_systemFrequency;
 CCriticalSection CDVDClock::m_systemsection;
diff --git a/xbmc/cores/VideoPlayer/DVDClock.h b/xbmc/cores/VideoPlayer/DVDClock.h
index b42ed9d..d4db746 100644
--- a/xbmc/cores/VideoPlayer/DVDClock.h
+++ b/xbmc/cores/VideoPlayer/DVDClock.h
@@ -20,12 +20,11 @@
  *
  */
 
+#include "system.h"
 #include "threads/CriticalSection.h"
 
-#include <stdint.h>
-
 #define DVD_TIME_BASE 1000000
-#define DVD_NOPTS_VALUE 0xFFF0000000000000
+#define DVD_NOPTS_VALUE 0xFFF0000000000000 // should be possible to represent in both double and int64_t
 
 #define DVD_TIME_TO_SEC(x)  ((int)((double)(x) / DVD_TIME_BASE))
 #define DVD_TIME_TO_MSEC(x) ((int)((double)(x) * 1000 / DVD_TIME_BASE))
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.cpp
index 6f521cb..a001c98 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.cpp
@@ -65,7 +65,7 @@ bool CDVDAudioCodecFFmpeg::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options
       allowdtshddecode = atoi(it->m_value.c_str());
 
   if (hints.codec == AV_CODEC_ID_DTS && allowdtshddecode)
-    pCodec = avcodec_find_decoder_by_name("dcadec");
+    pCodec = avcodec_find_decoder_by_name("libdcadec");
 
   if (!pCodec)
     pCodec = avcodec_find_decoder(hints.codec);
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/DVDFactoryCodec.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/DVDFactoryCodec.cpp
index 355257c..8644123 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/DVDFactoryCodec.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/DVDFactoryCodec.cpp
@@ -23,6 +23,7 @@
 
 #include "DVDFactoryCodec.h"
 #include "Video/DVDVideoCodec.h"
+#include "Video/PixelConverter.h"
 #include "Audio/DVDAudioCodec.h"
 #include "Overlay/DVDOverlayCodec.h"
 #include "cores/VideoPlayer/DVDCodecs/DVDCodecs.h"
@@ -138,6 +139,13 @@ CDVDVideoCodec* CDVDFactoryCodec::CreateVideoCodec(CDVDStreamInfo &hint, CProces
 
   options.m_opaque_pointer = info.opaque_pointer;
 
+  if (hint.codec == AV_CODEC_ID_NONE && hint.pixfmt != AV_PIX_FMT_NONE)
+  {
+    pCodec = OpenCodec(new CPixelConverter(processInfo), hint, options);
+    if (pCodec)
+      return pCodec;
+  }
+
   if (!hint.software)
   {
 #if defined(HAS_LIBAMCODEC)
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Overlay/DVDOverlayCodec.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Overlay/DVDOverlayCodec.cpp
index f7d6a96..b066a55 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Overlay/DVDOverlayCodec.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Overlay/DVDOverlayCodec.cpp
@@ -18,7 +18,6 @@
  *
  */
 #include "DVDOverlayCodec.h"
-#include "DVDDemuxers/DVDDemuxPacket.h"
 #include "cores/VideoPlayer/DVDClock.h"
 
 void CDVDOverlayCodec::GetAbsoluteTimes(double &starttime, double &stoptime, DemuxPacket *pkt, bool &replace, double offset/* = 0.0*/)
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Overlay/DVDOverlayCodec.h b/xbmc/cores/VideoPlayer/DVDCodecs/Overlay/DVDOverlayCodec.h
index 7b7e45a..2c5f7e1 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Overlay/DVDOverlayCodec.h
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Overlay/DVDOverlayCodec.h
@@ -20,6 +20,7 @@
  *
  */
 
+#include "DVDOverlay.h"
 #include "PlatformDefs.h"
 #include "cores/VideoPlayer/DVDDemuxers/DVDDemux.h"
 
@@ -30,7 +31,6 @@
 #define OC_BUFFER   0x00000002  // the decoder needs more data
 #define OC_OVERLAY  0x00000004  // the decoder decoded an overlay, call Decode(NULL, 0) again to parse the rest of the data
 
-class CDVDOverlay;
 class CDVDStreamInfo;
 class CDVDCodecOption;
 class CDVDCodecOptions;
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.cpp
index 24f2de0..dca4bdf 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.cpp
@@ -22,7 +22,6 @@
 #include "DVDOverlayImage.h"
 #include "DVDStreamInfo.h"
 #include "DVDClock.h"
-#include "DVDDemuxers/DVDDemuxPacket.h"
 #include "utils/log.h"
 #include "utils/EndianSwap.h"
 #include "guilib/GraphicContext.h"
@@ -132,8 +131,8 @@ void CDVDOverlayCodecFFmpeg::FreeSubtitle(AVSubtitle& sub)
   {
     if(sub.rects[i])
     {
-      av_free(sub.rects[i]->data[0]);
-      av_free(sub.rects[i]->data[1]);
+      av_free(sub.rects[i]->pict.data[0]);
+      av_free(sub.rects[i]->pict.data[1]);
       av_freep(&sub.rects[i]);
     }
   }
@@ -238,7 +237,7 @@ CDVDOverlay* CDVDOverlayCodecFFmpeg::GetOverlay()
       return NULL;
 
     AVSubtitleRect rect = *m_Subtitle.rects[m_SubtitleIndex];
-    if (rect.data[0] == NULL)
+    if (rect.pict.data[0] == NULL)
       return NULL;
 
     m_height = m_pCodecContext->height;
@@ -290,20 +289,20 @@ CDVDOverlay* CDVDOverlayCodecFFmpeg::GetOverlay()
     overlay->source_width  = m_width;
     overlay->source_height = m_height;
 
-    uint8_t* s = rect.data[0];
+    uint8_t* s = rect.pict.data[0];
     uint8_t* t = overlay->data;
     for(int i=0;i<rect.h;i++)
     {
       memcpy(t, s, rect.w);
-      s += rect.linesize[0];
+      s += rect.pict.linesize[0];
       t += overlay->linesize;
     }
 
     for(int i=0;i<rect.nb_colors;i++)
-      overlay->palette[i] = Endian_SwapLE32(((uint32_t *)rect.data[1])[i]);
+      overlay->palette[i] = Endian_SwapLE32(((uint32_t *)rect.pict.data[1])[i]);
 
-    av_free(rect.data[0]);
-    av_free(rect.data[1]);
+    av_free(rect.pict.data[0]);
+    av_free(rect.pict.data[1]);
     av_freep(&m_Subtitle.rects[m_SubtitleIndex]);
     m_SubtitleIndex++;
 
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Overlay/DVDOverlayCodecSSA.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Overlay/DVDOverlayCodecSSA.cpp
index c67e3a6..a955e9f 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Overlay/DVDOverlayCodecSSA.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Overlay/DVDOverlayCodecSSA.cpp
@@ -25,7 +25,6 @@
 #include "DVDStreamInfo.h"
 #include "DVDCodecs/DVDCodecs.h"
 #include "DVDClock.h"
-#include "DVDDemuxers/DVDDemuxPacket.h"
 #include "Util.h"
 #include "utils/StringUtils.h"
 
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Overlay/DVDOverlayCodecTX3G.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Overlay/DVDOverlayCodecTX3G.cpp
index a0b9982..e8abb13 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Overlay/DVDOverlayCodecTX3G.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Overlay/DVDOverlayCodecTX3G.cpp
@@ -23,7 +23,6 @@
 #include "DVDOverlayText.h"
 #include "DVDStreamInfo.h"
 #include "DVDCodecs/DVDCodecs.h"
-#include "DVDDemuxers/DVDDemuxPacket.h"
 #include "settings/Settings.h"
 #include "utils/log.h"
 #include "utils/StringUtils.h"
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Overlay/DVDOverlayCodecText.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Overlay/DVDOverlayCodecText.cpp
index bbe98f1..9207c1a 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Overlay/DVDOverlayCodecText.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Overlay/DVDOverlayCodecText.cpp
@@ -23,7 +23,6 @@
 #include "DVDOverlayText.h"
 #include "DVDStreamInfo.h"
 #include "DVDCodecs/DVDCodecs.h"
-#include "DVDDemuxers/DVDDemuxPacket.h"
 #include "utils/log.h"
 #include "cores/VideoPlayer/DVDSubtitles/DVDSubtitleTagSami.h"
 
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
index f986a4b..7146f3a 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
@@ -582,7 +582,7 @@ int CDVDVideoCodecFFmpeg::Decode(uint8_t* pData, int iSize, double dts, double p
 
   if (!iGotPicture)
   {
-    if (pData && m_pCodecContext->skip_frame > AVDISCARD_DEFAULT)
+    if (pData)
     {
       m_droppedFrames++;
       if (m_interlaced)
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp
index e6f46c5..0f90298 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp
@@ -508,20 +508,20 @@ bool CDVDVideoCodecIMX::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
   m_convert_bitstream = false;
   switch(m_hints.codec)
   {
-  case AV_CODEC_ID_MPEG1VIDEO:
+  case CODEC_ID_MPEG1VIDEO:
     m_decOpenParam.CodecFormat = VPU_V_MPEG2;
     m_pFormatName = "iMX-mpeg1";
     break;
-  case AV_CODEC_ID_MPEG2VIDEO:
-  case AV_CODEC_ID_MPEG2VIDEO_XVMC:
+  case CODEC_ID_MPEG2VIDEO:
+  case CODEC_ID_MPEG2VIDEO_XVMC:
     m_decOpenParam.CodecFormat = VPU_V_MPEG2;
     m_pFormatName = "iMX-mpeg2";
     break;
-  case AV_CODEC_ID_H263:
+  case CODEC_ID_H263:
     m_decOpenParam.CodecFormat = VPU_V_H263;
     m_pFormatName = "iMX-h263";
     break;
-  case AV_CODEC_ID_H264:
+  case CODEC_ID_H264:
   {
     // Test for VPU unsupported profiles to revert to sw decoding
     if ((m_hints.profile == 110) || //hi10p
@@ -542,31 +542,31 @@ bool CDVDVideoCodecIMX::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
     }
     break;
   }
-  case AV_CODEC_ID_VC1:
+  case CODEC_ID_VC1:
     m_decOpenParam.CodecFormat = VPU_V_VC1_AP;
     m_pFormatName = "iMX-vc1";
     break;
-  case AV_CODEC_ID_CAVS:
-  case AV_CODEC_ID_AVS:
+  case CODEC_ID_CAVS:
+  case CODEC_ID_AVS:
     m_decOpenParam.CodecFormat = VPU_V_AVS;
     m_pFormatName = "iMX-AVS";
     break;
-  case AV_CODEC_ID_RV10:
-  case AV_CODEC_ID_RV20:
-  case AV_CODEC_ID_RV30:
-  case AV_CODEC_ID_RV40:
+  case CODEC_ID_RV10:
+  case CODEC_ID_RV20:
+  case CODEC_ID_RV30:
+  case CODEC_ID_RV40:
     m_decOpenParam.CodecFormat = VPU_V_RV;
     m_pFormatName = "iMX-RV";
     break;
-  case AV_CODEC_ID_KMVC:
+  case CODEC_ID_KMVC:
     m_decOpenParam.CodecFormat = VPU_V_AVC_MVC;
     m_pFormatName = "iMX-MVC";
     break;
-  case AV_CODEC_ID_VP8:
+  case CODEC_ID_VP8:
     m_decOpenParam.CodecFormat = VPU_V_VP8;
     m_pFormatName = "iMX-vp8";
     break;
-  case AV_CODEC_ID_MPEG4:
+  case CODEC_ID_MPEG4:
     switch(m_hints.codec_tag)
     {
     case _4CC('D','I','V','X'):
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecOpenMax.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecOpenMax.cpp
index 47e2ecc..f015291 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecOpenMax.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecOpenMax.cpp
@@ -35,7 +35,7 @@
 #define CLASSNAME "COpenMax"
 ////////////////////////////////////////////////////////////////////////////////////////////
 ////////////////////////////////////////////////////////////////////////////////////////////
-CDVDVideoCodecOpenMax::CDVDVideoCodecOpenMax(CProcessInfo &processInfo) : CDVDVideoCodec(processInfo)
+CDVDVideoCodecOpenMax::CDVDVideoCodecOpenMax() : CDVDVideoCodec()
 {
   m_omx_decoder = NULL;
   m_pFormatName = "omx-xxxx";
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecOpenMax.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecOpenMax.h
index caabc84..34a1b22 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecOpenMax.h
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecOpenMax.h
@@ -27,7 +27,7 @@ class COpenVideoMax;
 class CDVDVideoCodecOpenMax : public CDVDVideoCodec
 {
 public:
-  CDVDVideoCodecOpenMax(CProcessInfo &processInfo);
+  CDVDVideoCodecOpenMax();
   virtual ~CDVDVideoCodecOpenMax();
 
   // Required overrides
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoPPFFmpeg.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoPPFFmpeg.cpp
index fd54f15..4fe863f 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoPPFFmpeg.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoPPFFmpeg.cpp
@@ -21,9 +21,6 @@
 #include "DVDVideoPPFFmpeg.h"
 #include "utils/log.h"
 #include "cores/FFmpeg.h"
-#ifdef TARGET_POSIX
-#include "linux/XMemUtils.h"
-#endif
 
 CDVDVideoPPFFmpeg::CDVDVideoPPFFmpeg(const std::string& mType):
   m_sType(mType)
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.cpp
index 6d7b0a0..b6b91e7 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/MMALFFmpeg.cpp
@@ -101,7 +101,7 @@ void CDecoder::ReleaseBuffer(CGPUMEM *gmem)
 
 void CDecoder::AlignedSize(AVCodecContext *avctx, int &w, int &h)
 {
-  AVFrame picture;
+  AVPicture picture;
   int unaligned;
   int stride_align[AV_NUM_DATA_POINTERS];
 
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/Makefile.in b/xbmc/cores/VideoPlayer/DVDCodecs/Video/Makefile.in
index a1a3447..d34e55c 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/Makefile.in
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/Makefile.in
@@ -3,6 +3,7 @@ INCLUDES+=-I@abs_top_srcdir@/xbmc/cores/VideoPlayer
 SRCS  = DVDVideoCodec.cpp
 SRCS += DVDVideoCodecFFmpeg.cpp
 SRCS += DVDVideoPPFFmpeg.cpp
+SRCS += PixelConverter.cpp
 
 ifeq (@USE_VDPAU@,1)
 SRCS += VDPAU.cpp
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/PixelConverter.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/PixelConverter.cpp
new file mode 100644
index 0000000..96f1e0f
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/PixelConverter.cpp
@@ -0,0 +1,163 @@
+/*
+ *      Copyright (C) 2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "PixelConverter.h"
+#include "cores/VideoPlayer/DVDClock.h"
+#include "cores/VideoPlayer/DVDCodecs/DVDCodecs.h"
+#include "cores/VideoPlayer/DVDCodecs/DVDCodecUtils.h"
+#include "cores/VideoPlayer/DVDStreamInfo.h"
+#include "utils/log.h"
+
+extern "C" {
+#include "libavutil/avconfig.h"
+#include "libswscale/swscale.h"
+}
+
+#include <algorithm>
+#include <cstring>
+
+CPixelConverter::CPixelConverter(CProcessInfo &processInfo) :
+  CDVDVideoCodec(processInfo),
+  m_pixfmt(AV_PIX_FMT_NONE),
+  m_targetfmt(AV_PIX_FMT_NONE),
+  m_width(0),
+  m_height(0),
+  m_swsContext(nullptr),
+  m_buf(nullptr)
+{
+}
+
+bool CPixelConverter::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
+{
+  if (hints.width <= 0 || hints.height <= 0)
+    return false;
+
+  m_pixfmt = hints.pixfmt;
+  m_targetfmt = AV_PIX_FMT_NONE;
+  m_width = hints.width;
+  m_height = hints.height;
+
+  const std::vector<ERenderFormat>& renderFmts = options.m_formats;
+
+  // Try to render without conversion
+  ERenderFormat renderFmt = CDVDCodecUtils::EFormatFromPixfmt(m_pixfmt);
+  if (renderFmt != RENDER_FMT_NONE && std::find(renderFmts.begin(), renderFmts.end(), renderFmt) != renderFmts.end())
+  {
+    // TODO: Support non-YUV420p
+    //m_targetfmt = m_pixfmt;
+  }
+
+  // Try to fallback to YUV420p
+  if (m_targetfmt == AV_PIX_FMT_NONE && std::find(renderFmts.begin(), renderFmts.end(), RENDER_FMT_YUV420P) != renderFmts.end())
+    m_targetfmt = AV_PIX_FMT_YUV420P;
+
+  if (m_targetfmt == AV_PIX_FMT_NONE)
+  {
+    CLog::Log(LOGDEBUG, "%s: Failed to find a suitable render format", GetName());
+    return false;
+  }
+
+  if (m_pixfmt != m_targetfmt)
+  {
+    m_swsContext = sws_getContext(m_width, m_height, m_pixfmt,
+                                  m_width, m_height, m_targetfmt,
+                                  SWS_FAST_BILINEAR, NULL, NULL, NULL);
+    if (!m_swsContext)
+    {
+      CLog::Log(LOGERROR, "%s: Failed to create swscale context", GetName());
+      return false;
+    }
+  }
+
+  m_buf = CDVDCodecUtils::AllocatePicture(m_width, m_height);
+
+  return true;
+}
+
+void CPixelConverter::Dispose()
+{
+  if (m_swsContext)
+  {
+    sws_freeContext(m_swsContext);
+    m_swsContext = nullptr;
+  }
+
+  if (m_buf)
+  {
+    CDVDCodecUtils::FreePicture(m_buf);
+    m_buf = nullptr;
+  }
+}
+
+int CPixelConverter::Decode(uint8_t* pData, int iSize, double dts, double pts)
+{
+  int ret = VC_ERROR;
+
+  if (m_swsContext)
+  {
+    const int stride = iSize / m_height;
+
+    if (stride > 0)
+    {
+      uint8_t* src[] =       { pData,               0,                   0,                   0 };
+      int      srcStride[] = { stride,              0,                   0,                   0 };
+      uint8_t* dst[] =       { m_buf->data[0],      m_buf->data[1],      m_buf->data[2],      0 };
+      int      dstStride[] = { m_buf->iLineSize[0], m_buf->iLineSize[1], m_buf->iLineSize[2], 0 };
+
+      sws_scale(m_swsContext, src, srcStride, 0, m_height, dst, dstStride);
+
+      ret = VC_PICTURE;
+    }
+  }
+  else
+  {
+    // Don't overflow buffer
+    if (iSize <= (int)m_width * (int)m_height * 3 / 2)
+    {
+      std::memcpy(m_buf->data[0], pData, iSize);
+      ret = VC_PICTURE;
+    }
+  }
+
+  return ret;
+}
+
+bool CPixelConverter::GetPicture(DVDVideoPicture* pDvdVideoPicture)
+{
+  pDvdVideoPicture->dts            = DVD_NOPTS_VALUE;
+  pDvdVideoPicture->pts            = DVD_NOPTS_VALUE;
+
+  for (int i = 0; i < 4; i++)
+  {
+    pDvdVideoPicture->data[i]      = m_buf->data[i];
+    pDvdVideoPicture->iLineSize[i] = m_buf->iLineSize[i];
+  }
+
+  pDvdVideoPicture->iFlags         = DVP_FLAG_ALLOCATED;
+  pDvdVideoPicture->color_matrix   = 4; // CONF_FLAGS_YUVCOEF_BT601
+  pDvdVideoPicture->color_range    = 0; // *not* CONF_FLAGS_YUV_FULLRANGE
+  pDvdVideoPicture->iWidth         = m_width;
+  pDvdVideoPicture->iHeight        = m_height;
+  pDvdVideoPicture->iDisplayWidth  = m_width;
+  pDvdVideoPicture->iDisplayHeight = m_height;
+  pDvdVideoPicture->format         = CDVDCodecUtils::EFormatFromPixfmt(m_targetfmt);
+
+  return true;
+}
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/PixelConverter.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/PixelConverter.h
new file mode 100644
index 0000000..0821ebd
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/PixelConverter.h
@@ -0,0 +1,55 @@
+/*
+ *      Copyright (C) 2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+#include "DVDVideoCodec.h"
+
+extern "C" {
+#include "libavutil/pixfmt.h"
+}
+
+#define PIXEL_CONVERTER_CODEC_NAME  "PixelConverter"
+
+struct DVDVideoPicture;
+struct SwsContext;
+
+class CPixelConverter : public CDVDVideoCodec
+{
+public:
+  CPixelConverter(CProcessInfo &processInfo);
+  virtual ~CPixelConverter() { }
+
+  // implementation of CDVDVideoCodec
+  virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options) override;
+  virtual void Dispose() override;
+  virtual int Decode(uint8_t* pData, int iSize, double dts, double pts) override;
+  virtual void Reset() override { }
+  virtual bool GetPicture(DVDVideoPicture* pDvdVideoPicture) override;
+  virtual void SetDropState(bool bDrop) override { }
+  virtual const char* GetName() override { return PIXEL_CONVERTER_CODEC_NAME; }
+
+private:
+  AVPixelFormat    m_pixfmt;
+  AVPixelFormat    m_targetfmt;
+  unsigned int     m_width;
+  unsigned int     m_height;
+  SwsContext*      m_swsContext;
+  DVDVideoPicture* m_buf;
+};
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/VAAPI.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/VAAPI.cpp
index c014ce2..a7a1587 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/VAAPI.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/VAAPI.cpp
@@ -34,8 +34,6 @@
 #include <va/va_x11.h>
 #include <va/va_drmcommon.h>
 #include <drm_fourcc.h>
-#include "linux/XTimeUtils.h"
-#include "linux/XMemUtils.h"
 
 extern "C" {
 #include "libavutil/avutil.h"
diff --git a/xbmc/cores/VideoPlayer/DVDDemuxSPU.cpp b/xbmc/cores/VideoPlayer/DVDDemuxSPU.cpp
index 24a37fb..7c93e8e 100644
--- a/xbmc/cores/VideoPlayer/DVDDemuxSPU.cpp
+++ b/xbmc/cores/VideoPlayer/DVDDemuxSPU.cpp
@@ -20,7 +20,6 @@
 
 #include "DVDDemuxSPU.h"
 #include "DVDClock.h"
-#include "DVDCodecs/Overlay/DVDOverlaySpu.h"
 #include "utils/log.h"
 
 #undef ALIGN
@@ -51,7 +50,7 @@ CDVDDemuxSPU::CDVDDemuxSPU()
 
 CDVDDemuxSPU::~CDVDDemuxSPU()
 {
-  free(m_spuData.data);
+  if (m_spuData.data) free(m_spuData.data);
 }
 
 void CDVDDemuxSPU::Reset()
@@ -68,7 +67,7 @@ void CDVDDemuxSPU::Reset()
 
 void CDVDDemuxSPU::FlushCurrentPacket()
 {
-  free(m_spuData.data);
+  if (m_spuData.data) free(m_spuData.data);
   memset(&m_spuData, 0, sizeof(m_spuData));
 }
 
diff --git a/xbmc/cores/VideoPlayer/DVDDemuxSPU.h b/xbmc/cores/VideoPlayer/DVDDemuxSPU.h
index 771feac..de4cd57 100644
--- a/xbmc/cores/VideoPlayer/DVDDemuxSPU.h
+++ b/xbmc/cores/VideoPlayer/DVDDemuxSPU.h
@@ -20,10 +20,11 @@
  *
  */
 
+#include "DVDCodecs/Overlay/DVDOverlaySpu.h"
+
 #include <stdint.h>
 
-struct AVFrame;
-class CDVDOverlaySpu;
+struct AVPicture;
 
 typedef struct SPUData
 {
@@ -38,11 +39,11 @@ SPUData;
 // upto 32 streams can exist
 #define DVD_MAX_SPUSTREAMS 32
 
-class CDVDDemuxSPU final
+class CDVDDemuxSPU
 {
 public:
   CDVDDemuxSPU();
-  ~CDVDDemuxSPU();
+  virtual ~CDVDDemuxSPU();
 
   CDVDOverlaySpu* AddData(uint8_t* data, int iSize, double pts); // returns a packet from ParsePacket if possible
 
diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemux.h b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemux.h
index 7d778e6..4f71df9 100644
--- a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemux.h
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemux.h
@@ -23,8 +23,8 @@
 #include <string>
 #include <vector>
 #include "system.h"
+#include "DVDDemuxPacket.h"
 
-struct DemuxPacket;
 class CDVDInputStream;
 
 #ifndef __GNUC__
@@ -38,6 +38,7 @@ class CDVDInputStream;
 
 extern "C" {
 #include "libavcodec/avcodec.h"
+#include "libavutil/pixfmt.h"
 }
 
 #ifndef __GNUC__
@@ -146,6 +147,7 @@ class CDemuxStreamVideo : public CDemuxStream
 public:
   CDemuxStreamVideo() : CDemuxStream()
   {
+    pixfmt = AV_PIX_FMT_NONE;
     iFpsScale = 0;
     iFpsRate = 0;
     irFpsScale = 0;
@@ -162,6 +164,8 @@ public:
   }
 
   virtual ~CDemuxStreamVideo() {}
+
+  AVPixelFormat pixfmt; // used if codec is AV_CODEC_ID_NONE
   int iFpsScale; // scale of 1000 and a rate of 29970 will result in 29.97 fps
   int iFpsRate;
   int irFpsScale;
@@ -348,12 +352,6 @@ public:
   virtual void EnableStreamAtPTS(int64_t demuxerId, int id, uint64_t pts) { EnableStreamAtPTS(id, pts); };
 
   /*
-   * sets desired width / height for video stream
-   * adaptive demuxers like DASH can use this to choose best fitting video stream
-   */
-  virtual void SetVideoResolution(int width, int height) {};
-  
-  /*
   * return the id of the demuxer
   */
   int64_t GetDemuxerId() { return m_demuxerId; };
diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxClient.cpp b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxClient.cpp
index b77c308..3f8245c 100644
--- a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxClient.cpp
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxClient.cpp
@@ -617,11 +617,3 @@ void CDVDDemuxClient::EnableStreamAtPTS(int id, uint64_t pts)
     m_IDemux->EnableStreamAtPTS(id, pts);
   }
 }
-
-void CDVDDemuxClient::SetVideoResolution(int width, int height)
-{
-  if (m_IDemux)
-  {
-    m_IDemux->SetVideoResolution(width, height);
-  }
-}
diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxClient.h b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxClient.h
index e6c9bfd..c4d9c8e 100644
--- a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxClient.h
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxClient.h
@@ -51,7 +51,6 @@ public:
   virtual bool SupportsEnableAtPTS() override { return m_IDemux ? m_IDemux->SupportsEnableAtPTS():false; };
   virtual void EnableStream(int id, bool enable) override;
   virtual void EnableStreamAtPTS(int id, uint64_t pts) override;
-  virtual void SetVideoResolution(int width, int height) override;
 
 protected:
   void RequestStreams();
diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
index 5271e4b..930ffec 100644
--- a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
@@ -438,7 +438,7 @@ bool CDVDDemuxFFmpeg::Open(CDVDInputStream* pInput, bool streaminfo, bool filein
       AVStream *st = m_pFormatContext->streams[i];
       if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO && st->codec->codec_id == AV_CODEC_ID_DTS)
       {
-        AVCodec* pCodec = avcodec_find_decoder_by_name("dcadec");
+        AVCodec* pCodec = avcodec_find_decoder_by_name("libdcadec");
         if (pCodec)
           st->codec->codec = pCodec;
       }
@@ -508,7 +508,7 @@ bool CDVDDemuxFFmpeg::Open(CDVDInputStream* pInput, bool streaminfo, bool filein
 void CDVDDemuxFFmpeg::Dispose()
 {
   m_pkt.result = -1;
-  av_packet_unref(&m_pkt.pkt);
+  av_free_packet(&m_pkt.pkt);
 
   if (m_pFormatContext)
   {
@@ -556,7 +556,7 @@ void CDVDDemuxFFmpeg::Flush()
   m_currentPts = DVD_NOPTS_VALUE;
 
   m_pkt.result = -1;
-  av_packet_unref(&m_pkt.pkt);
+  av_free_packet(&m_pkt.pkt);
 
   m_displayTime = 0;
   m_dtsAtDisplayTime = DVD_NOPTS_VALUE;
@@ -763,7 +763,7 @@ DemuxPacket* CDVDDemuxFFmpeg::Read()
         CLog::Log(LOGERROR, "CDVDDemuxFFmpeg::Read() returned invalid packet and eof reached");
 
       m_pkt.result = -1;
-      av_packet_unref(&m_pkt.pkt);
+      av_free_packet(&m_pkt.pkt);
     }
     else
     {
@@ -817,6 +817,10 @@ DemuxPacket* CDVDDemuxFFmpeg::Read()
             m_pkt.pkt.pts = AV_NOPTS_VALUE;
         }
 
+        // we need to get duration slightly different for matroska embedded text subtitels
+        if(m_bMatroska && stream->codec && stream->codec->codec_id == AV_CODEC_ID_TEXT && m_pkt.pkt.convergence_duration != 0)
+          m_pkt.pkt.duration = m_pkt.pkt.convergence_duration;
+
         if(m_bAVI && stream->codec && stream->codec->codec_type == AVMEDIA_TYPE_VIDEO)
         {
           // AVI's always have borked pts, specially if m_pFormatContext->flags includes
@@ -883,7 +887,7 @@ DemuxPacket* CDVDDemuxFFmpeg::Read()
         pPacket->iStreamId = m_pkt.pkt.stream_index;
       }
       m_pkt.result = -1;
-      av_packet_unref(&m_pkt.pkt);
+      av_free_packet(&m_pkt.pkt);
     }
   }
   } // end of lock scope
@@ -945,7 +949,7 @@ bool CDVDDemuxFFmpeg::SeekTime(int time, bool backwords, double *startpts)
     time = 0;
 
   m_pkt.result = -1;
-  av_packet_unref(&m_pkt.pkt);
+  av_free_packet(&m_pkt.pkt);
 
   CDVDInputStream::IPosTime* ist = m_pInput->GetIPosTime();
   if (ist)
@@ -1012,7 +1016,7 @@ bool CDVDDemuxFFmpeg::SeekByte(int64_t pos)
     UpdateCurrentPTS();
 
   m_pkt.result = -1;
-  av_packet_unref(&m_pkt.pkt);
+  av_free_packet(&m_pkt.pkt);
 
   return (ret >= 0);
 }
diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxGame.cpp b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxGame.cpp
new file mode 100644
index 0000000..5fb51ad
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxGame.cpp
@@ -0,0 +1,306 @@
+/*
+ *      Copyright (C) 2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "DVDDemuxGame.h"
+
+CDVDDemuxGame::CDVDDemuxGame(CDVDInputStream *pInput) :
+  m_pInput(pInput),
+  m_IDemux(nullptr)
+{
+}
+
+CDVDDemuxGame::~CDVDDemuxGame()
+{
+  Dispose();
+}
+
+bool CDVDDemuxGame::Open()
+{
+  Abort();
+
+  m_IDemux = m_pInput->GetIDemux();
+  if (!m_IDemux)
+    return false;
+
+  if (!m_IDemux->OpenDemux())
+    return false;
+
+  RequestStreams();
+
+  return true;
+}
+
+void CDVDDemuxGame::Dispose()
+{
+  m_IDemux = nullptr;
+}
+
+void CDVDDemuxGame::Reset()
+{
+  Open();
+}
+
+void CDVDDemuxGame::Abort()
+{
+  if (m_IDemux)
+    m_IDemux->AbortDemux();
+}
+
+void CDVDDemuxGame::Flush()
+{
+  if (m_IDemux)
+    m_IDemux->FlushDemux();
+}
+
+DemuxPacket* CDVDDemuxGame::Read()
+{
+  DemuxPacket *pPacket = m_IDemux->ReadDemux();
+  if (pPacket)
+    ParsePacket(pPacket);
+
+  return pPacket;
+}
+
+bool CDVDDemuxGame::SeekTime(int timems, bool backwards, double *startpts)
+{
+  if (m_IDemux)
+    return m_IDemux->SeekTime(timems, backwards, startpts);
+
+  return false;
+}
+
+void CDVDDemuxGame::SetSpeed(int speed)
+{
+  if (m_IDemux)
+    m_IDemux->SetSpeed(speed);
+}
+
+int CDVDDemuxGame::GetStreamLength()
+{
+  return 0; // TODO
+}
+
+std::vector<CDemuxStream*> CDVDDemuxGame::GetStreams() const
+{
+  std::vector<CDemuxStream*> streams;
+
+  if (m_IDemux)
+    streams = m_IDemux->GetStreams();
+
+  return streams;
+}
+
+CDemuxStream* CDVDDemuxGame::GetStream(int iStreamId) const
+{
+  if (m_IDemux)
+    return m_IDemux->GetStream(iStreamId);
+
+  return nullptr;
+}
+
+int CDVDDemuxGame::GetNrOfStreams() const
+{
+  if (m_IDemux)
+    return m_IDemux->GetNrOfStreams();
+
+  return 0;
+}
+
+std::string CDVDDemuxGame::GetFileName()
+{
+  if (m_pInput)
+    return m_pInput->GetFileName();
+  else
+    return "";
+}
+
+std::string CDVDDemuxGame::GetStreamCodecName(int iStreamId)
+{
+  std::string strName;
+
+  CDemuxStream *stream = GetStream(iStreamId);
+  if (stream)
+  {
+    switch (stream->codec)
+    {
+    case AV_CODEC_ID_AC3:
+      strName = "ac3";
+      break;
+    case AV_CODEC_ID_MP2:
+      strName = "mpeg2audio";
+      break;
+    case AV_CODEC_ID_AAC:
+      strName = "aac";
+      break;
+    case AV_CODEC_ID_DTS:
+      strName = "dts";
+      break;
+    case AV_CODEC_ID_MPEG2VIDEO:
+      strName = "mpeg2video";
+      break;
+    case AV_CODEC_ID_H264:
+      strName = "h264";
+      break;
+    case AV_CODEC_ID_EAC3:
+      strName = "eac3";
+      break;
+    case AV_CODEC_ID_HEVC:
+      strName = "hevc";
+      break;
+    default:
+      break;
+    }
+  }
+  return strName;
+}
+
+void CDVDDemuxGame::EnableStream(int id, bool enable)
+{
+  if (m_IDemux)
+    m_IDemux->EnableStream(id, enable);
+}
+
+void CDVDDemuxGame::ParsePacket(DemuxPacket* pkt)
+{
+  if (pkt->iStreamId == 1)
+    ; // TODO: Video
+  else if (pkt->iStreamId == 2)
+    ; // TODO: Audio
+}
+
+void CDVDDemuxGame::RequestStreams()
+{
+  /* TODO
+  int nbStreams = m_IDemux->GetNrOfStreams();
+
+  int i;
+  for (i = 0; i < nbStreams; ++i)
+  {
+    CDemuxStream *stream = m_IDemux->GetStream(i);
+    if (!stream)
+    {
+      CLog::Log(LOGERROR, "CDVDDemuxGame::RequestStreams - invalid stream at pos %d", i);
+      DisposeStreams();
+      return;
+    }
+
+    if (stream->type == STREAM_AUDIO)
+    {
+      CDemuxStreamAudio *source = dynamic_cast<CDemuxStreamAudio*>(stream);
+      if (!source)
+      {
+        CLog::Log(LOGERROR, "CDVDDemuxGame::RequestStreams - invalid audio stream at pos %d", i);
+        DisposeStreams();
+        return;
+      }
+      CDemuxStreamAudioClient* st = nullptr;
+      if (m_streams[i])
+      {
+        st = dynamic_cast<CDemuxStreamAudioClient*>(m_streams[i]);
+        if (!st || (st->codec != source->codec))
+          DisposeStream(i);
+      }
+      if (!m_streams[i])
+      {
+        st = new CDemuxStreamAudioClient();
+        st->m_parser = av_parser_init(source->codec);
+        if(st->m_parser)
+          st->m_parser->flags |= PARSER_FLAG_COMPLETE_FRAMES;
+      }
+      st->iChannels       = source->iChannels;
+      st->iSampleRate     = source->iSampleRate;
+      st->iBlockAlign     = source->iBlockAlign;
+      st->iBitRate        = source->iBitRate;
+      st->iBitsPerSample  = source->iBitsPerSample;
+      if (source->ExtraSize > 0 && source->ExtraData)
+      {
+        st->ExtraData = new uint8_t[source->ExtraSize];
+        st->ExtraSize = source->ExtraSize;
+        for (unsigned int j=0; j<source->ExtraSize; j++)
+          st->ExtraData[j] = source->ExtraData[j];
+      }
+      m_streams[i] = st;
+      st->m_parser_split = true;
+      st->changes++;
+    }
+    else if (stream->type == STREAM_VIDEO)
+    {
+      CDemuxStreamVideo *source = dynamic_cast<CDemuxStreamVideo*>(stream);
+      if (!source)
+      {
+        CLog::Log(LOGERROR, "CDVDDemuxGame::RequestStreams - invalid video stream at pos %d", i);
+        DisposeStreams();
+        return;
+      }
+      CDemuxStreamVideoClient* st = nullptr;
+      if (m_streams[i])
+      {
+        st = dynamic_cast<CDemuxStreamVideoClient*>(m_streams[i]);
+        if (!st
+            || (st->codec != source->codec)
+            || (st->iWidth != source->iWidth)
+            || (st->iHeight != source->iHeight))
+          DisposeStream(i);
+      }
+      if (!m_streams[i])
+      {
+        st = new CDemuxStreamVideoClient();
+        st->m_parser = av_parser_init(source->codec);
+        if(st->m_parser)
+          st->m_parser->flags |= PARSER_FLAG_COMPLETE_FRAMES;
+      }
+      st->iFpsScale       = source->irFpsScale;
+      st->iFpsRate        = source->irFpsRate;
+      st->iHeight         = source->iHeight;
+      st->iWidth          = source->iWidth;
+      st->fAspect         = source->fAspect;
+      st->stereo_mode     = "mono";
+      if (source->ExtraSize > 0 && source->ExtraData)
+      {
+        st->ExtraData = new uint8_t[source->ExtraSize];
+        st->ExtraSize = source->ExtraSize;
+        for (unsigned int j=0; j<source->ExtraSize; j++)
+          st->ExtraData[j] = source->ExtraData[j];
+      }
+      m_streams[i] = st;
+      st->m_parser_split = true;
+    }
+    else
+    {
+      if (m_streams[i])
+        DisposeStream(i);
+      m_streams[i] = new CDemuxStream();
+    }
+
+    m_streams[i]->codec = stream->codec;
+    m_streams[i]->iId = i;
+    m_streams[i]->iPhysicalId = stream->iPhysicalId;
+    for (int j=0; j<4; j++)
+      m_streams[i]->language[j] = stream->language[j];
+
+    m_streams[i]->realtime = stream->realtime;
+
+    CLog::Log(LOGDEBUG,"CDVDDemuxGame::RequestStreams(): added/updated stream %d:%d with codec_id %d",
+        m_streams[i]->iId,
+        m_streams[i]->iPhysicalId,
+        m_streams[i]->codec);
+  }
+  */
+}
diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxGame.h b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxGame.h
new file mode 100644
index 0000000..234de05
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxGame.h
@@ -0,0 +1,58 @@
+/*
+ *      Copyright (C) 2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+#include "DVDDemux.h"
+#include "DVDInputStreams/DVDInputStream.h"
+
+class CDVDDemuxGame : public CDVDDemux
+{
+public:
+  CDVDDemuxGame(CDVDInputStream *pInput);
+
+  virtual ~CDVDDemuxGame();
+
+  bool Open();
+  void Dispose();
+
+  // implementation of CDVDDemux
+  virtual void Reset() override;
+  virtual void Abort() override;
+  virtual void Flush() override;
+  virtual DemuxPacket* Read() override;
+  virtual bool SeekTime(int time, bool backwords = false, double* startpts = NULL) override;
+  virtual void SetSpeed(int iSpeed) override;
+  virtual int GetStreamLength() override;
+  virtual std::vector<CDemuxStream*> GetStreams() const override;
+  virtual int GetNrOfStreams() const override;
+  virtual std::string GetFileName() override;
+  virtual std::string GetStreamCodecName(int iStreamId) override;
+  virtual void EnableStream(int id, bool enable) override;
+
+protected:
+  virtual CDemuxStream* GetStream(int iStreamId) const override;
+
+private:
+  void RequestStreams();
+  void ParsePacket(DemuxPacket* pPacket);
+  
+  CDVDInputStream* const m_pInput;
+  CDVDInputStream::IDemux* m_IDemux;
+};
diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxUtils.cpp b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxUtils.cpp
index df0f35b..d32e698 100644
--- a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxUtils.cpp
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxUtils.cpp
@@ -24,11 +24,6 @@
 #include "DVDDemuxUtils.h"
 #include "DVDClock.h"
 #include "utils/log.h"
-#include "system.h"
-
-#ifdef TARGET_POSIX
-#include "linux/XMemUtils.h"
-#endif
 
 extern "C" {
 #include "libavcodec/avcodec.h"
diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxVobsub.cpp b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxVobsub.cpp
index a241dcb..90d3eb7 100644
--- a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxVobsub.cpp
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDDemuxVobsub.cpp
@@ -23,8 +23,7 @@
 #include "DVDInputStreams/DVDInputStream.h"
 #include "DVDStreamInfo.h"
 #include "DVDCodecs/DVDCodecs.h"
-#include "DVDDemuxFFmpeg.h"
-#include "DVDDemuxPacket.h"
+#include "DVDDemuxers/DVDDemuxFFmpeg.h"
 #include "DVDClock.h"
 #include "DVDSubtitles/DVDSubtitleStream.h"
 
diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDFactoryDemuxer.cpp b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDFactoryDemuxer.cpp
index 84c3276..3385d2e 100644
--- a/xbmc/cores/VideoPlayer/DVDDemuxers/DVDFactoryDemuxer.cpp
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/DVDFactoryDemuxer.cpp
@@ -28,6 +28,7 @@
 #include "DVDDemuxBXA.h"
 #include "DVDDemuxCDDA.h"
 #include "DVDDemuxClient.h"
+#include "DVDDemuxGame.h"
 #include "DemuxMultiSource.h"
 #include "pvr/PVRManager.h"
 #include "pvr/addons/PVRClients.h"
@@ -39,6 +40,15 @@ CDVDDemux* CDVDFactoryDemuxer::CreateDemuxer(CDVDInputStream* pInputStream, bool
   if (!pInputStream)
     return NULL;
 
+  if (pInputStream->IsStreamType(DVDSTREAM_TYPE_GAME))
+  {
+    std::unique_ptr<CDVDDemuxGame> demuxer(new CDVDDemuxGame(pInputStream));
+    if (demuxer->Open())
+      return demuxer.release();
+    else
+      return nullptr;
+  }
+
   // Try to open the AirTunes demuxer
   if (pInputStream->IsStreamType(DVDSTREAM_TYPE_FILE) && pInputStream->GetContent().compare("audio/x-xbmc-pcm") == 0 )
   {
diff --git a/xbmc/cores/VideoPlayer/DVDDemuxers/Makefile.in b/xbmc/cores/VideoPlayer/DVDDemuxers/Makefile.in
index e4f8aed..65678bd 100644
--- a/xbmc/cores/VideoPlayer/DVDDemuxers/Makefile.in
+++ b/xbmc/cores/VideoPlayer/DVDDemuxers/Makefile.in
@@ -6,6 +6,7 @@ SRCS += DVDDemuxBXA.cpp
 SRCS += DVDDemuxCDDA.cpp
 SRCS += DVDDemuxFFmpeg.cpp
 SRCS += DVDDemuxClient.cpp
+SRCS += DVDDemuxGame.cpp
 SRCS += DVDDemuxUtils.cpp
 SRCS += DVDDemuxVobsub.cpp
 SRCS += DVDDemuxCC.cpp
diff --git a/xbmc/cores/VideoPlayer/DVDFileInfo.cpp b/xbmc/cores/VideoPlayer/DVDFileInfo.cpp
index cf59f83..b75ab94 100644
--- a/xbmc/cores/VideoPlayer/DVDFileInfo.cpp
+++ b/xbmc/cores/VideoPlayer/DVDFileInfo.cpp
@@ -18,8 +18,11 @@
  *
  */
 
-#include "DVDFileInfo.h"
+#include <string>
+#include <cstdlib>
+#include <memory>
 #include "threads/SystemClock.h"
+#include "DVDFileInfo.h"
 #include "FileItem.h"
 #include "settings/AdvancedSettings.h"
 #include "pictures/Picture.h"
@@ -53,8 +56,6 @@
 #include "Util.h"
 #include "utils/LangCodeExpander.h"
 
-#include <cstdlib>
-#include <memory>
 
 bool CDVDFileInfo::GetFileDuration(const std::string &path, int& duration)
 {
@@ -102,12 +103,6 @@ bool CDVDFileInfo::ExtractThumb(const std::string &strPath,
   std::string redactPath = CURL::GetRedacted(strPath);
   unsigned int nTime = XbmcThreads::SystemClockMillis();
   CFileItem item(strPath, false);
-
-  if (item.IsDiscImage() ||
-      item.IsPVR())
-    return false;
-
-  item.SetMimeTypeForInternetFile();
   CDVDInputStream *pInputStream = CDVDFactoryInputStream::CreateInputStream(NULL, item);
   if (!pInputStream)
   {
@@ -115,6 +110,20 @@ bool CDVDFileInfo::ExtractThumb(const std::string &strPath,
     return false;
   }
 
+  if (pInputStream->IsStreamType(DVDSTREAM_TYPE_DVD)
+   || pInputStream->IsStreamType(DVDSTREAM_TYPE_BLURAY))
+  {
+    CLog::Log(LOGDEBUG, "%s: disc streams not supported for thumb extraction, file: %s", __FUNCTION__, redactPath.c_str());
+    delete pInputStream;
+    return false;
+  }
+
+  if (pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER))
+  {
+    delete pInputStream;
+    return false;
+  }
+
   if (!pInputStream->Open())
   {
     CLog::Log(LOGERROR, "InputStream: Error opening, %s", redactPath.c_str());
@@ -342,7 +351,6 @@ bool CDVDFileInfo::GetFileStreamDetails(CFileItem *pItem)
     playablePath = XFILE::CStackDirectory::GetFirstStackedFile(playablePath);
 
   CFileItem item(playablePath, false);
-  item.SetMimeTypeForInternetFile();
   CDVDInputStream *pInputStream = CDVDFactoryInputStream::CreateInputStream(NULL, item);
   if (!pInputStream)
     return false;
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDFactoryInputStream.cpp b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDFactoryInputStream.cpp
index ab6d4cf..3ff9df5 100644
--- a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDFactoryInputStream.cpp
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDFactoryInputStream.cpp
@@ -27,6 +27,7 @@
 #include "DVDInputStreamPVRManager.h"
 #include "DVDInputStreamRTMP.h"
 #include "InputStreamAddon.h"
+#include "InputStreamGame.h"
 #include "InputStreamMultiSource.h"
 #ifdef HAVE_LIBBLURAY
 #include "DVDInputStreamBluray.h"
@@ -42,10 +43,11 @@
 #include "ServiceBroker.h"
 #include "addons/InputStream.h"
 #include "addons/BinaryAddonCache.h"
+#include "games/GameManager.h"
 #include "Util.h"
 
 
-CDVDInputStream* CDVDFactoryInputStream::CreateInputStream(IVideoPlayer* pPlayer, const CFileItem &fileitem, bool scanforextaudio)
+CDVDInputStream* CDVDFactoryInputStream::CreateInputStream(IVideoPlayer* pPlayer, CFileItem fileitem, bool scanforextaudio)
 {
   std::string file = fileitem.GetPath();
   if (scanforextaudio)
@@ -60,6 +62,13 @@ CDVDInputStream* CDVDFactoryInputStream::CreateInputStream(IVideoPlayer* pPlayer
     }
   }
 
+  if (fileitem.IsGame()) // TODO: Game info tag is lost
+  {
+    GAME::GameClientPtr gameClient = GAME::CGameManager::GetInstance().GetGameClient(fileitem); // TODO
+    if (gameClient)
+      return new CInputStreamGame(fileitem, gameClient);
+  }
+
   ADDON::VECADDONS addons;
   ADDON::CBinaryAddonCache &addonCache = CServiceBroker::GetBinaryAddonCache();
   addonCache.GetAddons(addons, ADDON::ADDON_INPUTSTREAM);
@@ -137,6 +146,13 @@ CDVDInputStream* CDVDFactoryInputStream::CreateInputStream(IVideoPlayer* pPlayer
     if (fileitem.IsType(".m3u8"))
       return new CDVDInputStreamFFmpeg(fileitem);
 
+    if (fileitem.ContentLookup())
+    {
+      // request header
+      fileitem.SetMimeType("");
+      fileitem.FillInMimeType();
+    }
+
     if (fileitem.GetMimeType() == "application/vnd.apple.mpegurl")
       return new CDVDInputStreamFFmpeg(fileitem);
   }
@@ -145,7 +161,7 @@ CDVDInputStream* CDVDFactoryInputStream::CreateInputStream(IVideoPlayer* pPlayer
   return (new CDVDInputStreamFile(fileitem));
 }
 
-CDVDInputStream* CDVDFactoryInputStream::CreateInputStream(IVideoPlayer* pPlayer, const CFileItem &fileitem, const std::vector<std::string>& filenames)
+CDVDInputStream* CDVDFactoryInputStream::CreateInputStream(IVideoPlayer* pPlayer, CFileItem fileitem, const std::vector<std::string>& filenames)
 {
   return (new CInputStreamMultiSource(pPlayer, fileitem, filenames));
 }
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDFactoryInputStream.h b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDFactoryInputStream.h
index 2f2b43e..0c39e88 100644
--- a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDFactoryInputStream.h
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDFactoryInputStream.h
@@ -29,6 +29,6 @@ class IVideoPlayer;
 class CDVDFactoryInputStream
 {
 public:
-  static CDVDInputStream* CreateInputStream(IVideoPlayer* pPlayer, const CFileItem &fileitem, bool scanforextaudio = false);
-  static CDVDInputStream* CreateInputStream(IVideoPlayer* pPlayer, const CFileItem &fileitem, const std::vector<std::string>& filenames);
+  static CDVDInputStream* CreateInputStream(IVideoPlayer* pPlayer, CFileItem fileitem, bool scanforextaudio = false);
+  static CDVDInputStream* CreateInputStream(IVideoPlayer* pPlayer, CFileItem fileitem, const std::vector<std::string>& filenames);
 };
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStream.cpp b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStream.cpp
index 4c05ae5..a2ef411 100644
--- a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStream.cpp
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStream.cpp
@@ -20,9 +20,8 @@
 
 #include "DVDInputStream.h"
 #include "URL.h"
-#include "DVDStreamInfo.h"
 
-CDVDInputStream::CDVDInputStream(DVDStreamType streamType, const CFileItem& fileitem)
+CDVDInputStream::CDVDInputStream(DVDStreamType streamType, CFileItem& fileitem)
 {
   m_streamType = streamType;
   m_contentLookup = true;
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStream.h b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStream.h
index 39c68b3..8321616 100644
--- a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStream.h
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStream.h
@@ -43,7 +43,8 @@ enum DVDStreamType
   DVDSTREAM_TYPE_BLURAY = 11,
   DVDSTREAM_TYPE_PVRMANAGER = 12,
   DVDSTREAM_TYPE_MULTIFILES = 13,
-  DVDSTREAM_TYPE_ADDON = 14
+  DVDSTREAM_TYPE_ADDON = 14,
+  DVDSTREAM_TYPE_GAME = 15,
 };
 
 #define SEEK_POSSIBLE 0x10 // flag used to check if protocol allows seeks
@@ -131,7 +132,6 @@ public:
     virtual bool SeekTime(int time, bool backward = false, double* startpts = NULL) = 0;
     virtual void AbortDemux() = 0;
     virtual void FlushDemux() = 0;
-    virtual void SetVideoResolution(int width, int height) {};
   };
 
   enum ENextStream
@@ -141,7 +141,7 @@ public:
     NEXTSTREAM_RETRY,
   };
 
-  CDVDInputStream(DVDStreamType m_streamType, const CFileItem& fileitem);
+  CDVDInputStream(DVDStreamType m_streamType, CFileItem& fileitem);
   virtual ~CDVDInputStream();
   virtual bool Open();
   virtual void Close();
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamBluray.cpp b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamBluray.cpp
index f37668e..7ab8d8e 100644
--- a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamBluray.cpp
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamBluray.cpp
@@ -41,10 +41,6 @@
 #include "utils/LangCodeExpander.h"
 #include "filesystem/SpecialProtocol.h"
 
-#ifdef TARGET_POSIX
-#include "linux/XTimeUtils.h"
-#endif
-
 #define LIBBLURAY_BYTESEEK 0
 
 using namespace XFILE;
@@ -187,7 +183,7 @@ void  bluray_overlay_argb_cb(void *this_gen, const struct bd_argb_overlay_s * co
 }
 #endif
 
-CDVDInputStreamBluray::CDVDInputStreamBluray(IVideoPlayer* player, const CFileItem& fileitem) :
+CDVDInputStreamBluray::CDVDInputStreamBluray(IVideoPlayer* player, CFileItem& fileitem) :
   CDVDInputStream(DVDSTREAM_TYPE_BLURAY, fileitem)
 {
   m_title = NULL;
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamBluray.h b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamBluray.h
index b967a85..14ae289 100644
--- a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamBluray.h
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamBluray.h
@@ -47,7 +47,7 @@ class CDVDInputStreamBluray
   , public CDVDInputStream::IMenus
 {
 public:
-  CDVDInputStreamBluray(IVideoPlayer* player, const CFileItem& fileitem);
+  CDVDInputStreamBluray(IVideoPlayer* player, CFileItem& fileitem);
   virtual ~CDVDInputStreamBluray();
   virtual bool Open();
   virtual void Close();
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamFFmpeg.cpp b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamFFmpeg.cpp
index cb6d890..5d81e57 100644
--- a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamFFmpeg.cpp
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamFFmpeg.cpp
@@ -32,7 +32,7 @@
 using namespace XFILE;
 using PLAYLIST::CPlayListM3U;
 
-CDVDInputStreamFFmpeg::CDVDInputStreamFFmpeg(const CFileItem& fileitem)
+CDVDInputStreamFFmpeg::CDVDInputStreamFFmpeg(CFileItem& fileitem)
   : CDVDInputStream(DVDSTREAM_TYPE_FFMPEG, fileitem)
   , m_can_pause(false)
   , m_can_seek(false)
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamFFmpeg.h b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamFFmpeg.h
index ffcdb78..2a3404e 100644
--- a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamFFmpeg.h
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamFFmpeg.h
@@ -26,7 +26,7 @@ class CDVDInputStreamFFmpeg
   : public CDVDInputStream
 {
 public:
-  CDVDInputStreamFFmpeg(const CFileItem& fileitem);
+  CDVDInputStreamFFmpeg(CFileItem& fileitem);
   virtual ~CDVDInputStreamFFmpeg();
   virtual bool Open();
   virtual void Close();
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamFile.cpp b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamFile.cpp
index 772de5a..613857f 100644
--- a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamFile.cpp
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamFile.cpp
@@ -27,7 +27,7 @@
 
 using namespace XFILE;
 
-CDVDInputStreamFile::CDVDInputStreamFile(const CFileItem& fileitem) : CDVDInputStream(DVDSTREAM_TYPE_FILE, fileitem)
+CDVDInputStreamFile::CDVDInputStreamFile(CFileItem& fileitem) : CDVDInputStream(DVDSTREAM_TYPE_FILE, fileitem)
 {
   m_pFile = NULL;
   m_eof = true;
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamFile.h b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamFile.h
index 53f3478..8914719 100644
--- a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamFile.h
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamFile.h
@@ -25,7 +25,7 @@
 class CDVDInputStreamFile : public CDVDInputStream
 {
 public:
-  CDVDInputStreamFile(const CFileItem& fileitem);
+  CDVDInputStreamFile(CFileItem& fileitem);
   virtual ~CDVDInputStreamFile();
   virtual bool Open();
   virtual void Close();
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamNavigator.cpp b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamNavigator.cpp
index 06e59e1..5cb7198 100644
--- a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamNavigator.cpp
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamNavigator.cpp
@@ -38,7 +38,7 @@
 #define HOLDMODE_SKIP 2 /* set by inputstream user, when they wish to skip the held mode */
 #define HOLDMODE_DATA 3 /* set after hold mode has been exited, and action that inited it has been executed */
 
-CDVDInputStreamNavigator::CDVDInputStreamNavigator(IVideoPlayer* player, const CFileItem& fileitem)
+CDVDInputStreamNavigator::CDVDInputStreamNavigator(IVideoPlayer* player, CFileItem& fileitem)
   : CDVDInputStream(DVDSTREAM_TYPE_DVD, fileitem)
 {
   m_dvdnav = 0;
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamNavigator.h b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamNavigator.h
index d1b553b..005f11b 100644
--- a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamNavigator.h
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamNavigator.h
@@ -21,7 +21,6 @@
  */
 
 #include "DVDInputStream.h"
-#include "DVDDemuxers/DVDDemux.h"
 #include "../IVideoPlayer.h"
 #include "../DVDCodecs/Overlay/DVDOverlaySpu.h"
 #include <string>
@@ -109,7 +108,7 @@ class CDVDInputStreamNavigator
   , public CDVDInputStream::IMenus
 {
 public:
-  CDVDInputStreamNavigator(IVideoPlayer* player, const CFileItem& fileitem);
+  CDVDInputStreamNavigator(IVideoPlayer* player, CFileItem& fileitem);
   virtual ~CDVDInputStreamNavigator();
 
   virtual bool Open();
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamPVRManager.cpp b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamPVRManager.cpp
index ec03c9d..09f1a31 100644
--- a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamPVRManager.cpp
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamPVRManager.cpp
@@ -20,7 +20,6 @@
 
 #include "DVDFactoryInputStream.h"
 #include "DVDInputStreamPVRManager.h"
-#include "DVDDemuxers/DVDDemuxPacket.h"
 #include "URL.h"
 #include "pvr/PVRManager.h"
 #include "pvr/channels/PVRChannel.h"
@@ -41,7 +40,7 @@ using namespace PVR;
  * Description: Class constructor, initialize member variables
  *              public class is CDVDInputStream
  */
-CDVDInputStreamPVRManager::CDVDInputStreamPVRManager(IVideoPlayer* pPlayer, const CFileItem& fileitem)
+CDVDInputStreamPVRManager::CDVDInputStreamPVRManager(IVideoPlayer* pPlayer, CFileItem& fileitem)
   : CDVDInputStream(DVDSTREAM_TYPE_PVRMANAGER, fileitem)
 {
   m_pPlayer = pPlayer;
@@ -156,8 +155,6 @@ bool CDVDInputStreamPVRManager::Open()
     m_isOtherStreamHack = true;
     
     m_item.SetPath(transFile);
-    m_item.SetMimeTypeForInternetFile();
-
     m_pOtherStream = CDVDFactoryInputStream::CreateInputStream(m_pPlayer, m_item);
     if (!m_pOtherStream)
     {
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamPVRManager.h b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamPVRManager.h
index d037b19..82958fa 100644
--- a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamPVRManager.h
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamPVRManager.h
@@ -44,7 +44,7 @@ class CDVDInputStreamPVRManager
   , public CDVDInputStream::IDemux
 {
 public:
-  CDVDInputStreamPVRManager(IVideoPlayer* pPlayer, const CFileItem& fileitem);
+  CDVDInputStreamPVRManager(IVideoPlayer* pPlayer, CFileItem& fileitem);
   virtual ~CDVDInputStreamPVRManager();
   virtual bool Open() override;
   virtual void Close() override;
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamRTMP.cpp b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamRTMP.cpp
index 9a4b889..d44f07f 100644
--- a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamRTMP.cpp
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamRTMP.cpp
@@ -62,7 +62,7 @@ extern "C"
   }
 }
 
-CDVDInputStreamRTMP::CDVDInputStreamRTMP(const CFileItem &fileitem)
+CDVDInputStreamRTMP::CDVDInputStreamRTMP(CFileItem &fileitem)
   : CDVDInputStream(DVDSTREAM_TYPE_RTMP, fileitem)
   , m_canSeek(true)
   , m_canPause(true)
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamRTMP.h b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamRTMP.h
index 5af246a..a7a1b22 100644
--- a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamRTMP.h
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamRTMP.h
@@ -29,7 +29,7 @@ class CDVDInputStreamRTMP
   , public CDVDInputStream::IPosTime
 {
 public:
-  CDVDInputStreamRTMP(const CFileItem &fileitem);
+  CDVDInputStreamRTMP(CFileItem &fileitem);
   virtual ~CDVDInputStreamRTMP();
   virtual bool Open();
   virtual void Close();
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamStack.cpp b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamStack.cpp
index e91c014..845ef6b 100644
--- a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamStack.cpp
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamStack.cpp
@@ -28,7 +28,7 @@
 
 using namespace XFILE;
 
-CDVDInputStreamStack::CDVDInputStreamStack(const CFileItem& fileitem) : CDVDInputStream(DVDSTREAM_TYPE_FILE, fileitem)
+CDVDInputStreamStack::CDVDInputStreamStack(CFileItem& fileitem) : CDVDInputStream(DVDSTREAM_TYPE_FILE, fileitem)
 {
   m_eof = true;
   m_pos = 0;
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamStack.h b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamStack.h
index a00fed4..3c28f8c 100644
--- a/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamStack.h
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/DVDInputStreamStack.h
@@ -26,7 +26,7 @@
 class CDVDInputStreamStack : public CDVDInputStream
 {
 public:
-  CDVDInputStreamStack(const CFileItem& fileitem);
+  CDVDInputStreamStack(CFileItem& fileitem);
   virtual ~CDVDInputStreamStack();
 
   virtual bool    Open();
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamAddon.cpp b/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamAddon.cpp
index 3281ea2..0f8254e 100644
--- a/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamAddon.cpp
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamAddon.cpp
@@ -22,7 +22,7 @@
 #include "addons/InputStream.h"
 #include "cores/VideoPlayer/DVDClock.h"
 
-CInputStreamAddon::CInputStreamAddon(const CFileItem& fileitem, ADDON::CInputStream *inputStream)
+CInputStreamAddon::CInputStreamAddon(CFileItem& fileitem, ADDON::CInputStream *inputStream)
 : CDVDInputStream(DVDSTREAM_TYPE_ADDON, fileitem), m_addon(inputStream)
 {
   m_hasDemux = false;
@@ -265,11 +265,3 @@ void CInputStreamAddon::FlushDemux()
 
   m_addon->FlushDemux();
 }
-
-void CInputStreamAddon::SetVideoResolution(int width, int height)
-{
-  if (!m_addon)
-    return;
-
-  m_addon->SetVideoResolution(width, height);
-}
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamAddon.h b/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamAddon.h
index 64a060f..5fffe87 100644
--- a/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamAddon.h
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamAddon.h
@@ -32,7 +32,7 @@ class CInputStreamAddon :
 {
 public:
   //! \brief constructor
-  CInputStreamAddon(const CFileItem& fileitem, ADDON::CInputStream *inputStream);
+  CInputStreamAddon(CFileItem& fileitem, ADDON::CInputStream *inputStream);
 
   //! \brief Destructor.
   virtual ~CInputStreamAddon();
@@ -83,7 +83,6 @@ public:
   virtual bool SeekTime(int time, bool backward = false, double* startpts = NULL) override;
   virtual void AbortDemux() override;
   virtual void FlushDemux() override;
-  virtual void SetVideoResolution(int width, int height) override;
 
 protected:
   ADDON::CInputStream *m_addon;
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamGame.cpp b/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamGame.cpp
new file mode 100644
index 0000000..a0e3f05
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamGame.cpp
@@ -0,0 +1,329 @@
+/*
+ *      Copyright (C) 2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "InputStreamGame.h"
+#include "cores/AudioEngine/Utils/AEChannelInfo.h"
+#include "cores/AudioEngine/Utils/AEUtil.h"
+#include "cores/VideoPlayer/DVDDemuxers/DVDDemuxUtils.h"
+#include "games/addons/GameClient.h"
+
+#include <cstring>
+
+#define GAME_STREAM_VIDEO_ID  1
+#define GAME_STREAM_AUDIO_ID  2
+
+// --- CInputStreamGame --------------------------------------------------------
+
+CInputStreamGame::CInputStreamGame(CFileItem &fileitem, const GAME::GameClientPtr &gameClient) :
+  CDVDInputStream(DVDSTREAM_TYPE_GAME, fileitem),
+  m_gameClient(gameClient),
+  m_pDisplayTime(nullptr),
+  m_pPosTime(nullptr),
+  m_pDemux(new CInputStreamGameDemux(gameClient))
+{
+  // initialize CDVDInputStream
+  SetRealtime(true);
+}
+
+CInputStreamGame::~CInputStreamGame()
+{
+  Close();
+
+  delete m_pDisplayTime;
+  delete m_pPosTime;
+  delete m_pDemux;
+}
+
+bool CInputStreamGame::Open()
+{
+  bool bSuccess = false;
+
+  if (m_gameClient->Initialize())
+  {
+    /* TODO
+    bool hasDisplayTime = m_gameClient->CanSeek(); // TODO
+    bool hasPosTime = m_gameClient->CanSeek(); // TODO
+
+    if (hasDisplayTime)
+    {
+      delete m_pDisplayTime;
+      m_pDisplayTime = new CInputStreamGameDisplayTime(m_gameClient);
+    }
+
+    if (hasPosTime)
+    {
+      delete m_pPosTime;
+      m_pPosTime = new CInputStreamGamePosTime(m_gameClient);
+    }
+    */
+
+    bSuccess = m_gameClient->OpenFile(m_item, static_cast<CInputStreamGameDemux*>(m_pDemux));
+
+    if (!bSuccess)
+      m_gameClient->Destroy();
+  }
+
+  return bSuccess;
+}
+
+void CInputStreamGame::Close()
+{
+  m_gameClient->CloseFile();
+  m_gameClient->Destroy();
+}
+
+CDVDInputStream::ENextStream CInputStreamGame::NextStream()
+{
+  bool bIsPlaying = m_gameClient->IsPlaying();
+  return bIsPlaying ? NEXTSTREAM_RETRY : NEXTSTREAM_NONE;
+}
+
+// --- CInputStreamGameDisplayTime ---------------------------------------------
+
+CInputStreamGameDisplayTime::CInputStreamGameDisplayTime(const GAME::GameClientPtr &gameClient) :
+  m_gameClient(gameClient)
+{
+}
+
+int CInputStreamGameDisplayTime::GetTotalTime()
+{
+  return 0; // TODO
+}
+
+int CInputStreamGameDisplayTime::GetTime()
+{
+  return 0; // TODO
+}
+
+// --- CInputStreamGamePosTime -------------------------------------------------
+
+CInputStreamGamePosTime::CInputStreamGamePosTime(const GAME::GameClientPtr &gameClient) :
+  m_gameClient(gameClient)
+{
+}
+
+bool CInputStreamGamePosTime::PosTime(int ms)
+{
+  return false; // TODO
+}
+
+// --- CInputStreamGameDemux ---------------------------------------------------
+
+CInputStreamGameDemux::CInputStreamGameDemux(const GAME::GameClientPtr &gameClient) :
+  m_gameClient(gameClient),
+  m_videoStream(nullptr),
+  m_audioStream(nullptr)
+{
+}
+
+CInputStreamGameDemux::~CInputStreamGameDemux()
+{
+  delete m_videoStream;
+  delete m_audioStream;
+}
+
+bool CInputStreamGameDemux::OpenDemux()
+{
+  return true;
+}
+
+DemuxPacket* CInputStreamGameDemux::ReadDemux()
+{
+  using namespace GAME;
+
+  DemuxPacket *pPacket = nullptr;
+
+  CGameClient::STREAM_TYPE streamType = CGameClient::STREAM_TYPE::NONE;
+  if (m_gameClient->ReadDemux(m_buffer, streamType))
+  {
+    pPacket = CDVDDemuxUtils::AllocateDemuxPacket(m_buffer.size());
+
+    if (pPacket)
+    {
+      std::memcpy(pPacket->pData, m_buffer.data(), m_buffer.size());
+
+      pPacket->iSize = m_buffer.size();
+
+      switch (streamType)
+      {
+      case CGameClient::STREAM_TYPE::VIDEO:
+        pPacket->iStreamId = GAME_STREAM_VIDEO_ID;
+        break;
+      case CGameClient::STREAM_TYPE::AUDIO:
+        pPacket->iStreamId = GAME_STREAM_AUDIO_ID;
+        break;
+      default:
+        break;
+      }
+    }
+  }
+
+  m_buffer.clear();
+
+  return pPacket;
+}
+
+CDemuxStream* CInputStreamGameDemux::GetStream(int iStreamId) const
+{
+  switch (iStreamId)
+  {
+    case GAME_STREAM_VIDEO_ID:
+      return m_videoStream;
+    case GAME_STREAM_AUDIO_ID:
+      return m_audioStream;
+    default:
+      break;
+  }
+
+  return nullptr;
+}
+
+std::vector<CDemuxStream*> CInputStreamGameDemux::GetStreams() const
+{
+  std::vector<CDemuxStream*> streams;
+
+  if (m_videoStream)
+    streams.push_back(m_videoStream);
+  if (m_audioStream)
+    streams.push_back(m_audioStream);
+
+  return streams;
+}
+
+void CInputStreamGameDemux::EnableStream(int iStreamId, bool enable)
+{
+  switch (iStreamId)
+  {
+    case GAME_STREAM_VIDEO_ID:
+      if (m_videoStream)
+        m_videoStream->disabled = !enable;
+      break;
+    case GAME_STREAM_AUDIO_ID:
+      if (m_audioStream)
+        m_audioStream->disabled = !enable;
+      break;
+    default:
+      break;
+  }
+}
+
+int CInputStreamGameDemux::GetNrOfStreams() const
+{
+  unsigned int count = 0;
+
+  if (m_videoStream)
+    count++;
+  if (m_audioStream)
+    count++;
+
+  return count;
+}
+
+void CInputStreamGameDemux::SetSpeed(int iSpeed)
+{
+  const double speed = static_cast<double>(iSpeed); // TODO: Correct conversion?
+  //m_gameClient->SetSpeed(speed); // TODO
+}
+
+bool CInputStreamGameDemux::SeekTime(int time, bool backward, double* startpts)
+{
+  /* TODO
+  if (m_gameClient->CanSeek())
+  {
+    // TODO
+    if (startpts)
+      *startpts = DVD_NOPTS_VALUE;
+    return true;
+  }
+  */
+
+  return false; // m_gameClient->SeekTime(time, backward, startpts); // TODO
+}
+
+void CInputStreamGameDemux::AbortDemux()
+{
+  m_gameClient->CloseFile();
+}
+
+void CInputStreamGameDemux::FlushDemux()
+{
+  m_gameClient->FlushDemux();
+}
+
+void CInputStreamGameDemux::OpenVideoStream(AVCodecID codec,
+                                            AVPixelFormat pixfmt,
+                                            unsigned int width,
+                                            unsigned int height)
+{
+  if (!m_videoStream)
+    m_videoStream = new CDemuxStreamVideo;
+  else
+    m_videoStream->changes++;
+
+  // Stream
+  m_videoStream->uniqueId = GAME_STREAM_VIDEO_ID;
+  m_videoStream->codec = codec;
+  m_videoStream->codec_fourcc = 0; // TODO
+  m_videoStream->type = STREAM_VIDEO;
+  m_videoStream->source = STREAM_SOURCE_DEMUX;
+  m_videoStream->realtime = true;
+  m_videoStream->disabled = false;
+
+  // Video
+  m_videoStream->pixfmt = pixfmt;
+  m_videoStream->iHeight = height;
+  m_videoStream->iWidth = width;
+}
+
+void CInputStreamGameDemux::CloseVideoStream()
+{
+  delete m_videoStream;
+  m_videoStream = nullptr;
+}
+
+void CInputStreamGameDemux::OpenAudioStream(AVCodecID codec,
+                                            unsigned int samplerate,
+                                            const CAEChannelInfo& channelLayout)
+{
+  if (!m_audioStream)
+    m_audioStream = new CDemuxStreamAudio;
+  else
+    m_audioStream->changes++;
+
+  // Stream
+  m_audioStream->uniqueId = GAME_STREAM_AUDIO_ID;
+  m_audioStream->codec = codec;
+  m_audioStream->codec_fourcc = 0; // TODO
+  m_audioStream->type = STREAM_AUDIO;
+  m_audioStream->source = STREAM_SOURCE_DEMUX;
+  m_audioStream->realtime = true;
+  m_audioStream->disabled = false;
+
+  // Audio
+  m_audioStream->iChannels = channelLayout.Count();
+  m_audioStream->iSampleRate = samplerate;
+  m_audioStream->iChannelLayout = CAEUtil::GetAVChannelLayout(channelLayout);
+}
+
+void CInputStreamGameDemux::CloseAudioStream()
+{
+  delete m_audioStream;
+  m_audioStream = nullptr;
+}
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamGame.h b/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamGame.h
new file mode 100644
index 0000000..ddb3b32
--- /dev/null
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamGame.h
@@ -0,0 +1,122 @@
+/*
+ *      Copyright (C) 2012-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+#include "DVDInputStream.h"
+#include "cores/VideoPlayer/DVDDemuxers/DVDDemux.h"
+#include "games/addons/GameClient.h"
+
+#include <stdint.h>
+#include <vector>
+
+class CInputStreamGame : public CDVDInputStream
+{
+public:
+  CInputStreamGame(CFileItem &fileitem, const GAME::GameClientPtr &gameClient);
+
+  virtual ~CInputStreamGame();
+
+  // implementation of CDVDInputStream
+  virtual bool Open() override;
+  virtual void Close() override;
+  virtual int Read(uint8_t *buf, int buf_size) override { return -1; } // Can't read arbitrary bytes, must read full packet from demuxer
+  virtual int64_t Seek(int64_t offset, int whence) override { return -1; }
+  virtual bool Pause(double dTime) override { return false; } // Must pause demuxer
+  virtual int64_t GetLength() override { return -1; }
+  virtual ENextStream NextStream();
+  virtual bool CanSeek() override { return false; }
+  virtual bool CanPause() override { return false; }
+  virtual bool IsEOF() override { return false; } // Read until demuxer returns no data
+
+  // interfaces
+  virtual IDisplayTime* GetIDisplayTime() override { return m_pDisplayTime; }
+  virtual IPosTime* GetIPosTime() override { return m_pPosTime; }
+  virtual IDemux* GetIDemux() override { return m_pDemux; }
+
+private:
+  const GAME::GameClientPtr m_gameClient;
+  IDisplayTime* m_pDisplayTime;
+  IPosTime* m_pPosTime;
+  IDemux* m_pDemux;
+};
+
+class CInputStreamGameDisplayTime : public CDVDInputStream::IDisplayTime
+{
+public:
+  CInputStreamGameDisplayTime(const GAME::GameClientPtr &gameClient);
+
+  virtual ~CInputStreamGameDisplayTime() { }
+
+  // implementation of CDVDInputStream::IDisplayTime
+  virtual int GetTotalTime() override;
+  virtual int GetTime() override;
+
+private:
+  const GAME::GameClientPtr m_gameClient;
+};
+
+class CInputStreamGamePosTime : public CDVDInputStream::IPosTime
+{
+public:
+  CInputStreamGamePosTime(const GAME::GameClientPtr &gameClient);
+
+  virtual ~CInputStreamGamePosTime() { }
+
+  // implementation of CDVDInputStream::IPosTime
+  virtual bool PosTime(int ms) override;
+
+private:
+  const GAME::GameClientPtr m_gameClient;
+};
+
+class CInputStreamGameDemux : public CDVDInputStream::IDemux,
+                              public GAME::IGameDemuxCallback
+{
+public:
+  CInputStreamGameDemux(const GAME::GameClientPtr &gameClient);
+
+  virtual ~CInputStreamGameDemux();
+
+  // implementation of CDVDInputStream::IDemux
+  virtual bool OpenDemux() override;
+  virtual DemuxPacket* ReadDemux() override;
+  virtual CDemuxStream* GetStream(int iStreamId) const override;
+  virtual std::vector<CDemuxStream*> GetStreams() const override;
+  virtual void EnableStream(int iStreamId, bool enable) override;
+  virtual int GetNrOfStreams() const override;
+  virtual void SetSpeed(int iSpeed) override;
+  virtual bool SeekTime(int time, bool backward = false, double* startpts = NULL) override;
+  virtual void AbortDemux() override;
+  virtual void FlushDemux() override;
+
+  // implementation of IGameDemuxCallback
+  virtual void OpenVideoStream(AVCodecID codec, AVPixelFormat pixfmt, unsigned int width, unsigned int height);
+  virtual void CloseVideoStream();
+  virtual void OpenAudioStream(AVCodecID codec, unsigned int samplerate, const CAEChannelInfo& channelLayout);
+  virtual void CloseAudioStream();
+
+private:
+  const GAME::GameClientPtr m_gameClient;
+
+  CDemuxStreamVideo* m_videoStream;
+  CDemuxStreamAudio* m_audioStream;
+
+  std::vector<uint8_t> m_buffer;
+};
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamMultiSource.cpp b/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamMultiSource.cpp
index ca7f92b..908b3a8 100644
--- a/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamMultiSource.cpp
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamMultiSource.cpp
@@ -29,7 +29,7 @@
 
 using namespace XFILE;
 
-CInputStreamMultiSource::CInputStreamMultiSource(IVideoPlayer* pPlayer, const CFileItem& fileitem, const std::vector<std::string>& filenames) : InputStreamMultiStreams(DVDSTREAM_TYPE_MULTIFILES, fileitem),
+CInputStreamMultiSource::CInputStreamMultiSource(IVideoPlayer* pPlayer, CFileItem& fileitem, const std::vector<std::string>& filenames) : InputStreamMultiStreams(DVDSTREAM_TYPE_MULTIFILES, fileitem),
   m_pPlayer(pPlayer),
   m_filenames(filenames)
 {
@@ -118,7 +118,6 @@ bool CInputStreamMultiSource::Open()
   for (unsigned int i = 0; i < m_filenames.size(); i++)
   {
     CFileItem fileitem = CFileItem(m_filenames[i], false);
-    fileitem.SetMimeTypeForInternetFile();
     InputStreamPtr inputstream(CDVDFactoryInputStream::CreateInputStream(m_pPlayer, fileitem));
     if (!inputstream)
     {
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamMultiSource.h b/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamMultiSource.h
index 9185b14..2558632 100644
--- a/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamMultiSource.h
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamMultiSource.h
@@ -32,7 +32,7 @@ class CInputStreamMultiSource : public InputStreamMultiStreams
 {
 
 public:
-  CInputStreamMultiSource(IVideoPlayer* pPlayer, const CFileItem& fileitem, const std::vector<std::string>& filenames);
+  CInputStreamMultiSource(IVideoPlayer* pPlayer, CFileItem& fileitem, const std::vector<std::string>& filenames);
   virtual ~CInputStreamMultiSource();
 
   virtual void Abort() override;
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamMultiStreams.h b/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamMultiStreams.h
index 6719761..313d6dd 100644
--- a/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamMultiStreams.h
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/InputStreamMultiStreams.h
@@ -33,7 +33,7 @@ class InputStreamMultiStreams : public CDVDInputStream
   friend class CDemuxMultiSource;
 
 public:
-  InputStreamMultiStreams(DVDStreamType type, const CFileItem& fileitem)
+  InputStreamMultiStreams(DVDStreamType type, CFileItem& fileitem)
     : CDVDInputStream(type, fileitem) {}
 
   virtual ~InputStreamMultiStreams() {};
diff --git a/xbmc/cores/VideoPlayer/DVDInputStreams/Makefile b/xbmc/cores/VideoPlayer/DVDInputStreams/Makefile
index 1809e63..cbdca45 100644
--- a/xbmc/cores/VideoPlayer/DVDInputStreams/Makefile
+++ b/xbmc/cores/VideoPlayer/DVDInputStreams/Makefile
@@ -12,6 +12,7 @@ SRCS=	DVDFactoryInputStream.cpp \
 	DVDInputStreamPVRManager.cpp \
 	DVDInputStreamStack.cpp \
 	InputStreamAddon.cpp \
+	InputStreamGame.cpp \
 	InputStreamMultiSource.cpp\
 	DVDStateSerializer.cpp \
 
diff --git a/xbmc/cores/VideoPlayer/DVDMessage.cpp b/xbmc/cores/VideoPlayer/DVDMessage.cpp
index 5aed691..4879562 100644
--- a/xbmc/cores/VideoPlayer/DVDMessage.cpp
+++ b/xbmc/cores/VideoPlayer/DVDMessage.cpp
@@ -122,11 +122,3 @@ CDVDMsgDemuxerPacket::~CDVDMsgDemuxerPacket()
   if (m_packet)
     CDVDDemuxUtils::FreeDemuxPacket(m_packet);
 }
-
-unsigned int CDVDMsgDemuxerPacket::GetPacketSize()
-{
-  if (m_packet)
-    return m_packet->iSize;
-  else
-    return 0;
-}
diff --git a/xbmc/cores/VideoPlayer/DVDMessage.h b/xbmc/cores/VideoPlayer/DVDMessage.h
index 20bfd94..7424eae 100644
--- a/xbmc/cores/VideoPlayer/DVDMessage.h
+++ b/xbmc/cores/VideoPlayer/DVDMessage.h
@@ -29,11 +29,11 @@
 #endif
 
 // include as less is possible to prevent dependencies
+#include "system.h"
+#include "DVDDemuxers/DVDDemux.h"
 #include "DVDResource.h"
-#include <string>
-#include <string.h>
 
-struct DemuxPacket;
+#include <assert.h>
 
 class CDVDMsg : public IDVDResourceCounted<CDVDMsg>
 {
@@ -269,7 +269,7 @@ public:
   CDVDMsgDemuxerPacket(DemuxPacket* packet, bool drop = false);
   virtual ~CDVDMsgDemuxerPacket();
   DemuxPacket* GetPacket()      { return m_packet; }
-  unsigned int GetPacketSize();
+  unsigned int GetPacketSize()  { if(m_packet) return m_packet->iSize; else return 0; }
   bool         GetPacketDrop()  { return m_drop; }
   DemuxPacket* m_packet;
   bool         m_drop;
diff --git a/xbmc/cores/VideoPlayer/DVDMessageQueue.cpp b/xbmc/cores/VideoPlayer/DVDMessageQueue.cpp
index 7610d40..cb5d507 100644
--- a/xbmc/cores/VideoPlayer/DVDMessageQueue.cpp
+++ b/xbmc/cores/VideoPlayer/DVDMessageQueue.cpp
@@ -19,7 +19,6 @@
  */
 
 #include "DVDMessageQueue.h"
-#include "DVDDemuxers/DVDDemuxPacket.h"
 #include "utils/log.h"
 #include "threads/SingleLock.h"
 #include "DVDClock.h"
@@ -56,9 +55,13 @@ void CDVDMessageQueue::Flush(CDVDMsg::Message type)
 {
   CSingleLock lock(m_section);
 
-  m_list.remove_if([type](const DVDMessageListItem &item){
-      return type == CDVDMsg::NONE || item.message->IsType(type);
-    });
+  for (SList::iterator it = m_list.begin(); it != m_list.end();)
+  {
+    if (it->message->IsType(type) ||  type == CDVDMsg::NONE)
+      it = m_list.erase(it);
+    else
+      ++it;
+  }
 
   if (type == CDVDMsg::DEMUXER_PACKET ||  type == CDVDMsg::NONE)
   {
@@ -105,11 +108,14 @@ MsgQueueReturnCode CDVDMessageQueue::Put(CDVDMsg* pMsg, int priority)
     return MSGQ_INVALID_MSG;
   }
 
-  auto it = std::find_if(m_list.begin(), m_list.end(),
-                         [priority](const DVDMessageListItem &item){
-                           return priority <= item.priority;
-                         });
-  m_list.emplace(it, pMsg, priority);
+  SList::iterator it = m_list.begin();
+  while(it != m_list.end())
+  {
+    if(priority <= it->priority)
+      break;
+    ++it;
+  }
+  m_list.insert(it, DVDMessageListItem(pMsg, priority));
 
   if (pMsg->IsType(CDVDMsg::DEMUXER_PACKET) && priority == 0)
   {
@@ -206,9 +212,9 @@ unsigned CDVDMessageQueue::GetPacketCount(CDVDMsg::Message type)
     return 0;
 
   unsigned count = 0;
-  for (const auto &item : m_list)
+  for(SList::iterator it = m_list.begin(); it != m_list.end();++it)
   {
-    if(item.message->IsType(type))
+    if(it->message->IsType(type))
       count++;
   }
 
diff --git a/xbmc/cores/VideoPlayer/DVDMessageQueue.h b/xbmc/cores/VideoPlayer/DVDMessageQueue.h
index 3c07874..c98a02d 100644
--- a/xbmc/cores/VideoPlayer/DVDMessageQueue.h
+++ b/xbmc/cores/VideoPlayer/DVDMessageQueue.h
@@ -39,14 +39,33 @@ struct DVDMessageListItem
     message = NULL;
     priority = 0;
   }
-  DVDMessageListItem(const DVDMessageListItem&) = delete;
+  DVDMessageListItem(const DVDMessageListItem& item)
+  {
+    if (item.message)
+      message = item.message->Acquire();
+    else
+      message = NULL;
+
+    priority = item.priority;
+  }
  ~DVDMessageListItem()
   {
     if(message)
       message->Release();
   }
 
-  DVDMessageListItem& operator=(const DVDMessageListItem&) = delete;
+  DVDMessageListItem& operator=(const DVDMessageListItem& item)
+  {
+    if (message)
+      message->Release();
+    if (item.message)
+      message = item.message->Acquire();
+    else
+      message = NULL;
+
+    priority = item.priority;
+    return *this;
+  }
 
   CDVDMsg* message;
   int priority;
diff --git a/xbmc/cores/VideoPlayer/DVDResource.h b/xbmc/cores/VideoPlayer/DVDResource.h
index 19f9614..0032855 100644
--- a/xbmc/cores/VideoPlayer/DVDResource.h
+++ b/xbmc/cores/VideoPlayer/DVDResource.h
@@ -27,10 +27,6 @@ template<typename T> struct IDVDResourceCounted
 {
   IDVDResourceCounted() : m_refs(1) {}
   virtual ~IDVDResourceCounted() {}
-
-  IDVDResourceCounted(const IDVDResourceCounted &) = delete;
-  IDVDResourceCounted &operator=(const IDVDResourceCounted &) = delete;
-
   virtual T*   Acquire()
   {
     AtomicIncrement(&m_refs);
diff --git a/xbmc/cores/VideoPlayer/DVDStreamInfo.cpp b/xbmc/cores/VideoPlayer/DVDStreamInfo.cpp
index db1a651..5aacc0f 100644
--- a/xbmc/cores/VideoPlayer/DVDStreamInfo.cpp
+++ b/xbmc/cores/VideoPlayer/DVDStreamInfo.cpp
@@ -52,6 +52,7 @@ void CDVDStreamInfo::Clear()
   extradata = NULL;
   extrasize = 0;
 
+  pixfmt   = AV_PIX_FMT_NONE;
   fpsscale = 0;
   fpsrate  = 0;
   rfpsscale= 0;
@@ -98,7 +99,8 @@ bool CDVDStreamInfo::Equal(const CDVDStreamInfo& right, bool withextradata)
   }
 
   // VIDEO
-  if( fpsscale != right.fpsscale
+  if( pixfmt   != right.pixfmt
+  ||  fpsscale != right.fpsscale
   ||  fpsrate  != right.fpsrate
   ||  rfpsscale!= right.rfpsscale
   ||  rfpsrate != right.rfpsrate
@@ -164,6 +166,7 @@ void CDVDStreamInfo::Assign(const CDVDStreamInfo& right, bool withextradata)
   }
 
   // VIDEO
+  pixfmt   = right.pixfmt;
   fpsscale = right.fpsscale;
   fpsrate  = right.fpsrate;
   rfpsscale= right.rfpsscale;
@@ -228,6 +231,7 @@ void CDVDStreamInfo::Assign(const CDemuxStream& right, bool withextradata)
   else if(  right.type == STREAM_VIDEO )
   {
     const CDemuxStreamVideo *stream = static_cast<const CDemuxStreamVideo*>(&right);
+    pixfmt    = stream->pixfmt;
     fpsscale  = stream->iFpsScale;
     fpsrate   = stream->iFpsRate;
     rfpsscale = stream->irFpsScale;
diff --git a/xbmc/cores/VideoPlayer/DVDStreamInfo.h b/xbmc/cores/VideoPlayer/DVDStreamInfo.h
index 2252d65..859d183 100644
--- a/xbmc/cores/VideoPlayer/DVDStreamInfo.h
+++ b/xbmc/cores/VideoPlayer/DVDStreamInfo.h
@@ -28,6 +28,7 @@
 
 extern "C" {
 #include "libavcodec/avcodec.h"
+#include "libavutil/pixfmt.h"
 }
 
 class CDemuxStream;
@@ -59,6 +60,7 @@ public:
 
 
   // VIDEO
+  AVPixelFormat pixfmt; // used if codec is AV_CODEC_ID_NONE
   int fpsscale; // scale of 1001 and a rate of 60000 will result in 59.94 fps
   int fpsrate;
   int rfpsscale;
diff --git a/xbmc/cores/VideoPlayer/Edl.cpp b/xbmc/cores/VideoPlayer/Edl.cpp
index 2f36967..6d07bd6 100644
--- a/xbmc/cores/VideoPlayer/Edl.cpp
+++ b/xbmc/cores/VideoPlayer/Edl.cpp
@@ -41,6 +41,11 @@ CEdl::CEdl()
   Clear();
 }
 
+CEdl::~CEdl()
+{
+  Clear();
+}
+
 void CEdl::Clear()
 {
   m_vecCuts.clear();
diff --git a/xbmc/cores/VideoPlayer/Edl.h b/xbmc/cores/VideoPlayer/Edl.h
index 95eef03..ff26078 100644
--- a/xbmc/cores/VideoPlayer/Edl.h
+++ b/xbmc/cores/VideoPlayer/Edl.h
@@ -22,11 +22,13 @@
 
 #include <string>
 #include <vector>
+#include <stdint.h>
 
 class CEdl
 {
 public:
   CEdl();
+  virtual ~CEdl(void);
 
   typedef enum
   {
diff --git a/xbmc/cores/VideoPlayer/IVideoPlayer.h b/xbmc/cores/VideoPlayer/IVideoPlayer.h
index c1708b9..a1b8d5e 100644
--- a/xbmc/cores/VideoPlayer/IVideoPlayer.h
+++ b/xbmc/cores/VideoPlayer/IVideoPlayer.h
@@ -20,7 +20,10 @@
  *
  */
 
+#include "DVDStreamInfo.h"
+#include "DVDMessageQueue.h"
 #include "DVDClock.h"
+#include "cores/VideoPlayer/Process/ProcessInfo.h"
 
 #define VideoPlayer_AUDIO    1
 #define VideoPlayer_VIDEO    2
@@ -33,9 +36,6 @@ template <typename T> class CRectGen;
 typedef CRectGen<float>  CRect;
 
 class DVDNavResult;
-class CDVDMsg;
-class CDVDStreamInfo;
-class CProcessInfo;
 
 struct SPlayerState
 {
diff --git a/xbmc/cores/VideoPlayer/VideoPlayer.cpp b/xbmc/cores/VideoPlayer/VideoPlayer.cpp
index f8b42d3..169ae0f 100644
--- a/xbmc/cores/VideoPlayer/VideoPlayer.cpp
+++ b/xbmc/cores/VideoPlayer/VideoPlayer.cpp
@@ -18,9 +18,9 @@
  *
  */
 
-#include "VideoPlayer.h"
-#include "VideoPlayerRadioRDS.h"
 #include "system.h"
+#include "VideoPlayerRadioRDS.h"
+#include "VideoPlayer.h"
 
 #include "DVDInputStreams/DVDInputStream.h"
 #include "DVDInputStreams/DVDFactoryInputStream.h"
@@ -84,21 +84,22 @@
 #include "windowing/WindowingFactory.h"
 #include "DVDCodecs/DVDCodecUtils.h"
 
-#include <iterator>
-
 using namespace PVR;
 using namespace KODI::MESSAGING;
 
 void CSelectionStreams::Clear(StreamType type, StreamSource source)
 {
   CSingleLock lock(m_section);
-  auto new_end = std::remove_if(m_Streams.begin(), m_Streams.end(),
-    [type, source](const SelectionStream &stream)
-    {
-      return (type == STREAM_NONE || stream.type == type) &&
-      (source == 0 || stream.source == source);
-    });
-  m_Streams.erase(new_end, m_Streams.end());
+  for(int i=m_Streams.size()-1;i>=0;i--)
+  {
+    if(type && m_Streams[i].type != type)
+      continue;
+
+    if(source && m_Streams[i].source != source)
+      continue;
+
+    m_Streams.erase(m_Streams.begin() + i);
+  }
 }
 
 SelectionStream& CSelectionStreams::Get(StreamType type, int index)
@@ -119,11 +120,10 @@ SelectionStream& CSelectionStreams::Get(StreamType type, int index)
 std::vector<SelectionStream> CSelectionStreams::Get(StreamType type)
 {
   std::vector<SelectionStream> streams;
-  std::copy_if(m_Streams.begin(), m_Streams.end(), std::back_inserter(streams),
-    [type](const SelectionStream &stream)
-    {
-      return stream.type == type;
-    });
+  int count = Count(type);
+  for(int index = 0; index < count; ++index){
+    streams.push_back(Get(type, index));
+  }
   return streams;
 }
 
@@ -696,8 +696,6 @@ bool CVideoPlayer::OpenFile(const CFileItem& file, const CPlayerOptions &options
 
   m_PlayerOptions = options;
   m_item = file;
-  // Try to resolve the correct mime type
-  m_item.SetMimeTypeForInternetFile();
 
   m_ready.Reset();
 
@@ -3721,10 +3719,6 @@ bool CVideoPlayer::OpenVideoStream(CDVDStreamInfo& hint, bool reset)
     m_SelectionStreams.Clear(STREAM_NONE, STREAM_SOURCE_VIDEOMUX);
   }
 
-  // TODO desired resolution needs to come from somewhere else
-  RESOLUTION_INFO res = g_graphicsContext.GetResInfo();
-  m_pDemuxer->SetVideoResolution(res.iWidth, res.iHeight);
-
   return true;
 
 }
@@ -4968,6 +4962,11 @@ float CVideoPlayer::GetRenderAspectRatio()
   return m_renderManager.GetAspectRatio();
 }
 
+RESOLUTION CVideoPlayer::GetRenderResolution()
+{
+  return g_graphicsContext.GetVideoResolution();
+}
+
 void CVideoPlayer::TriggerUpdateResolution()
 {
   m_renderManager.TriggerUpdateResolution(0, 0, 0);
diff --git a/xbmc/cores/VideoPlayer/VideoPlayer.h b/xbmc/cores/VideoPlayer/VideoPlayer.h
index fa03efd..ecacd85 100644
--- a/xbmc/cores/VideoPlayer/VideoPlayer.h
+++ b/xbmc/cores/VideoPlayer/VideoPlayer.h
@@ -322,6 +322,7 @@ public:
   virtual void FlushRenderer();
   virtual void SetRenderViewMode(int mode);
   float GetRenderAspectRatio();
+  virtual RESOLUTION GetRenderResolution();
   virtual void TriggerUpdateResolution();
   virtual bool IsRenderingVideo();
   virtual bool IsRenderingGuiLayer();
diff --git a/xbmc/cores/VideoPlayer/VideoPlayerAudio.cpp b/xbmc/cores/VideoPlayer/VideoPlayerAudio.cpp
index ebdf2d8..29ab69c 100644
--- a/xbmc/cores/VideoPlayer/VideoPlayerAudio.cpp
+++ b/xbmc/cores/VideoPlayer/VideoPlayerAudio.cpp
@@ -22,7 +22,6 @@
 #include "VideoPlayerAudio.h"
 #include "DVDCodecs/Audio/DVDAudioCodec.h"
 #include "DVDCodecs/DVDFactoryCodec.h"
-#include "DVDDemuxers/DVDDemuxPacket.h"
 #include "settings/Settings.h"
 #include "video/VideoReferenceClock.h"
 #include "utils/log.h"
diff --git a/xbmc/cores/VideoPlayer/VideoPlayerSubtitle.cpp b/xbmc/cores/VideoPlayer/VideoPlayerSubtitle.cpp
index 7eb525b..1f01c47 100644
--- a/xbmc/cores/VideoPlayer/VideoPlayerSubtitle.cpp
+++ b/xbmc/cores/VideoPlayer/VideoPlayerSubtitle.cpp
@@ -25,7 +25,6 @@
 #include "DVDClock.h"
 #include "DVDSubtitles/DVDSubtitleParser.h"
 #include "DVDCodecs/DVDFactoryCodec.h"
-#include "DVDDemuxers/DVDDemuxPacket.h"
 #include "utils/log.h"
 #include "threads/SingleLock.h"
 #if defined(HAVE_CONFIG_H)
diff --git a/xbmc/cores/VideoPlayer/VideoPlayerTeletext.cpp b/xbmc/cores/VideoPlayer/VideoPlayerTeletext.cpp
index 0299a87..f51e643 100644
--- a/xbmc/cores/VideoPlayer/VideoPlayerTeletext.cpp
+++ b/xbmc/cores/VideoPlayer/VideoPlayerTeletext.cpp
@@ -21,7 +21,6 @@
 #include "VideoPlayerTeletext.h"
 #include "DVDClock.h"
 #include "DVDStreamInfo.h"
-#include "DVDDemuxers/DVDDemuxPacket.h"
 #include "utils/log.h"
 #include "threads/SingleLock.h"
 
diff --git a/xbmc/cores/VideoPlayer/VideoPlayerVideo.cpp b/xbmc/cores/VideoPlayer/VideoPlayerVideo.cpp
index 6d04b3a..bd3fe73 100644
--- a/xbmc/cores/VideoPlayer/VideoPlayerVideo.cpp
+++ b/xbmc/cores/VideoPlayer/VideoPlayerVideo.cpp
@@ -32,7 +32,6 @@
 #include "DVDCodecs/Video/DVDVideoPPFFmpeg.h"
 #include "DVDCodecs/Video/DVDVideoCodecFFmpeg.h"
 #include "DVDDemuxers/DVDDemux.h"
-#include "DVDDemuxers/DVDDemuxPacket.h"
 #include "guilib/GraphicContext.h"
 #include <sstream>
 #include <iomanip>
@@ -464,7 +463,7 @@ void CVideoPlayerVideo::Process()
       // buffer packets so we can recover should decoder flush for some reason
       if(m_pVideoCodec->GetConvergeCount() > 0)
       {
-        m_packets.emplace_back(pMsg, 0);
+        m_packets.push_back(DVDMessageListItem(pMsg, 0));
         if(m_packets.size() > m_pVideoCodec->GetConvergeCount()
         || m_packets.size() * frametime > DVD_SEC_TO_TIME(10))
           m_packets.pop_front();
diff --git a/xbmc/cores/VideoPlayer/VideoPlayerVideo.h b/xbmc/cores/VideoPlayer/VideoPlayerVideo.h
index 34a4c7d..5149066 100644
--- a/xbmc/cores/VideoPlayer/VideoPlayerVideo.h
+++ b/xbmc/cores/VideoPlayer/VideoPlayerVideo.h
@@ -23,7 +23,6 @@
 #include "threads/Thread.h"
 #include "IVideoPlayer.h"
 #include "DVDMessageQueue.h"
-#include "DVDStreamInfo.h"
 #include "DVDCodecs/Video/DVDVideoCodec.h"
 #include "DVDClock.h"
 #include "DVDOverlayContainer.h"
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/BaseRenderer.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/BaseRenderer.cpp
index ed0e15d..2b23ab8 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/BaseRenderer.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/BaseRenderer.cpp
@@ -210,11 +210,10 @@ void CBaseRenderer::restoreRotatedCoords()
     m_rotatedDestCoords[i] = m_savedRotatedDestCoords[i];
 }
 
-void CBaseRenderer::CalcNormalRenderRect(float offsetX, float offsetY, float width, float height,
-                                         float inputFrameRatio, float zoomAmount, float verticalShift)
+void CBaseRenderer::CalcNormalDisplayRect(float offsetX, float offsetY, float screenWidth, float screenHeight, float inputFrameRatio, float zoomAmount, float verticalShift)
 {
   // if view window is empty, set empty destination
-  if(height == 0 || width == 0)
+  if(screenHeight == 0 || screenWidth == 0)
   {
     m_destRect.SetRect(0.0f, 0.0f, 0.0f, 0.0f);
     return;
@@ -227,8 +226,8 @@ void CBaseRenderer::CalcNormalRenderRect(float offsetX, float offsetY, float wid
 
   float outputFrameRatio = inputFrameRatio / g_graphicsContext.GetResInfo().fPixelRatio;
 
-  // allow a certain error to maximize size of render area
-  float fCorrection = width / height / outputFrameRatio - 1.0f;
+  // allow a certain error to maximize screen size
+  float fCorrection = screenWidth / screenHeight / outputFrameRatio - 1.0f;
   float fAllowed    = CSettings::GetInstance().GetInt(CSettings::SETTING_VIDEOPLAYER_ERRORINASPECT) * 0.01f;
   if(fCorrection >   fAllowed) fCorrection =   fAllowed;
   if(fCorrection < - fAllowed) fCorrection = - fAllowed;
@@ -236,12 +235,12 @@ void CBaseRenderer::CalcNormalRenderRect(float offsetX, float offsetY, float wid
   outputFrameRatio *= 1.0f + fCorrection;
 
   // maximize the movie width
-  float newWidth = width;
+  float newWidth = screenWidth;
   float newHeight = newWidth / outputFrameRatio;
 
-  if (newHeight > height)
+  if (newHeight > screenHeight)
   {
-    newHeight = height;
+    newHeight = screenHeight;
     newWidth = newHeight * outputFrameRatio;
   }
 
@@ -250,24 +249,24 @@ void CBaseRenderer::CalcNormalRenderRect(float offsetX, float offsetY, float wid
   newHeight *= zoomAmount;
 
   // if we are less than one pixel off use the complete screen instead
-  if (std::abs(newWidth - width) < 1.0f)
-    newWidth = width;
-  if (std::abs(newHeight - height) < 1.0f)
-    newHeight = height;
+  if (std::abs(newWidth - screenWidth) < 1.0f)
+    newWidth = screenWidth;
+  if (std::abs(newHeight - screenHeight) < 1.0f)
+    newHeight = screenHeight;
 
   // Centre the movie
-  float posY = (height - newHeight) / 2;
-  float posX = (width - newWidth) / 2;
+  float posY = (screenHeight - newHeight) / 2;
+  float posX = (screenWidth - newWidth) / 2;
 
   // vertical shift range -1 to 1 shifts within the top and bottom black bars
   // if there are no top and bottom black bars, this range does nothing
-  float blackBarSize = std::max((height - newHeight) / 2.0f, 0.0f);
+  float blackBarSize = std::max((screenHeight - newHeight) / 2.0f, 0.0f);
   posY += blackBarSize * std::max(std::min(verticalShift, 1.0f), -1.0f);
 
   // vertical shift ranges -2 to -1 and 1 to 2 will shift the image out of the screen
   // if vertical shift is -2 it will be completely shifted out the top,
   // if it's 2 it will be completely shifted out the bottom
-  float shiftRange = std::min(newHeight, newHeight - (newHeight - height) / 2.0f);
+  float shiftRange = std::min(newHeight, newHeight - (newHeight - screenHeight) / 2.0f);
   if (verticalShift > 1.0f)
     posY += shiftRange * (verticalShift - 1.0f);
   else if (verticalShift < -1.0f)
@@ -282,7 +281,7 @@ void CBaseRenderer::CalcNormalRenderRect(float offsetX, float offsetY, float wid
   if (!(g_graphicsContext.IsFullScreenVideo() || g_graphicsContext.IsCalibrating()))
   {
     CRect original(m_destRect);
-    m_destRect.Intersect(CRect(offsetX, offsetY, offsetX + width, offsetY + height));
+    m_destRect.Intersect(CRect(offsetX, offsetY, offsetX + screenWidth, offsetY + screenHeight));
     if (m_destRect != original)
     {
       float scaleX = m_sourceRect.Width() / original.Width();
@@ -371,7 +370,7 @@ void CBaseRenderer::CalculateFrameAspectRatio(unsigned int desired_width, unsign
   }
 }
 
-void CBaseRenderer::ManageRenderArea()
+void CBaseRenderer::ManageDisplay()
 {
   m_viewRect = g_graphicsContext.GetViewWindow();
 
@@ -423,7 +422,7 @@ void CBaseRenderer::ManageRenderArea()
     }
   }
 
-  CalcNormalRenderRect(m_viewRect.x1, m_viewRect.y1, m_viewRect.Width(), m_viewRect.Height(), GetAspectRatio() * CDisplaySettings::GetInstance().GetPixelRatio(), CDisplaySettings::GetInstance().GetZoomAmount(), CDisplaySettings::GetInstance().GetVerticalShift());
+  CalcNormalDisplayRect(m_viewRect.x1, m_viewRect.y1, m_viewRect.Width(), m_viewRect.Height(), GetAspectRatio() * CDisplaySettings::GetInstance().GetPixelRatio(), CDisplaySettings::GetInstance().GetZoomAmount(), CDisplaySettings::GetInstance().GetVerticalShift());
 }
 
 void CBaseRenderer::SetViewMode(int viewMode)
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/BaseRenderer.h b/xbmc/cores/VideoPlayer/VideoRenderers/BaseRenderer.h
index 649a7e7..e3901dc 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/BaseRenderer.h
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/BaseRenderer.h
@@ -108,22 +108,21 @@ public:
   virtual bool Supports(ESCALINGMETHOD method) = 0;
 
   void SetViewMode(int viewMode);
-
-  /*! \brief Get video rectangle and view window
-  \param source is original size of the video
-  \param dest is the target rendering area honoring aspect ratio of source
-  \param view is the entire target rendering area for the video (including black bars)
-  */
+
+  /*! \brief Get video rectangle and view window
+  \param source is original size of the video
+  \param dest is the target rendering area honoring aspect ratio of source
+  \param view is the entire target rendering area for the video (including black bars)
+  */
   void GetVideoRect(CRect &source, CRect &dest, CRect &view);
   float GetAspectRatio() const;
 
   static void SettingOptionsRenderMethodsFiller(const CSetting *setting, std::vector< std::pair<std::string, int> > &list, int &current, void *data);
 
 protected:
-  void CalcNormalRenderRect(float offsetX, float offsetY, float width, float height,
-                            float inputFrameRatio, float zoomAmount, float verticalShift);
+  void CalcNormalDisplayRect(float offsetX, float offsetY, float screenWidth, float screenHeight, float inputFrameRatio, float zoomAmount, float verticalShift);
   void CalculateFrameAspectRatio(unsigned int desired_width, unsigned int desired_height);
-  void ManageRenderArea();
+  void ManageDisplay();
   virtual void ReorderDrawPoints();//might be overwritten (by egl e.x.)
   void saveRotatedCoords();//saves the current state of m_rotatedDestCoords
   void syncDestRectToRotatedPoints();//sync any changes of m_destRect to m_rotatedDestCoords
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/CMakeLists.txt b/xbmc/cores/VideoPlayer/VideoRenderers/CMakeLists.txt
index ce1dc18..e6d97e5 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/CMakeLists.txt
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/CMakeLists.txt
@@ -51,7 +51,3 @@ core_add_library(videorenderers)
 if(ENABLE_INTERNAL_FFMPEG)
   add_dependencies(videorenderers ffmpeg)
 endif()
-
-if(CORE_SYSTEM_NAME STREQUAL windows)
-  add_dependencies(videorenderers d3dx11effects)
-endif()
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.cpp
index 186f886..8506f9d 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/MMALRenderer.cpp
@@ -227,7 +227,7 @@ bool CMMALRenderer::Configure(unsigned int width, unsigned int height, unsigned
   // calculate the input frame aspect ratio
   CalculateFrameAspectRatio(d_width, d_height);
   SetViewMode(CMediaSettings::GetInstance().GetCurrentVideoSettings().m_ViewMode);
-  ManageRenderArea();
+  ManageDisplay();
 
   m_bMMALConfigured = init_vout(format, m_opaque);
   m_bConfigured = m_bMMALConfigured;
@@ -285,7 +285,7 @@ void CMMALRenderer::Update()
   if (g_advancedSettings.CanLogComponent(LOGVIDEO))
     CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
   if (!m_bConfigured) return;
-  ManageRenderArea();
+  ManageDisplay();
 }
 
 void CMMALRenderer::RenderUpdate(bool clear, DWORD flags, DWORD alpha)
@@ -300,7 +300,7 @@ void CMMALRenderer::RenderUpdate(bool clear, DWORD flags, DWORD alpha)
     return;
   }
 
-  ManageRenderArea();
+  ManageDisplay();
 
   if (m_format != RENDER_FMT_MMAL)
   {
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererAML.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererAML.cpp
index f6b7bb1..c18b3d3 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererAML.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererAML.cpp
@@ -129,7 +129,7 @@ bool CRendererAML::RenderHook(int index)
 
 bool CRendererAML::RenderUpdateVideoHook(bool clear, DWORD flags, DWORD alpha)
 {
-  ManageRenderArea();
+  ManageDisplay();
 
   CDVDAmlogicInfo *amli = static_cast<CDVDAmlogicInfo *>(m_buffers[m_iYV12RenderBuffer].hwDec);
   if (amli)
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererIMX.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererIMX.cpp
index ed5b643..547b8f6 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererIMX.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererIMX.cpp
@@ -152,7 +152,7 @@ bool CRendererIMX::RenderUpdateVideoHook(bool clear, DWORD flags, DWORD alpha)
     if (stereo_mode)
       g_graphicsContext.SetStereoView(RENDER_STEREO_VIEW_LEFT);
 
-    ManageRenderArea();
+    ManageDisplay();
 
     if (stereo_mode)
       g_graphicsContext.SetStereoView(RENDER_STEREO_VIEW_OFF);
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererMediaCodecSurface.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererMediaCodecSurface.cpp
index d5f7542..1796561 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererMediaCodecSurface.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererMediaCodecSurface.cpp
@@ -130,7 +130,7 @@ bool CRendererMediaCodecSurface::RenderUpdateVideoHook(bool clear, DWORD flags,
     if (stereo_mode)
       g_graphicsContext.SetStereoView(RENDER_STEREO_VIEW_LEFT);
 
-    ManageRenderArea();
+    ManageDisplay();
 
     if (stereo_mode)
       g_graphicsContext.SetStereoView(RENDER_STEREO_VIEW_OFF);
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGL.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGL.cpp
index 2ba568b..a437302 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGL.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGL.cpp
@@ -263,7 +263,7 @@ bool CLinuxRendererGL::Configure(unsigned int width, unsigned int height, unsign
   // Calculate the input frame aspect ratio.
   CalculateFrameAspectRatio(d_width, d_height);
   SetViewMode(CMediaSettings::GetInstance().GetCurrentVideoSettings().m_ViewMode);
-  ManageRenderArea();
+  ManageDisplay();
 
   m_bConfigured = true;
   m_bImageReady = false;
@@ -533,7 +533,7 @@ void CLinuxRendererGL::Update()
 {
   if (!m_bConfigured)
     return;
-  ManageRenderArea();
+  ManageDisplay();
   m_scalingMethodGui = (ESCALINGMETHOD)-1;
 
   ValidateRenderTarget();
@@ -551,7 +551,7 @@ void CLinuxRendererGL::RenderUpdate(bool clear, DWORD flags, DWORD alpha)
     return;
   }
 
-  ManageRenderArea();
+  ManageDisplay();
 
   if (clear)
   {
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGLES.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGLES.cpp
index 1f0f691..07ec955 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGLES.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/LinuxRendererGLES.cpp
@@ -172,7 +172,7 @@ bool CLinuxRendererGLES::Configure(unsigned int width, unsigned int height, unsi
   // Calculate the input frame aspect ratio.
   CalculateFrameAspectRatio(d_width, d_height);
   SetViewMode(CMediaSettings::GetInstance().GetCurrentVideoSettings().m_ViewMode);
-  ManageRenderArea();
+  ManageDisplay();
 
   m_bConfigured = true;
   m_bImageReady = false;
@@ -415,7 +415,7 @@ void CLinuxRendererGLES::Update()
 {
   if (!m_bConfigured)
     return;
-  ManageRenderArea();
+  ManageDisplay();
   ValidateRenderTarget();
 }
 
@@ -447,7 +447,7 @@ void CLinuxRendererGLES::RenderUpdate(bool clear, DWORD flags, DWORD alpha)
   if (buf.image.flags==0)
     return;
 
-  ManageRenderArea();
+  ManageDisplay();
 
   m_iLastRenderBuffer = index;
 
@@ -498,7 +498,7 @@ void CLinuxRendererGLES::RenderUpdateVideo(bool clear, DWORD flags, DWORD alpha)
 
   if (m_renderMethod & RENDER_BYPASS)
   {
-    ManageRenderArea();
+    ManageDisplay();
     return;
   }
 }
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/RenderManager.cpp
index 6b4e62e..111fa24 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/RenderManager.cpp
@@ -69,10 +69,6 @@
 #include "HwDecRender/RendererMediaCodecSurface.h"
 #endif
 
-#if defined(TARGET_POSIX)
-#include "linux/XTimeUtils.h"
-#endif
-
 #include "RenderCapture.h"
 
 /* to use the same as player */
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/WinRenderer.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/WinRenderer.cpp
index 38977cf..527453f 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/WinRenderer.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/WinRenderer.cpp
@@ -227,7 +227,7 @@ bool CWinRenderer::Configure(unsigned int width, unsigned int height, unsigned i
   // calculate the input frame aspect ratio
   CalculateFrameAspectRatio(d_width, d_height);
   SetViewMode(CMediaSettings::GetInstance().GetCurrentVideoSettings().m_ViewMode);
-  ManageRenderArea();
+  ManageDisplay();
 
   SelectRenderMethod();
   m_bConfigured = true;
@@ -327,7 +327,7 @@ void CWinRenderer::Update()
 {
   if (!m_bConfigured) 
     return;
-  ManageRenderArea();
+  ManageDisplay();
   ManageTextures();
 }
 
@@ -341,7 +341,7 @@ void CWinRenderer::RenderUpdate(bool clear, unsigned int flags, unsigned int alp
 
   g_Windowing.SetAlphaBlendEnable(alpha < 255);
   ManageTextures();
-  ManageRenderArea();
+  ManageDisplay();
   Render(flags);
 }
 
diff --git a/xbmc/cores/omxplayer/OMXAudio.cpp b/xbmc/cores/omxplayer/OMXAudio.cpp
index 4654e22..3020771 100644
--- a/xbmc/cores/omxplayer/OMXAudio.cpp
+++ b/xbmc/cores/omxplayer/OMXAudio.cpp
@@ -55,12 +55,6 @@ extern "C" {
 #define AUDIO_DECODE_OUTPUT_BUFFER (32*1024)
 static const char rounded_up_channels_shift[] = {0,0,1,2,2,3,3,3,3};
 
-static const GUID KSDATAFORMAT_SUBTYPE_PCM = {
-  WAVE_FORMAT_PCM,
-  0x0000, 0x0010,
-  {0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
-};
-
 //////////////////////////////////////////////////////////////////////
 // Construction/Destruction
 //////////////////////////////////////////////////////////////////////
@@ -586,7 +580,7 @@ bool COMXAudio::Initialize(AEAudioFormat format, OMXClock *clock, CDVDStreamInfo
   memset(&m_wave_header, 0x0, sizeof(m_wave_header));
 
   m_wave_header.Format.nChannels  = 2;
-  m_wave_header.dwChannelMask = 3; // SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT;
+  m_wave_header.dwChannelMask     = SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT;
 
   if (!m_Passthrough)
   {
diff --git a/xbmc/cores/omxplayer/OMXAudio.h b/xbmc/cores/omxplayer/OMXAudio.h
index db7f98d..e17acf4 100644
--- a/xbmc/cores/omxplayer/OMXAudio.h
+++ b/xbmc/cores/omxplayer/OMXAudio.h
@@ -40,26 +40,6 @@ extern "C" {
 #define AUDIO_BUFFER_SECONDS 3
 #define VIS_PACKET_SIZE 512
 
-typedef struct tGUID
-{
-  DWORD Data1;
-  WORD  Data2, Data3;
-  BYTE  Data4[8];
-} __attribute__((__packed__)) GUID;
-
-typedef struct tWAVEFORMATEXTENSIBLE
-{
-  WAVEFORMATEX Format;
-  union
-  {
-    WORD wValidBitsPerSample;
-    WORD wSamplesPerBlock;
-    WORD wReserved;
-  } Samples;
-  DWORD dwChannelMask;
-  GUID SubFormat;
-} __attribute__((__packed__)) WAVEFORMATEXTENSIBLE;
-
 class COMXAudio
 {
 public:
diff --git a/xbmc/cores/omxplayer/OMXAudioCodecOMX.cpp b/xbmc/cores/omxplayer/OMXAudioCodecOMX.cpp
index 6bdfc58..1baeaf5 100644
--- a/xbmc/cores/omxplayer/OMXAudioCodecOMX.cpp
+++ b/xbmc/cores/omxplayer/OMXAudioCodecOMX.cpp
@@ -68,7 +68,7 @@ bool COMXAudioCodecOMX::Open(CDVDStreamInfo &hints)
   m_bOpenedCodec = false;
 
   if (hints.codec == AV_CODEC_ID_DTS && g_RBP.RasberryPiVersion() > 1)
-    pCodec = avcodec_find_decoder_by_name("dcadec");
+    pCodec = avcodec_find_decoder_by_name("libdcadec");
 
   if (!pCodec)
     pCodec = avcodec_find_decoder(hints.codec);
diff --git a/xbmc/cores/paplayer/ICodec.h b/xbmc/cores/paplayer/ICodec.h
index 1915da4..2cecf99 100644
--- a/xbmc/cores/paplayer/ICodec.h
+++ b/xbmc/cores/paplayer/ICodec.h
@@ -66,7 +66,7 @@ public:
   // Should seek to the appropriate time (in ms) in the file, and return the
   // time to which we managed to seek (in the case where seeking is problematic)
   // This is used in FFwd/Rewd so can be called very often.
-  virtual bool Seek(int64_t iSeekTime)=0;
+  virtual int64_t Seek(int64_t iSeekTime)=0;
 
   // ReadPCM()
   // Decodes audio into pBuffer up to size bytes.  The actual amount of returned data
diff --git a/xbmc/cores/paplayer/VideoPlayerCodec.cpp b/xbmc/cores/paplayer/VideoPlayerCodec.cpp
index 821f129..9e17607 100644
--- a/xbmc/cores/paplayer/VideoPlayerCodec.cpp
+++ b/xbmc/cores/paplayer/VideoPlayerCodec.cpp
@@ -92,7 +92,6 @@ bool VideoPlayerCodec::Init(const std::string &strFile, unsigned int filecache)
 
   CFileItem fileitem(urlFile, false);
   fileitem.SetMimeType(m_strContentType);
-  fileitem.SetMimeTypeForInternetFile();
   m_pInputStream = CDVDFactoryInputStream::CreateInputStream(NULL, fileitem);
   if (!m_pInputStream)
   {
@@ -214,7 +213,7 @@ bool VideoPlayerCodec::Init(const std::string &strFile, unsigned int filecache)
   m_bCanSeek = false;
   if (m_pInputStream->Seek(0, SEEK_POSSIBLE))
   {
-    if (Seek(1))
+    if (Seek(1) != DVD_NOPTS_VALUE)
     {
       // rewind stream to beginning
       Seek(0);
@@ -320,7 +319,7 @@ void VideoPlayerCodec::DeInit()
   m_bInited = false;
 }
 
-bool VideoPlayerCodec::Seek(int64_t iSeekTime)
+int64_t VideoPlayerCodec::Seek(int64_t iSeekTime)
 {
   // default to announce backwards seek if !m_pPacket to not make FFmpeg
   // skip mpeg audio frames at playback start
@@ -338,7 +337,10 @@ bool VideoPlayerCodec::Seek(int64_t iSeekTime)
 
   m_nDecodedLen = 0;
 
-  return ret;
+  if (!ret)
+    return DVD_NOPTS_VALUE;
+
+  return iSeekTime;
 }
 
 int VideoPlayerCodec::ReadPCM(BYTE *pBuffer, int size, int *actualsize)
diff --git a/xbmc/cores/paplayer/VideoPlayerCodec.h b/xbmc/cores/paplayer/VideoPlayerCodec.h
index bc00d5e..1c20177 100644
--- a/xbmc/cores/paplayer/VideoPlayerCodec.h
+++ b/xbmc/cores/paplayer/VideoPlayerCodec.h
@@ -40,7 +40,7 @@ public:
 
   virtual bool Init(const std::string &strFile, unsigned int filecache);
   virtual void DeInit();
-  virtual bool Seek(int64_t iSeekTime);
+  virtual int64_t Seek(int64_t iSeekTime);
   virtual int ReadPCM(BYTE *pBuffer, int size, int *actualsize);
   virtual int ReadRaw(uint8_t **pBuffer, int *bufferSize);
   virtual bool CanInit();
diff --git a/xbmc/dbwrappers/Database.cpp b/xbmc/dbwrappers/Database.cpp
index 4dc71c5..3982ae3 100644
--- a/xbmc/dbwrappers/Database.cpp
+++ b/xbmc/dbwrappers/Database.cpp
@@ -34,10 +34,6 @@
 #include "mysqldataset.h"
 #endif
 
-#ifdef TARGET_POSIX
-#include "linux/ConvUtils.h"
-#endif
-
 using namespace dbiplus;
 
 #define MAX_COMPRESS_COUNT 20
diff --git a/xbmc/dbwrappers/mysqldataset.cpp b/xbmc/dbwrappers/mysqldataset.cpp
index 527bd1d..1380ede 100644
--- a/xbmc/dbwrappers/mysqldataset.cpp
+++ b/xbmc/dbwrappers/mysqldataset.cpp
@@ -36,10 +36,6 @@
 #pragma comment(lib, "libmysql.lib")
 #endif
 
-#ifdef TARGET_POSIX
-#include "linux/ConvUtils.h"
-#endif
-
 #define MYSQL_OK          0
 #define ER_BAD_DB_ERROR   1049
 
diff --git a/xbmc/dbwrappers/sqlitedataset.cpp b/xbmc/dbwrappers/sqlitedataset.cpp
index 7091e97..ca11c7c 100644
--- a/xbmc/dbwrappers/sqlitedataset.cpp
+++ b/xbmc/dbwrappers/sqlitedataset.cpp
@@ -38,10 +38,6 @@
 #pragma comment(lib, "sqlite3.lib")
 #endif
 
-#ifdef TARGET_POSIX
-#include "linux/XTimeUtils.h"
-#endif
-
 namespace dbiplus {
 //************* Callback function ***************************
 
diff --git a/xbmc/dialogs/GUIDialogContextMenu.h b/xbmc/dialogs/GUIDialogContextMenu.h
index eff23a9..5084d2b 100644
--- a/xbmc/dialogs/GUIDialogContextMenu.h
+++ b/xbmc/dialogs/GUIDialogContextMenu.h
@@ -35,6 +35,7 @@ enum CONTEXT_BUTTON { CONTEXT_BUTTON_CANCELLED = 0,
                       CONTEXT_BUTTON_MOVE,
                       CONTEXT_BUTTON_ADD_FAVOURITE,
                       CONTEXT_BUTTON_SETTINGS,
+                      CONTEXT_BUTTON_GOTO_ROOT,
                       CONTEXT_BUTTON_RIP_CD,
                       CONTEXT_BUTTON_CANCEL_RIP_CD,
                       CONTEXT_BUTTON_RIP_TRACK,
diff --git a/xbmc/dialogs/GUIDialogMediaFilter.cpp b/xbmc/dialogs/GUIDialogMediaFilter.cpp
index be8ed24..580cf66 100644
--- a/xbmc/dialogs/GUIDialogMediaFilter.cpp
+++ b/xbmc/dialogs/GUIDialogMediaFilter.cpp
@@ -420,7 +420,7 @@ void CGUIDialogMediaFilter::InitializeSettings()
       if (filter.settingType == SettingTypeString)
         filter.setting = AddEdit(group, settingId, filter.label, 0, data.asString(), true, false, filter.label, true);
       else if (filter.settingType == SettingTypeInteger)
-        filter.setting = AddEdit(group, settingId, filter.label, 0, static_cast<int>(data.asInteger()), 0, 1, 0, false,  static_cast<int>(filter.label), true);
+        filter.setting = AddEdit(group, settingId, filter.label, 0, static_cast<int>(data.asInteger()), 0, 1, 0, false, filter.label, true);
       else if (filter.settingType == SettingTypeNumber)
         filter.setting = AddEdit(group, settingId, filter.label, 0, data.asFloat(), 0.0f, 1.0f, 0.0f, false, filter.label, true);
     }
diff --git a/xbmc/filesystem/AddonsDirectory.cpp b/xbmc/filesystem/AddonsDirectory.cpp
index 808be15..3240837 100644
--- a/xbmc/filesystem/AddonsDirectory.cpp
+++ b/xbmc/filesystem/AddonsDirectory.cpp
@@ -24,16 +24,15 @@
 #include <set>
 #include "AddonsDirectory.h"
 #include "addons/AddonDatabase.h"
-#include "addons/AddonSystemSettings.h"
 #include "interfaces/generic/ScriptInvocationManager.h"
 #include "FileItem.h"
 #include "addons/AddonInstaller.h"
 #include "addons/PluginSource.h"
 #include "addons/RepositoryUpdater.h"
 #include "dialogs/GUIDialogOK.h"
+#include "games/addons/GameClient.h"
 #include "guilib/TextureManager.h"
 #include "File.h"
-#include "settings/Settings.h"
 #include "SpecialProtocol.h"
 #include "utils/URIUtils.h"
 #include "utils/StringUtils.h"
@@ -51,6 +50,9 @@ CAddonsDirectory::~CAddonsDirectory(void) {}
 const auto CATEGORY_INFO_PROVIDERS = "category.infoproviders";
 const auto CATEGORY_LOOK_AND_FEEL = "category.lookandfeel";
 const auto CATEGORY_GAME_ADDONS = "category.gameaddons";
+const auto CATEGORY_EMULATORS = "category.emulators";
+const auto CATEGORY_STANDALONE_GAMES = "category.standalonegames";
+const auto CATEGORY_GAME_PROVIDERS = "category.gameproviders";
 
 const std::set<TYPE> dependencyTypes = {
     ADDON_SCRAPER_LIBRARY,
@@ -77,8 +79,11 @@ const std::set<TYPE> lookAndFeelTypes = {
 
 const std::set<TYPE> gameTypes = {
   ADDON_GAME_CONTROLLER,
+  ADDON_GAMEDLL,
+  ADDON_GAME,
 };
 
+
 static bool IsInfoProviderType(TYPE type)
 {
   return infoProviderTypes.find(type) != infoProviderTypes.end();
@@ -106,7 +111,23 @@ static bool IsGameType(TYPE type)
 
 static bool IsGameAddon(const AddonPtr& addon)
 {
-  return IsGameType(addon->Type());
+  return addon->IsType(ADDON_GAME);
+}
+
+static bool IsStandaloneGame(const AddonPtr& addon)
+{
+  return (addon->Type() == ADDON_GAMEDLL && std::static_pointer_cast<GAME::CGameClient>(addon)->IsStandalone()) ||
+         (addon->Type() == ADDON_SCRIPT  && addon->IsType(ADDON_GAME));
+}
+
+static bool IsEmulator(const AddonPtr& addon)
+{
+  return addon->Type() == ADDON_GAMEDLL && !std::static_pointer_cast<GAME::CGameClient>(addon)->IsStandalone();
+}
+
+static bool IsGameProvider(const AddonPtr& addon)
+{
+  return addon->Type() == ADDON_PLUGIN && addon->IsType(ADDON_GAME);
 }
 
 static bool IsDependecyType(TYPE type)
@@ -161,6 +182,79 @@ static void GenerateTypeListing(const CURL& path, const std::set<TYPE>& types,
   }
 }
 
+// Creates categories for game add-ons, if we have any game add-ons
+static void GenerateGameListing(const CURL& path, const VECADDONS& addons, CFileItemList& items)
+{
+  // Game controllers
+  for (const auto& addon : addons)
+  {
+    if (addon->Type() == ADDON_GAME_CONTROLLER)
+    {
+      CFileItemPtr item(new CFileItem(TranslateType(ADDON_GAME_CONTROLLER, true)));
+      CURL itemPath = path;
+      itemPath.SetFileName(TranslateType(ADDON_GAME_CONTROLLER, false));
+      item->SetPath(itemPath.Get());
+      item->m_bIsFolder = true;
+      std::string thumb = GetIcon(ADDON_GAME_CONTROLLER);
+      if (!thumb.empty() && g_TextureManager.HasTexture(thumb))
+        item->SetArt("thumb", thumb);
+      items.Add(item);
+      break;
+    }
+  }
+  // Emulators
+  for (const auto& addon : addons)
+  {
+    if (IsEmulator(addon))
+    {
+      CFileItemPtr item(new CFileItem(g_localizeStrings.Get(35207))); // Emulators
+      CURL itemPath = path;
+      itemPath.SetFileName(CATEGORY_EMULATORS);
+      item->SetPath(itemPath.Get());
+      item->m_bIsFolder = true;
+      std::string thumb = GetIcon(ADDON_GAMEDLL);
+      if (!thumb.empty() && g_TextureManager.HasTexture(thumb))
+        item->SetArt("thumb", thumb);
+      items.Add(item);
+      break;
+    }
+  }
+  // Standalone games
+  for (const auto& addon : addons)
+  {
+    if (IsStandaloneGame(addon))
+    {
+      CFileItemPtr item(new CFileItem(g_localizeStrings.Get(35208))); // Standalone games
+      CURL itemPath = path;
+      itemPath.SetFileName(CATEGORY_STANDALONE_GAMES);
+      item->SetPath(itemPath.Get());
+      item->m_bIsFolder = true;
+      std::string thumb = GetIcon(ADDON_GAMEDLL);
+      if (!thumb.empty() && g_TextureManager.HasTexture(thumb))
+        item->SetArt("thumb", thumb);
+      items.Add(item);
+      break;
+    }
+  }
+  // Game providers
+  for (const auto& addon : addons)
+  {
+    if (IsGameProvider(addon))
+    {
+      CFileItemPtr item(new CFileItem(g_localizeStrings.Get(35209))); // Game providers
+      CURL itemPath = path;
+      itemPath.SetFileName(CATEGORY_GAME_PROVIDERS);
+      item->SetPath(itemPath.Get());
+      item->m_bIsFolder = true;
+      std::string thumb = GetIcon(ADDON_GAMEDLL);
+      if (!thumb.empty() && g_TextureManager.HasTexture(thumb))
+        item->SetArt("thumb", thumb);
+      items.Add(item);
+      break;
+    }
+  }
+}
+
 //Creates the top-level category list
 static void GenerateMainCategoryListing(const CURL& path, const VECADDONS& addons,
     CFileItemList& items)
@@ -187,7 +281,7 @@ static void GenerateMainCategoryListing(const CURL& path, const VECADDONS& addon
   }
   if (std::any_of(addons.begin(), addons.end(), IsGameAddon))
   {
-    CFileItemPtr item(new CFileItem(g_localizeStrings.Get(35049))); // Game add-ons
+    CFileItemPtr item(new CFileItem(TranslateType(ADDON_GAME, true)));
     item->SetPath(URIUtils::AddFileToFolder(path.Get(), CATEGORY_GAME_ADDONS));
     item->m_bIsFolder = true;
     const std::string thumb = "DefaultGameAddons.png";
@@ -200,7 +294,7 @@ static void GenerateMainCategoryListing(const CURL& path, const VECADDONS& addon
   for (unsigned int i = ADDON_UNKNOWN + 1; i < ADDON_MAX - 1; ++i)
   {
     const TYPE type = (TYPE)i;
-    if (!IsInfoProviderType(type) && !IsLookAndFeelType(type) && !IsDependecyType(type))
+    if (!IsInfoProviderType(type) && !IsLookAndFeelType(type) && !IsDependecyType(type) && !IsGameType(type))
       uncategorized.insert(static_cast<TYPE>(i));
   }
   GenerateTypeListing(path, uncategorized, addons, items);
@@ -225,9 +319,30 @@ static void GenerateCategoryListing(const CURL& path, VECADDONS& addons,
   }
   else if (category == CATEGORY_GAME_ADDONS)
   {
-    items.SetProperty("addoncategory", g_localizeStrings.Get(35049)); // Game add-ons
-    items.SetLabel(g_localizeStrings.Get(35049)); // Game add-ons
-    GenerateTypeListing(path, gameTypes, addons, items);
+    items.SetProperty("addoncategory", TranslateType(ADDON_GAME, true));
+    items.SetLabel(TranslateType(ADDON_GAME, true));
+    GenerateGameListing(path, addons, items);
+  }
+  else if (category == CATEGORY_EMULATORS)
+  {
+    items.SetProperty("addoncategory", g_localizeStrings.Get(35207)); // Emulators
+    addons.erase(std::remove_if(addons.begin(), addons.end(),
+        [](const AddonPtr& addon){ return !IsEmulator(addon); }), addons.end());
+    CAddonsDirectory::GenerateAddonListing(path, addons, items, g_localizeStrings.Get(35207)); // Emulators
+  }
+  else if (category == CATEGORY_STANDALONE_GAMES)
+  {
+    items.SetProperty("addoncategory", g_localizeStrings.Get(35208)); // Standalone games
+    addons.erase(std::remove_if(addons.begin(), addons.end(),
+        [](const AddonPtr& addon){ return !IsStandaloneGame(addon); }), addons.end());
+    CAddonsDirectory::GenerateAddonListing(path, addons, items, g_localizeStrings.Get(35208)); // Standalone games
+  }
+  else if (category == CATEGORY_GAME_PROVIDERS)
+  {
+    items.SetProperty("addoncategory", g_localizeStrings.Get(35209)); // Game providers
+    addons.erase(std::remove_if(addons.begin(), addons.end(),
+        [](const AddonPtr& addon){ return !IsGameProvider(addon); }), addons.end());
+    CAddonsDirectory::GenerateAddonListing(path, addons, items, g_localizeStrings.Get(35209)); // Game providers
   }
   else
   { // fallback to addon type
@@ -389,22 +504,6 @@ static bool Browse(const CURL& path, CFileItemList &items)
   return true;
 }
 
-static bool GetRecentlyUpdatedAddons(VECADDONS& addons)
-{
-  if (!CAddonMgr::GetInstance().GetInstalledAddons(addons))
-    return false;
-
-  auto limit = CDateTime::GetCurrentDateTime() - CDateTimeSpan(14, 0, 0, 0);
-  auto isOld = [limit](const AddonPtr& addon){ return addon->LastUpdated() < limit; };
-  addons.erase(std::remove_if(addons.begin(), addons.end(), isOld), addons.end());
-  return true;
-}
-
-static bool HasRecentlyUpdatedAddons()
-{
-  VECADDONS addons;
-  return GetRecentlyUpdatedAddons(addons) && !addons.empty();
-}
 
 static bool Repos(const CURL& path, CFileItemList &items)
 {
@@ -452,14 +551,6 @@ static void RootDirectory(CFileItemList& items)
     item->SetIconImage("DefaultNetwork.png");
     items.Add(item);
   }
-  if (CSettings::GetInstance().GetInt(CSettings::SETTING_ADDONS_AUTOUPDATES) == ADDON::AUTO_UPDATES_ON
-      && HasRecentlyUpdatedAddons())
-  {
-    CFileItemPtr item(new CFileItem("addons://recently_updated/", true));
-    item->SetLabel(g_localizeStrings.Get(24004));
-    item->SetIconImage("DefaultAddonsRecentlyUpdated.png");
-    items.Add(item);
-  }
   if (CAddonMgr::GetInstance().HasAddons(ADDON_REPOSITORY))
   {
     CFileItemPtr item(new CFileItem("addons://repos/", true));
@@ -549,19 +640,6 @@ bool CAddonsDirectory::GetDirectory(const CURL& url, CFileItemList &items)
   {
     return GetSearchResults(path, items);
   }
-  else if (endpoint == "recently_updated")
-  {
-    VECADDONS addons;
-    if (!GetRecentlyUpdatedAddons(addons))
-      return false;
-
-    std::sort(addons.begin(), addons.end(),
-        [](const AddonPtr& a, const AddonPtr& b){ return a->LastUpdated() > b->LastUpdated(); });
-
-    CAddonsDirectory::GenerateAddonListing(path, addons, items, g_localizeStrings.Get(24004));
-    return true;
-
-  }
   else if (endpoint == "downloading")
   {
     VECADDONS addons;
diff --git a/xbmc/filesystem/CacheStrategy.cpp b/xbmc/filesystem/CacheStrategy.cpp
index 890902c..006940b 100644
--- a/xbmc/filesystem/CacheStrategy.cpp
+++ b/xbmc/filesystem/CacheStrategy.cpp
@@ -21,10 +21,6 @@
 #include "threads/SystemClock.h"
 #include "CacheStrategy.h"
 #include "IFile.h"
-#ifdef TARGET_POSIX
-#include "PlatformInclude.h"
-#include "ConvUtils.h"
-#endif
 #include "Util.h"
 #include "utils/log.h"
 #include "SpecialProtocol.h"
diff --git a/xbmc/filesystem/DirectoryFactory.cpp b/xbmc/filesystem/DirectoryFactory.cpp
index c66e1d8..b84ccde 100644
--- a/xbmc/filesystem/DirectoryFactory.cpp
+++ b/xbmc/filesystem/DirectoryFactory.cpp
@@ -112,7 +112,7 @@ IDirectory* CDirectoryFactory::Create(const CURL& url)
   if (!CWakeOnAccess::GetInstance().WakeUpHost(url))
     return NULL;
 
-  CFileItem item(url.Get(), true);
+  CFileItem item(url.Get(), false);
   IFileDirectory* pDir=CFileDirectoryFactory::Create(url, &item);
   if (pDir)
     return pDir;
diff --git a/xbmc/filesystem/FileCache.cpp b/xbmc/filesystem/FileCache.cpp
index b1474ac..2d76b65 100644
--- a/xbmc/filesystem/FileCache.cpp
+++ b/xbmc/filesystem/FileCache.cpp
@@ -37,10 +37,6 @@
 #include <algorithm>
 #include <memory>
 
-#ifdef TARGET_POSIX
-#include "linux/ConvUtils.h"
-#endif
-
 using namespace XFILE;
 
 #define READ_CACHE_CHUNK_SIZE (64*1024)
diff --git a/xbmc/filesystem/ISO9660Directory.cpp b/xbmc/filesystem/ISO9660Directory.cpp
index 55457fb..6ad7056 100644
--- a/xbmc/filesystem/ISO9660Directory.cpp
+++ b/xbmc/filesystem/ISO9660Directory.cpp
@@ -25,9 +25,6 @@
 #include "utils/StringUtils.h"
 #include "URL.h"
 #include "FileItem.h"
-#ifdef TARGET_POSIX
-#include "linux/XTimeUtils.h"
-#endif
 
 using namespace XFILE;
 
diff --git a/xbmc/filesystem/MusicDatabaseDirectory.cpp b/xbmc/filesystem/MusicDatabaseDirectory.cpp
index 20c57e7..4eafeaa 100644
--- a/xbmc/filesystem/MusicDatabaseDirectory.cpp
+++ b/xbmc/filesystem/MusicDatabaseDirectory.cpp
@@ -112,6 +112,13 @@ bool CMusicDatabaseDirectory::IsArtistDir(const std::string& strDirectory)
   return (node==NODE_TYPE_ARTIST);
 }
 
+bool CMusicDatabaseDirectory::HasAlbumInfo(const std::string& strDirectory)
+{
+  NODE_TYPE node=GetDirectoryType(strDirectory);
+  return (node!=NODE_TYPE_OVERVIEW && node!=NODE_TYPE_TOP100 &&
+          node!=NODE_TYPE_GENRE && node!=NODE_TYPE_ARTIST && node!=NODE_TYPE_YEAR);
+}
+
 void CMusicDatabaseDirectory::ClearDirectoryCache(const std::string& strDirectory)
 {
   std::string path = CLegacyPathTranslation::TranslateMusicDbPath(strDirectory);
diff --git a/xbmc/filesystem/MusicDatabaseDirectory.h b/xbmc/filesystem/MusicDatabaseDirectory.h
index 027f86b..d3b692f 100644
--- a/xbmc/filesystem/MusicDatabaseDirectory.h
+++ b/xbmc/filesystem/MusicDatabaseDirectory.h
@@ -37,6 +37,7 @@ namespace XFILE
     static MUSICDATABASEDIRECTORY::NODE_TYPE GetDirectoryType(const std::string& strPath);
     static MUSICDATABASEDIRECTORY::NODE_TYPE GetDirectoryParentType(const std::string& strPath);
     bool IsArtistDir(const std::string& strDirectory);
+    bool HasAlbumInfo(const std::string& strDirectory);
     void ClearDirectoryCache(const std::string& strDirectory);
     static bool IsAllItem(const std::string& strDirectory);
     static bool GetLabel(const std::string& strDirectory, std::string& strLabel);
diff --git a/xbmc/filesystem/NFSDirectory.cpp b/xbmc/filesystem/NFSDirectory.cpp
index 81da26e..c744aa8 100644
--- a/xbmc/filesystem/NFSDirectory.cpp
+++ b/xbmc/filesystem/NFSDirectory.cpp
@@ -27,10 +27,6 @@
 #include <sys\stat.h>
 #endif
 
-#ifdef TARGET_POSIX
-#include "linux/XTimeUtils.h"
-#endif
-
 #include "NFSDirectory.h"
 #include "FileItem.h"
 #include "utils/log.h"
diff --git a/xbmc/filesystem/RarFile.cpp b/xbmc/filesystem/RarFile.cpp
index 54bf8e3..b7f8065 100644
--- a/xbmc/filesystem/RarFile.cpp
+++ b/xbmc/filesystem/RarFile.cpp
@@ -38,10 +38,6 @@
 #include <process.h>
 #endif
 
-#ifdef TARGET_POSIX
-#include "linux/XTimeUtils.h"
-#endif
-
 using namespace XFILE;
 
 #define SEEKTIMOUT 30000
diff --git a/xbmc/filesystem/RarManager.cpp b/xbmc/filesystem/RarManager.cpp
index 94e2b9c..128cf13 100644
--- a/xbmc/filesystem/RarManager.cpp
+++ b/xbmc/filesystem/RarManager.cpp
@@ -40,10 +40,6 @@
 
 #include <set>
 
-#ifdef TARGET_POSIX
-#include "linux/XFileUtils.h"
-#endif
-
 #define EXTRACTION_WARN_SIZE 50*1024*1024
 
 using namespace XFILE;
diff --git a/xbmc/filesystem/SFTPFile.cpp b/xbmc/filesystem/SFTPFile.cpp
index 18e7558..2438dbd 100644
--- a/xbmc/filesystem/SFTPFile.cpp
+++ b/xbmc/filesystem/SFTPFile.cpp
@@ -101,7 +101,7 @@ static const char * SFTPErrorText(int sftp_error)
 
 CSFTPSession::CSFTPSession(const std::string &host, unsigned int port, const std::string &username, const std::string &password)
 {
-  CLog::Log(LOGINFO, "SFTPSession: Creating new session on host '%s:%d'", host.c_str(), port);
+  CLog::Log(LOGINFO, "SFTPSession: Creating new session on host '%s:%d' with user '%s'", host.c_str(), port, username.c_str());
   CSingleLock lock(m_critSect);
   if (!Connect(host, port, username, password))
     Disconnect();
diff --git a/xbmc/filesystem/SMBDirectory.cpp b/xbmc/filesystem/SMBDirectory.cpp
index df9c959..825ae3c 100644
--- a/xbmc/filesystem/SMBDirectory.cpp
+++ b/xbmc/filesystem/SMBDirectory.cpp
@@ -41,9 +41,6 @@
 #include "utils/URIUtils.h"
 #include "threads/SingleLock.h"
 #include "PasswordManager.h"
-#ifdef TARGET_POSIX
-#include "linux/XTimeUtils.h"
-#endif
 
 #include <libsmbclient.h>
 
diff --git a/xbmc/filesystem/ZipFile.cpp b/xbmc/filesystem/ZipFile.cpp
index 8c403e0..5d49152 100644
--- a/xbmc/filesystem/ZipFile.cpp
+++ b/xbmc/filesystem/ZipFile.cpp
@@ -27,8 +27,12 @@
 #include <sys/stat.h>
 
 #if defined (TARGET_WINDOWS)
+#if defined (_DEBUG)
+#pragma comment(lib, "zlibd.lib")
+#else
 #pragma comment(lib, "zlib.lib")
 #endif
+#endif
 #define ZIP_CACHE_LIMIT 4*1024*1024
 
 using namespace XFILE;
diff --git a/xbmc/filesystem/iso9660.cpp b/xbmc/filesystem/iso9660.cpp
index e6acf2d..3bae1fa 100644
--- a/xbmc/filesystem/iso9660.cpp
+++ b/xbmc/filesystem/iso9660.cpp
@@ -52,8 +52,6 @@ ISO9660
 
 #ifndef TARGET_WINDOWS
 #include "storage/DetectDVDType.h"  // for MODE2_DATA_SIZE etc.
-#include "linux/XFileUtils.h"
-#include "linux/XTimeUtils.h"
 #endif
 #include <cdio/bytesex.h>
 //#define _DEBUG_OUTPUT 1
diff --git a/xbmc/filesystem/win32/Win32Directory.cpp b/xbmc/filesystem/win32/Win32Directory.cpp
index 408d402..eb4c5aa 100644
--- a/xbmc/filesystem/win32/Win32Directory.cpp
+++ b/xbmc/filesystem/win32/Win32Directory.cpp
@@ -62,7 +62,7 @@ bool CWin32Directory::GetDirectory(const CURL& url, CFileItemList &items)
   items.Clear();
 
   std::string pathWithSlash(url.Get());
-  if (!pathWithSlash.empty() && pathWithSlash.back() != '\\')
+  if (pathWithSlash.back() != '\\')
     pathWithSlash.push_back('\\');
 
   std::wstring searchMask(CWIN32Util::ConvertPathToWin32Form(pathWithSlash));
@@ -88,7 +88,7 @@ bool CWin32Directory::GetDirectory(const CURL& url, CFileItemList &items)
     std::wstring itemNameW(findData.cFileName);
     if (itemNameW == L"." || itemNameW == L"..")
       continue;
-
+    
     std::string itemName;
     if (!g_charsetConverter.wToUTF8(itemNameW, itemName, true) || itemName.empty())
     {
@@ -104,18 +104,18 @@ bool CWin32Directory::GetDirectory(const CURL& url, CFileItemList &items)
     else
       pItem->SetPath(pathWithSlash + itemName);
 
-    if ((findData.dwFileAttributes & (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM)) != 0
+    if ((findData.dwFileAttributes & (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM)) != 0 
           || itemName.front() == '.') // mark files starting from dot as hidden
       pItem->SetProperty("file:hidden", true);
 
-    // calculation of size and date costs a little on win32
+    // calculation of size and date costs a little on win32 
     // so DIR_FLAG_NO_FILE_INFO flag is ignored
     FILETIME localTime;
     if (FileTimeToLocalFileTime(&findData.ftLastWriteTime, &localTime) == TRUE)
       pItem->m_dateTime = localTime;
     else
       pItem->m_dateTime = 0;
-
+ 
     if (!pItem->m_bIsFolder)
         pItem->m_dwSize = (__int64(findData.nFileSizeHigh) << 32) + findData.nFileSizeLow;
 
@@ -123,7 +123,7 @@ bool CWin32Directory::GetDirectory(const CURL& url, CFileItemList &items)
   } while (FindNextFileW(hSearch, &findData));
 
   FindClose(hSearch);
-
+  
   return true;
 }
 
diff --git a/xbmc/games/GameFileAutoLauncher.cpp b/xbmc/games/GameFileAutoLauncher.cpp
new file mode 100644
index 0000000..7497cd6
--- /dev/null
+++ b/xbmc/games/GameFileAutoLauncher.cpp
@@ -0,0 +1,156 @@
+/*
+ *      Copyright (C) 2013-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "GameFileAutoLauncher.h"
+#include "Application.h"
+#include "dialogs/GUIDialogYesNo.h"
+#include "games/addons/GameClient.h"
+#include "games/tags/GameInfoTag.h"
+#include "guilib/GUIWindowManager.h"
+#include "guilib/WindowIDs.h"
+#include "threads/SingleLock.h"
+#include "utils/log.h"
+#include "utils/URIUtils.h"
+#include "utils/Variant.h"
+
+#include <string>
+
+#define UPDATE_INTERVAL_MS   5 * 1000 // 5s
+#define TIMEOUT_MS           2 * 60 * 1000 // 2 mins
+
+using namespace GAME;
+
+CGameFileAutoLauncher::CGameFileAutoLauncher() : CThread("Game launcher")
+{
+}
+
+CGameFileAutoLauncher::~CGameFileAutoLauncher()
+{
+  StopThread();
+}
+
+void CGameFileAutoLauncher::Process()
+{
+  m_timeout.Set(TIMEOUT_MS);
+
+  // Loop continuously until StopThread() is called
+  CEvent dummy;
+  while (!(AbortableWait(dummy, UPDATE_INTERVAL_MS) == WAIT_INTERRUPTED || m_bStop))
+  {
+    // Otherwise, AbortableWait() returned WAIT_TIMEDOUT (the wait timed out)
+    // Check state and wait again
+    CSingleLock lock(m_critSection);
+    if (!m_queuedFile || !IsStateValid())
+    {
+      CLog::Log(LOGDEBUG, "GameFileLauncher: aborted launch");
+      m_queuedFile.reset();
+      break;
+    }
+  }
+  // StopThread() was called or state became invalid
+}
+
+void CGameFileAutoLauncher::SetAutoLaunch(const CFileItem& file)
+{
+  if (m_queuedFile)
+    StopThread(true);
+
+  {
+    CSingleLock lock(m_critSection);
+    m_queuedFile = CFileItemPtr(new CFileItem(file));
+  }
+
+  CLog::Log(LOGDEBUG, "GameFileLauncher: queued %s", file.GetPath().c_str());
+
+  Create();
+}
+
+void CGameFileAutoLauncher::ClearAutoLaunch()
+{
+  {
+    CSingleLock lock(m_critSection);
+    m_queuedFile.reset();
+  }
+
+  StopThread(false);
+}
+
+bool CGameFileAutoLauncher::IsStateValid()
+{
+  // Check timeout
+  if (m_timeout.IsTimePast())
+    return false;
+
+  // Check if the user is still in the add-on browser
+  if (!g_windowManager.IsWindowActive(WINDOW_ADDON_BROWSER))
+    return false;
+
+  return true;
+}
+
+void CGameFileAutoLauncher::Launch(const GameClientPtr& gameClient)
+{
+  CFileItemPtr file;
+  {
+    CSingleLock lock(m_critSection);
+    if (!m_queuedFile || !gameClient)
+      return;
+    file = m_queuedFile;
+  }
+
+  if (!gameClient->CanOpen(*file))
+    return;
+
+  CGUIDialogYesNo *pDialog = dynamic_cast<CGUIDialogYesNo*>(g_windowManager.GetWindow(WINDOW_DIALOG_YES_NO));
+  if (!pDialog)
+    return;
+
+  CLog::Log(LOGDEBUG, "GameFileAutoLauncher: prompting user for launch of %s", file->GetPath().c_str());
+
+  std::string strTitle;
+  if (file->HasGameInfoTag())
+    strTitle = file->GetGameInfoTag()->GetTitle();
+  if (strTitle.empty())
+    strTitle = URIUtils::GetFileName(file->GetPath());
+
+  /* TODO
+  pDialog->SetHeading(27005); // Manage emulators...
+  pDialog->SetLine(0, 27004); // A compatible emulator was installed for:
+  pDialog->SetLine(1, strTitle);
+  pDialog->SetLine(2, 20013); // Do you wish to launch the game?
+  pDialog->DoModal();
+
+  if (pDialog->IsConfirmed())
+  {
+    // Close the add-on info dialog, if open
+    int iWindow = g_windowManager.GetTopMostModalDialogID(true);
+    CGUIWindow* window = g_windowManager.GetWindow(iWindow);
+    if (window)
+      window->Close();
+
+    // Force game client (so we aren't prompted for game client list by PlayMedia())
+    file->SetProperty("Addon.ID", gameClient->ID());
+
+    g_application.PlayMedia(*file);
+  }
+  */
+
+  ClearAutoLaunch(); // Don't ask to launch the same file twice
+}
diff --git a/xbmc/games/GameFileAutoLauncher.h b/xbmc/games/GameFileAutoLauncher.h
new file mode 100644
index 0000000..17e1540
--- /dev/null
+++ b/xbmc/games/GameFileAutoLauncher.h
@@ -0,0 +1,75 @@
+/*
+ *      Copyright (C) 2013-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+#include "FileItem.h"
+#include "GameTypes.h"
+#include "threads/CriticalSection.h"
+#include "threads/SystemClock.h"
+#include "threads/Thread.h"
+
+namespace GAME
+{
+  /**
+    * Class providing auto-launch functionality for the game browser. When the
+    * user launches a game with no compatible clients, the game browser will
+    * enqueue the file with CGameManager. RetroPlayer will give the user the
+    * option of visiting the add-on manager, where the user can manually install
+    * game clients. When a compatible game client is installed, the user will
+    * then be prompted to launch the queued game file. The purpose of this is
+    * to enable seamless launching of newly-installed game clients.
+    */
+  class CGameFileAutoLauncher : protected CThread
+  {
+  public:
+    CGameFileAutoLauncher();
+    ~CGameFileAutoLauncher();
+
+    /**
+     * Queue a file to be launched when a compatible emulator is installed.
+     */
+    void SetAutoLaunch(const CFileItem& file);
+    void ClearAutoLaunch();
+
+    /**
+     * Launch the queued file (if any) with the specified game client, if possible.
+     */
+    void Launch(const GameClientPtr& gameClient);
+
+  protected:
+    /**
+      * Monitor state of app and dequeue file when appropriate (user leaves
+      * add-on manager, too much time passes, etc).
+      */
+    virtual void Process() override;
+
+  private:
+    /**
+     * Return true if app is in a launch-ready state (add-on browser still
+     * visible, timeout hasn't elapsed).
+     */
+    bool IsStateValid();
+
+  private:
+    CFileItemPtr         m_queuedFile;
+    CCriticalSection     m_critSection;
+    XbmcThreads::EndTime m_timeout;
+  };
+} // namespace GAME
diff --git a/xbmc/games/GameManager.cpp b/xbmc/games/GameManager.cpp
new file mode 100644
index 0000000..761fea7
--- /dev/null
+++ b/xbmc/games/GameManager.cpp
@@ -0,0 +1,176 @@
+/*
+ *      Copyright (C) 2012-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "GameManager.h"
+#include "addons/Addon.h"
+#include "FileItem.h"
+#include "games/addons/GameClient.h"
+#include "threads/SingleLock.h"
+#include "URL.h"
+#include "utils/log.h"
+#include "utils/StringUtils.h"
+#include "utils/URIUtils.h"
+#include "utils/Variant.h"
+
+using namespace ADDON;
+using namespace GAME;
+using namespace XFILE;
+
+CGameManager& CGameManager::GetInstance()
+{
+  static CGameManager gameManagerInstance;
+  return gameManagerInstance;
+}
+
+void CGameManager::Start()
+{
+  UpdateAddons();
+
+  CAddonMgr::GetInstance().RegisterObserver(this);
+  CAddonMgr::GetInstance().RegisterAddonMgrCallback(ADDON_GAMEDLL, this);
+}
+
+void CGameManager::Stop()
+{
+  CAddonMgr::GetInstance().UnregisterObserver(this);
+  CAddonMgr::GetInstance().UnregisterAddonMgrCallback(ADDON_GAMEDLL);
+}
+
+void CGameManager::UpdateAddons()
+{
+  VECADDONS addonsEnabled;
+  VECADDONS addonsAll;
+
+  CAddonMgr::GetInstance().GetAddons(addonsEnabled, ADDON_GAMEDLL);
+  CAddonMgr::GetInstance().GetInstalledAddons(addonsAll, ADDON_GAMEDLL);
+  CAddonMgr::GetInstance().GetInstallableAddons(addonsAll, ADDON_GAMEDLL);
+
+  CSingleLock lock(m_critSection);
+
+  // Process add-ons
+  bool bModified = false;
+  for (const AddonPtr& addon : addonsEnabled)
+  {
+    GameClientPtr gameClient = std::dynamic_pointer_cast<CGameClient>(addon);
+    if (!gameClient)
+      continue;
+
+    if (m_gameClients.find(gameClient->ID()) != m_gameClients.end())
+      continue; // Already registered
+
+    m_gameClients[gameClient->ID()] = gameClient;
+    // TODO: Create directories
+    bModified = true;
+
+    CLog::Log(LOGDEBUG, "GameManager: Registered add-on %s", gameClient->ID().c_str());
+  }
+
+  // Process extensions
+  for (const AddonPtr& addon : addonsAll)
+  {
+    GameClientPtr gc = std::dynamic_pointer_cast<CGameClient>(addon);
+    if (gc)
+      m_gameExtensions.insert(gc->GetExtensions().begin(), gc->GetExtensions().end());
+  }
+
+  CLog::Log(LOGDEBUG, "GameManager: tracking %u extensions", (unsigned)m_gameExtensions.size());
+}
+
+bool CGameManager::GetAddonInstance(const std::string& strClientId, GameClientPtr& addon) const
+{
+  CSingleLock lock(m_critSection);
+
+  auto it = m_gameClients.find(strClientId);
+  if (it != m_gameClients.end())
+  {
+    addon = it->second;
+    return true;
+  }
+  return false;
+}
+
+GameClientPtr CGameManager::GetGameClient(const CFileItem& file) const
+{
+  GameClientPtr client;
+
+  std::vector<std::string> clientIds;
+  GetGameClientIDs(file, clientIds);
+  if (!clientIds.empty())
+    GetAddonInstance(clientIds[0], client); // TODO
+
+  return client;
+}
+
+void CGameManager::GetGameClientIDs(const CFileItem& file, std::vector<std::string>& candidates) const
+{
+  CSingleLock lock(m_critSection);
+
+  const std::string strRequestedClient = file.GetProperty("Addon.ID").asString();
+  
+  for (GameClientMap::const_iterator it = m_gameClients.begin(); it != m_gameClients.end(); it++)
+  {
+    if (!strRequestedClient.empty() && strRequestedClient != it->first)
+      continue;
+
+    CLog::Log(LOGDEBUG, "GameManager: Testing %s", it->second->ID().c_str());
+    if (it->second->CanOpen(file))
+    {
+      CLog::Log(LOGDEBUG, "GameManager: Adding client %s as a candidate", it->second->ID().c_str());
+      candidates.push_back(it->second->ID());
+    }
+
+    // If the requested client isn't installed, there are no valid candidates
+    if (!strRequestedClient.empty())
+      break;
+  }
+}
+
+void CGameManager::GetExtensions(std::vector<std::string> &exts) const
+{
+  CSingleLock lock(m_critSection);
+  exts.insert(exts.end(), m_gameExtensions.begin(), m_gameExtensions.end());
+}
+
+bool CGameManager::IsGame(const std::string &path) const
+{
+  // Get the file extension (must use a CURL, if the string is top-level zip
+  // directory it might not end in .zip)
+  std::string extension(URIUtils::GetExtension(CURL(path).GetFileNameWithoutPath()));
+  if (extension.empty())
+    return false;
+
+  StringUtils::ToLower(extension);
+
+  CSingleLock lock(m_critSection);
+
+  return m_gameExtensions.find(extension) != m_gameExtensions.end();
+}
+
+bool CGameManager::RequestRemoval(AddonPtr addon)
+{
+  // TODO: Remove addon from m_gameClients;
+  return true;
+}
+
+void CGameManager::Notify(const Observable& obs, const ObservableMessage msg)
+{
+  if (msg == ObservableMessageAddons)
+    UpdateAddons();
+}
diff --git a/xbmc/games/GameManager.h b/xbmc/games/GameManager.h
new file mode 100644
index 0000000..cc431eb
--- /dev/null
+++ b/xbmc/games/GameManager.h
@@ -0,0 +1,97 @@
+/*
+ *      Copyright (C) 2012-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+#include "GameFileAutoLauncher.h"
+#include "GameTypes.h"
+#include "addons/AddonManager.h"
+#include "threads/CriticalSection.h"
+#include "utils/Observer.h"
+
+#include <map>
+#include <set>
+#include <string>
+
+class FileItem;
+
+namespace GAME
+{
+  class CGameManager : public ADDON::IAddonMgrCallback,
+                       public Observer
+  {
+  protected:
+    CGameManager() { }
+    CGameManager(CGameManager&);
+
+  public:
+    static CGameManager& GetInstance();
+
+    virtual ~CGameManager() { Stop(); }
+    
+    // implementation of IAddonMgrCallback
+    virtual bool RequestRestart(ADDON::AddonPtr addon, bool datachanged) { return true; }
+    virtual bool RequestRemoval(ADDON::AddonPtr addon); // TODO: Never called!
+
+    // implementation of Observer
+    virtual void Notify(const Observable& obs, const ObservableMessage msg) override;
+
+    void Start();
+    void Stop();
+
+    bool GetAddonInstance(const std::string& strClientId, GameClientPtr& addon) const;
+
+    GameClientPtr GetGameClient(const CFileItem& file) const;
+
+    /**
+     * Resolve a file item to a list of game client IDs.
+     *
+     *   - If the file forces a particular game client via file.SetProperty("Addon.ID", id),
+     *     the result will be that add-on or none.
+     */
+    void GetGameClientIDs(const CFileItem& file, std::vector<std::string>& candidates) const;
+
+    /**
+     * Get a list of valid game client extensions (as determined by the tag in
+     * addon.xml). Includes game clients in remote repositories.
+     */
+    void GetExtensions(std::vector<std::string>& exts) const;
+
+    /**
+     * Returns true if the file extension is supported by an add-on in an enabled
+     * repository.
+     */
+    bool IsGame(const std::string& path) const;
+
+    // Queue a file to be launched when the next game client is installed.
+    void SetAutoLaunch(const CFileItem& file) { m_fileLauncher.SetAutoLaunch(file); }
+    void ClearAutoLaunch()                    { m_fileLauncher.ClearAutoLaunch(); }
+
+  private:
+    void UpdateAddons();
+
+    typedef std::string                           GameClientID;
+    typedef std::map<GameClientID, GameClientPtr> GameClientMap;
+
+    GameClientMap         m_gameClients;
+    std::set<std::string> m_gameExtensions;
+    CGameFileAutoLauncher m_fileLauncher;
+    CCriticalSection      m_critSection;
+  };
+} // namespace GAME
diff --git a/xbmc/games/GameSettings.cpp b/xbmc/games/GameSettings.cpp
new file mode 100644
index 0000000..9f83640
--- /dev/null
+++ b/xbmc/games/GameSettings.cpp
@@ -0,0 +1,69 @@
+/*
+ *      Copyright (C) 2012-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "GameSettings.h"
+#include "guilib/GUIWindowManager.h"
+#include "guilib/WindowIDs.h"
+#include "peripherals/Peripherals.h"
+#include "settings/lib/Setting.h"
+#include "utils/StringUtils.h"
+
+#include <cstring>
+#include <string>
+#include <vector>
+
+using namespace GAME;
+
+#define SETTING_PREFIX  "gamesinput.emulatedcontroller"
+
+CGameSettings& CGameSettings::GetInstance()
+{
+  static CGameSettings gameSettingsInstance;
+  return gameSettingsInstance;
+}
+
+void CGameSettings::OnSettingChanged(const CSetting* setting)
+{
+  if (setting == NULL)
+    return;
+
+  const std::string& settingId = setting->GetId();
+  if (settingId == "gamesinput.emulatedcontrollers")
+  {
+    PERIPHERALS::g_peripherals.TriggerDeviceScan(PERIPHERALS::PERIPHERAL_BUS_APPLICATION);
+  }
+}
+
+void CGameSettings::OnSettingAction(const CSetting* setting)
+{
+  if (setting == NULL)
+    return;
+
+  const std::string& settingId = setting->GetId();
+  if (settingId == "gamesinput.controllerconfig")
+  {
+    g_windowManager.ActivateWindow(WINDOW_DIALOG_GAME_CONTROLLERS);
+  }
+  else if (StringUtils::StartsWith(settingId, SETTING_PREFIX))
+  {
+    std::string strControllerIndex = settingId.substr(std::strlen(SETTING_PREFIX));
+    g_windowManager.ActivateWindow(WINDOW_DIALOG_GAME_CONTROLLERS, strControllerIndex);
+  }
+}
diff --git a/xbmc/games/GameSettings.h b/xbmc/games/GameSettings.h
new file mode 100644
index 0000000..c914880
--- /dev/null
+++ b/xbmc/games/GameSettings.h
@@ -0,0 +1,43 @@
+/*
+ *      Copyright (C) 2012-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+#include "settings/lib/ISettingCallback.h"
+
+class CSetting;
+
+namespace GAME
+{
+
+class CGameSettings : public ISettingCallback
+{
+public:
+  static CGameSettings& GetInstance();
+  virtual ~CGameSettings() { }
+
+  // Inherited from ISettingCallback
+  virtual void OnSettingChanged(const CSetting* setting) override;
+  virtual void OnSettingAction(const CSetting* setting) override;
+
+private:
+  CGameSettings() { }
+};
+
+} // namespace GAME
diff --git a/xbmc/games/GameTypes.h b/xbmc/games/GameTypes.h
new file mode 100644
index 0000000..0421908
--- /dev/null
+++ b/xbmc/games/GameTypes.h
@@ -0,0 +1,32 @@
+/*
+ *      Copyright (C) 2015-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+#include <memory>
+#include <vector>
+
+namespace GAME
+{
+
+  class CGameClient;
+  typedef std::shared_ptr<CGameClient> GameClientPtr;
+  typedef std::vector<GameClientPtr>   GameClientVector;
+
+}
diff --git a/xbmc/games/Makefile b/xbmc/games/Makefile
new file mode 100644
index 0000000..61359ef
--- /dev/null
+++ b/xbmc/games/Makefile
@@ -0,0 +1,9 @@
+SRCS=GameFileAutoLauncher.cpp \
+     GameManager.cpp \
+     GameSettings.cpp \
+     SerialState.cpp \
+
+LIB=games.a
+
+include ../../Makefile.include
+-include $(patsubst %.cpp,%.P,$(patsubst %.c,%.P,$(SRCS)))
diff --git a/xbmc/games/SerialState.cpp b/xbmc/games/SerialState.cpp
new file mode 100644
index 0000000..fea7672
--- /dev/null
+++ b/xbmc/games/SerialState.cpp
@@ -0,0 +1,108 @@
+/*
+ *      Copyright (C) 2012-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "SerialState.h"
+
+using namespace GAME;
+
+// Pad forward to nearest boundary of bytes
+#define PAD_TO_CEIL(x, bytes)  (((x) + (bytes) - 1) / (bytes))
+
+#ifndef SAFE_DELETE_ARRAY
+#define SAFE_DELETE_ARRAY(p)   do { delete[] (p);   (p)=NULL; } while (0)
+#endif
+
+void CSerialState::Init(size_t frameSize, size_t frameCount)
+{
+  Reset();
+  m_frameSize = frameSize; // Size of the frame from retro_serialize_size()
+  m_maxFrames = frameCount;
+  m_stateSize = PAD_TO_CEIL(m_frameSize, sizeof(uint32_t)); // Size of the padded frame ( >= m_frameSize)
+  m_state = new uint32_t[m_stateSize];
+  m_nextState = new uint32_t[m_stateSize];
+}
+
+// Make sure m_state and m_nextState are zero-initialized in the constructor
+void CSerialState::Reset()
+{
+  SAFE_DELETE_ARRAY(m_state);
+  SAFE_DELETE_ARRAY(m_nextState);
+  m_rewindBuffer.clear();
+  m_frameSize = 0;
+  m_maxFrames = 0;
+  m_stateSize = 0;
+}
+
+void CSerialState::SetMaxFrames(size_t frameCount)
+{
+  m_maxFrames = frameCount;
+  if (!m_maxFrames && (m_state || m_nextState))
+  {
+    Reset();
+  }
+  else
+  {
+    while (m_rewindBuffer.size() > m_maxFrames)
+      m_rewindBuffer.pop_front();
+  }
+}
+
+void CSerialState::AdvanceFrame()
+{
+  m_rewindBuffer.push_back(DeltaPairVector());
+  DeltaPairVector& buffer = m_rewindBuffer.back();
+
+  for (size_t i = 0; i < m_stateSize; i++)
+  {
+    uint32_t xor_val = m_state[i] ^ m_nextState[i];
+    if (xor_val)
+    {
+      DeltaPair pair = {i, xor_val};
+      buffer.push_back(pair);
+    }
+  }
+
+  // Delta is generated, bring the new frame forward (m_nextState is now disposable)
+  std::swap(m_state, m_nextState);
+
+  while (m_rewindBuffer.size() > m_maxFrames)
+    m_rewindBuffer.pop_front();
+}
+
+unsigned int CSerialState::RewindFrames(unsigned int frameCount)
+{
+  unsigned int rewound = 0;
+  while (frameCount > 0 && !m_rewindBuffer.empty())
+  {
+    const DeltaPair *buffer = m_rewindBuffer.back().data();
+
+    size_t bufferSize = m_rewindBuffer.back().size();
+    // buffer pointer redirection violates data-dependency requirements...
+    // no vecorization for us :(
+    for (size_t i = 0; i < bufferSize; i++)
+      m_state[buffer[i].pos] ^= buffer[i].delta;
+
+    rewound++;
+    frameCount--;
+    m_rewindBuffer.pop_back();
+  }
+
+  return rewound;
+}
diff --git a/xbmc/games/SerialState.h b/xbmc/games/SerialState.h
new file mode 100644
index 0000000..c8b4449
--- /dev/null
+++ b/xbmc/games/SerialState.h
@@ -0,0 +1,84 @@
+/*
+ *      Copyright (C) 2012-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+#include <deque>
+#include <vector>
+#include <stdint.h>
+#include <stdlib.h>
+
+namespace GAME
+{
+
+class CSerialState
+{
+public:
+  CSerialState() : m_frameSize(0), m_maxFrames(0), m_stateSize(0), m_state(NULL), m_nextState(NULL) { }
+  ~CSerialState() { Reset(); }
+
+  void Init(size_t frameSize, size_t frameCount);
+  void ReInit() { Init(m_frameSize, m_maxFrames); }
+  bool IsInited() const { return m_state && m_nextState; }
+  void Reset(); // Free up any memory allocated
+  void SetMaxFrames(size_t frameCount);
+
+  uint8_t *GetState() const { return reinterpret_cast<uint8_t*>(m_state); }
+  uint8_t *GetNextState() const { return reinterpret_cast<uint8_t*>(m_nextState); }
+  size_t GetFrameSize() const { return m_frameSize; }
+  size_t GetMaxFrames() const { return m_maxFrames; }
+  size_t GetFramesAvailable() const { return m_rewindBuffer.size(); }
+
+  void AdvanceFrame();
+  unsigned int RewindFrames(unsigned int frameCount);
+
+private:
+  // Size of the serialized data returned by retro_serialize_size()
+  size_t m_frameSize;
+  // Maximum number of frames in the history rewind buffer
+  size_t m_maxFrames;
+
+  /**
+   * Simple double-buffering. After XORing the two states, the next becomes the
+   * current, and the current because a buffer for the next call to
+   * retro_serialize().
+   */
+  size_t   m_stateSize;
+  uint32_t *m_state;
+  uint32_t *m_nextState;
+
+  /**
+   * Rewinding is implemented by applying XOR deltas on the specific parts of
+   * the save state buffer which have changed. In practice, this is very fast
+   * and simple (linear scan) and allows deltas to be compressed down to 1-3%
+   * of original save state size depending on the system. The algorithm runs on
+   * 32 bits at a time for speed. The state buffer has a fixed number of frames.
+   *
+   * Use std::deque here to achieve amortized O(1) on pop/push to front and back.
+   */
+  struct DeltaPair
+  {
+    size_t   pos;
+    uint32_t delta;
+  };
+  typedef std::vector<DeltaPair> DeltaPairVector;
+  std::deque<DeltaPairVector>    m_rewindBuffer;
+};
+
+} // namespace GAME
diff --git a/xbmc/games/addons/GameClient.cpp b/xbmc/games/addons/GameClient.cpp
new file mode 100644
index 0000000..afccd09
--- /dev/null
+++ b/xbmc/games/addons/GameClient.cpp
@@ -0,0 +1,1068 @@
+/*
+ *      Copyright (C) 2012-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "GameClient.h"
+#include "GameClientInput.h"
+#include "addons/AddonManager.h"
+#include "cores/IPlayer.h"
+#include "cores/AudioEngine/Utils/AEChannelInfo.h"
+#include "dialogs/GUIDialogContextMenu.h"
+#include "FileItem.h"
+#include "filesystem/Directory.h"
+#include "filesystem/SpecialProtocol.h"
+#include "games/controllers/Controller.h"
+#include "games/ports/PortManager.h"
+#include "games/GameManager.h"
+#include "guilib/GUIWindowManager.h"
+#include "guilib/WindowIDs.h"
+#include "input/InputManager.h"
+#include "input/joysticks/DefaultJoystick.h" // for DEFAULT_CONTROLLER_ID
+#include "input/joysticks/JoystickTypes.h"
+#include "peripherals/Peripherals.h"
+#include "settings/Settings.h"
+#include "threads/SingleLock.h"
+#include "URL.h"
+#include "utils/log.h"
+#include "utils/StringUtils.h"
+#include "utils/URIUtils.h"
+
+#include <algorithm>
+
+using namespace ADDON;
+using namespace GAME;
+using namespace JOYSTICK;
+using namespace XFILE;
+
+#define EXTENSION_SEPARATOR          "|"
+#define EXTENSION_WILDCARD           "*"
+#define GAME_REGION_NTSC_STRING      "NTSC"
+#define GAME_REGION_PAL_STRING       "PAL"
+#define MAX_LAUNCH_FILE_CHOICES      20 // Show up to this many games when a direcory is played
+#define BUTTON_INDEX_MASK            0x01ff
+#define MAX_VIDEO_BUFFER_SIZE        (2 * 1024 * 1024) // 1s at 2MB/s
+#define MAX_AUDIO_BUFFER_SIZE        (48000 * 4) // 1s at 48000, 16 bit
+
+
+// --- NormalizeExtension ------------------------------------------------------
+
+namespace
+{
+  /*
+   * \brief Convert to lower case and canonicalize with a leading "."
+   */
+  std::string NormalizeExtension(const std::string& strExtension)
+  {
+    std::string ext = strExtension;
+
+    if (!ext.empty() && ext != EXTENSION_WILDCARD)
+    {
+      StringUtils::ToLower(ext);
+
+      if (ext[0] != '.')
+        ext.insert(0, ".");
+    }
+
+    return ext;
+  }
+}
+
+// --- CGameClient -------------------------------------------------------------
+
+std::unique_ptr<CGameClient> CGameClient::FromExtension(ADDON::AddonProps props, const cp_extension_t* ext)
+{
+  /*
+  string strPlatforms = CAddonMgr::GetInstance().GetExtValue(ext->configuration, "platforms");
+  if (!strPlatforms.empty())
+  {
+    Props().extrainfo.insert(make_pair("platforms", strPlatforms));
+    SetPlatforms(strPlatforms);
+  }
+  */
+  std::vector<std::string> extensions;
+  std::string strExtensions = CAddonMgr::GetInstance().GetExtValue(ext->configuration, "extensions");
+  if (!strExtensions.empty())
+    extensions = ParseExtensions(strExtensions);
+
+  std::string strSupportsVFS = CAddonMgr::GetInstance().GetExtValue(ext->configuration, "supports_vfs");
+  bool bSupportsVFS = (strSupportsVFS == "true" || strSupportsVFS == "yes");
+
+  std::string strSupportsStandalone = CAddonMgr::GetInstance().GetExtValue(ext->configuration, "supports_no_game");
+  bool bSupportsStandalone = (strSupportsStandalone == "true" || strSupportsStandalone == "yes");
+
+  std::string strSupportsDirectory = CAddonMgr::GetInstance().GetExtValue(ext->configuration, "supports_directory");
+  bool bSupportsDirectory = (strSupportsDirectory == "true" || strSupportsDirectory == "yes");
+
+  std::string strSupportsKeyboard = CAddonMgr::GetInstance().GetExtValue(ext->configuration, "supports_keyboard");
+  bool bSupportsKeyboard = (strSupportsKeyboard == "true" || strSupportsKeyboard == "yes");
+
+  return std::unique_ptr<CGameClient>(new CGameClient(std::move(props), extensions, bSupportsVFS, bSupportsStandalone, bSupportsDirectory, bSupportsKeyboard));
+}
+
+CGameClient::CGameClient(ADDON::AddonProps props, const std::vector<std::string>& extensions, bool bSupportsVFS, bool bSupportsStandalone, bool bSupportsDirectory, bool bSupportsKeyboard)
+  : CAddonDll<DllGameClient, GameClient, game_client_properties>(std::move(props)),
+    m_apiVersion("0.0.0"),
+    m_libraryProps(this, m_pInfo),
+    m_bSupportsVFS(bSupportsVFS),
+    m_bSupportsStandalone(bSupportsStandalone),
+    m_bSupportsDirectory(bSupportsDirectory),
+    m_bSupportsKeyboard(bSupportsKeyboard)
+{
+  m_extensions.insert(extensions.begin(), extensions.end());
+
+  InitializeProperties();
+}
+
+void CGameClient::InitializeProperties(void)
+{
+  m_bIsPlaying = false;
+  m_demuxer = nullptr;
+  m_region = GAME_REGION_NTSC;
+  m_frameRate = 0.0;
+  m_sampleRate = 0.0;
+  m_bHasVideo = false;
+  m_bHasRawVideo = false;
+  m_bHasAudio = false;
+  m_bSerializationInited = false;
+  m_serializeSize = 0;
+  m_bRewindEnabled = false;
+}
+
+CGameClient::~CGameClient(void)
+{
+  /* TODO
+  if (m_bIsPlaying && m_demuxer)
+    m_player->CloseFile();
+  */
+}
+
+bool CGameClient::Initialize(void)
+{
+  // Ensure user profile directory exists for add-on
+  if (!CDirectory::Exists(Profile()))
+    CDirectory::Create(Profile());
+
+  m_libraryProps.InitializeProperties();
+
+  return Create() == ADDON_STATUS_OK;
+}
+
+const std::string CGameClient::LibPath() const
+{
+  // If the game client requires a proxy, load its DLL instead
+  if (m_pInfo->proxy_dll_count > 0)
+    return m_pInfo->proxy_dll_paths[0];
+
+  return CAddon::LibPath();
+}
+
+AddonPtr CGameClient::GetRunningInstance() const
+{
+  GameClientPtr gameAddon;
+  if (CGameManager::GetInstance().GetAddonInstance(ID(), gameAddon))
+    return std::dynamic_pointer_cast<CAddon>(gameAddon);
+
+  return CAddon::GetRunningInstance();
+}
+
+void CGameClient::OnEnabled()
+{
+  //CGameManager::GetInstance().Enable(ID());
+}
+
+void CGameClient::OnDisabled()
+{
+  //CGameManager::GetInstance().Disable(ID());
+}
+
+bool CGameClient::CanOpen(const CFileItem& file) const
+{
+  // Filter by Addon.ID property
+  if (file.HasProperty("Addon.ID") && file.GetProperty("Addon.ID").asString() != ID())
+    return false;
+
+  // Try to resolve path to a local file, as not all game clients support VFS
+  CURL translatedUrl(CSpecialProtocol::TranslatePath(file.GetPath()));
+  if (translatedUrl.GetProtocol() == "file")
+    translatedUrl.SetProtocol("");
+
+  // Filter by vfs support
+  const bool bIsLocalFS = translatedUrl.GetProtocol().empty();
+  if (!bIsLocalFS && !SupportsVFS())
+    return false;
+
+  if (file.m_bIsFolder)
+    return CanOpenDirectory(translatedUrl.Get());
+  else
+    return CanOpenFile(translatedUrl.Get());
+}
+
+bool CGameClient::CanOpenFile(std::string strPath) const
+{
+  // Filter by extension
+  if (IsExtensionValid(URIUtils::GetExtension(strPath)))
+    return true;
+
+  if (URIUtils::IsArchive(strPath))
+    return CanOpenDirectory(strPath);
+
+  return false;
+}
+
+bool CGameClient::CanOpenDirectory(std::string strPath) const
+{
+  // Turn archive files into archive paths
+  if (URIUtils::IsArchive(strPath))
+  {
+    // Must support VFS to load by zip:// protocol
+    if (!SupportsVFS())
+      return false;
+
+    strPath = ToArchivePath(strPath);
+  }
+
+  CFileItemList itemList;
+  if (ResolveDirectory(strPath, itemList))
+    return !itemList.IsEmpty();
+
+  return false;
+}
+
+std::string CGameClient::ResolvePath(const CFileItem& file) const
+{
+  CURL resolvedUrl(CSpecialProtocol::TranslatePath(file.GetPath()));
+  if (resolvedUrl.GetProtocol() == "file")
+    resolvedUrl.SetProtocol("");
+
+  std::string strResolvedPath;
+
+  std::string strPath = resolvedUrl.Get();
+
+  const bool bIsValidExt = !file.m_bIsFolder && IsExtensionValid(URIUtils::GetExtension(strPath));
+  if (bIsValidExt)
+  {
+    strResolvedPath = strPath;
+  }
+  else
+  {
+    bool bIsFolder = file.m_bIsFolder;
+
+    if (URIUtils::IsArchive(strPath))
+    {
+      // Turn archive files into archive paths
+      strPath = ToArchivePath(strPath);
+      bIsFolder |= !strPath.empty();
+    }
+
+    if (bIsFolder)
+    {
+      CFileItemList files;
+      if (ResolveDirectory(strPath, files))
+      {
+        if (files.Size() == 1)
+        {
+          strResolvedPath = files[0]->GetPath();
+        }
+        else if (files.Size() >= 2)
+        {
+          CLog::Log(LOGDEBUG, "%s: Directory contains %d possible game files (%s)", ID().c_str(), files.Size(), strPath.c_str());
+
+          // Don't show too many files
+          unsigned int fileCount = std::min((unsigned int)files.Size(), (unsigned int)MAX_LAUNCH_FILE_CHOICES);
+
+          CContextButtons choices;
+          choices.reserve(fileCount);
+
+          for (unsigned int i = 0; i < fileCount; i++)
+            choices.push_back(std::make_pair(i, files[i]->GetLabel()));
+
+          int result = CGUIDialogContextMenu::ShowAndGetChoice(choices);
+          if (result >= 0)
+            strResolvedPath = files[result]->GetPath();
+          else
+            CLog::Log(LOGDEBUG, "%s: User cancelled game file selection", ID().c_str());
+        }
+
+        if (!strResolvedPath.empty())
+          CLog::Log(LOGDEBUG, "%s: Directory resolved to file: %s", ID().c_str(), strResolvedPath.c_str());
+      }
+    }
+  }
+
+  return strResolvedPath;
+}
+
+std::string CGameClient::ToArchivePath(const std::string& strPath)
+{
+  std::string strArchivePath;
+
+  std::string strType = URIUtils::GetExtension(strPath);
+  if (!strType.empty())
+  {
+    if (strType[0] == '.')
+      strType.erase(strType.begin());
+    strArchivePath = URIUtils::CreateArchivePath(strType, CURL(strPath)).Get();
+  }
+
+  return strArchivePath;
+}
+
+bool CGameClient::ResolveDirectory(const std::string& strPath, CFileItemList& files) const
+{
+  CFileItemList directories;
+  if (GetDirectory(strPath, files, directories))
+  {
+    if (files.IsEmpty() && directories.Size() == 1)
+    {
+      // Try again in subdirectory if there are no files and a single directory
+      CFileItemList dummy;
+      GetDirectory(directories[0]->GetPath(), files, dummy);
+    }
+  }
+
+  return !files.IsEmpty();
+}
+
+bool CGameClient::GetDirectory(std::string strPath, CFileItemList& files, CFileItemList& directories) const
+{
+  if (m_extensions.empty())
+    return false;
+
+  std::string strValidExts;
+  if (!IsExtensionValid(EXTENSION_WILDCARD))
+  {
+    for (std::set<std::string>::const_iterator it = m_extensions.begin(); it != m_extensions.end(); it++)
+      strValidExts += *it + "|";
+  }
+
+  CFileItemList items;
+  if (CDirectory::GetDirectory(strPath, items, strValidExts, DIR_FLAG_READ_CACHE | DIR_FLAG_NO_FILE_INFO))
+  {
+    for (int i = 0; i < items.Size(); i++)
+    {
+      if (items[i]->m_bIsFolder)
+        directories.Add(items[i]);
+      else
+        files.Add(items[i]);
+    }
+    return true;
+  }
+
+  return false;
+}
+
+bool CGameClient::OpenFile(const CFileItem& file, IGameDemuxCallback* demuxer)
+{
+  if (!demuxer)
+    return false;
+
+  // Filter by Addon.ID property
+  if (file.HasProperty("Addon.ID") && file.GetProperty("Addon.ID").asString() != ID())
+    return false;
+
+  CSingleLock lock(m_critSection);
+
+  if (!Initialized())
+    return false;
+
+  if (!m_bSupportsStandalone && !CanOpen(file))
+    return false;
+
+  CloseFile();
+
+  GAME_ERROR error = GAME_ERROR_FAILED;
+  std::string strFilePath;
+
+  if (m_bSupportsStandalone)
+  {
+    try { LogError(error = m_pStruct->LoadStandalone(), "LoadStandalone()"); }
+    catch (...) { LogException("LoadStandalone()"); }
+  }
+  else
+  {
+    std::string strFilePath = ResolvePath(file);
+    if (strFilePath.empty())
+      return false;
+
+    CLog::Log(LOGDEBUG, "GameClient: Loading %s", strFilePath.c_str());
+
+    try { LogError(error = m_pStruct->LoadGame(strFilePath.c_str()), "LoadGame()"); }
+    catch (...) { LogException("LoadGame()"); }
+  }
+
+  if (error == GAME_ERROR_NO_ERROR && LoadGameInfo())
+  {
+    m_filePath        = strFilePath;
+    m_demuxer         = demuxer;
+    m_inputRateHandle = PERIPHERALS::g_peripherals.SetEventScanRate(m_frameRate);
+    m_bIsPlaying      = true;
+
+    if (m_bSupportsKeyboard)
+      OpenKeyboard();
+
+    return true;
+  }
+
+  return false;
+}
+
+bool CGameClient::LoadGameInfo()
+{
+  // Get information about system audio/video timings and geometry
+  // Can be called only after retro_load_game()
+  game_system_av_info av_info = { };
+
+  GAME_ERROR error = GAME_ERROR_FAILED;
+  try { LogError(error = m_pStruct->GetGameInfo(&av_info), "GetGameInfo()"); }
+  catch (...) { LogException("GetGameInfo()"); }
+
+  if (error != GAME_ERROR_NO_ERROR)
+    return false;
+
+  GAME_REGION region;
+  try { region = m_pStruct->GetRegion(); }
+  catch (...) { LogException("GetRegion()"); return false; }
+
+  CLog::Log(LOGINFO, "GAME: ---------------------------------------");
+  CLog::Log(LOGINFO, "GAME: Opened file %s",   m_filePath.c_str());
+  CLog::Log(LOGINFO, "GAME: Base Width:   %u", av_info.geometry.base_width);
+  CLog::Log(LOGINFO, "GAME: Base Height:  %u", av_info.geometry.base_height);
+  CLog::Log(LOGINFO, "GAME: Max Width:    %u", av_info.geometry.max_width);
+  CLog::Log(LOGINFO, "GAME: Max Height:   %u", av_info.geometry.max_height);
+  CLog::Log(LOGINFO, "GAME: Aspect Ratio: %f", av_info.geometry.aspect_ratio);
+  CLog::Log(LOGINFO, "GAME: FPS:          %f", av_info.timing.fps);
+  CLog::Log(LOGINFO, "GAME: Sample Rate:  %f", av_info.timing.sample_rate);
+  CLog::Log(LOGINFO, "GAME: Region:       %s", region == GAME_REGION_NTSC ? GAME_REGION_NTSC_STRING : GAME_REGION_PAL_STRING);
+  CLog::Log(LOGINFO, "GAME: ---------------------------------------");
+
+  m_frameRate  = av_info.timing.fps;
+  m_sampleRate = av_info.timing.sample_rate;
+  m_region     = region;
+
+  return true;
+}
+
+bool CGameClient::InitSerialization()
+{
+  // Check if serialization is supported so savestates and rewind can be used
+  unsigned int serializeSize;
+  try { serializeSize = m_pStruct->SerializeSize(); }
+  catch (...) { LogException("SerializeSize()"); return false; }
+
+  if (serializeSize == 0)
+  {
+    CLog::Log(LOGINFO, "GAME: Serialization not supported, continuing without save or rewind");
+    return false;
+  }
+
+  m_serializeSize = serializeSize;
+  m_bRewindEnabled = CSettings::GetInstance().GetBool("gamesgeneral.enablerewind");
+
+  // Set up rewind functionality
+  if (m_bRewindEnabled)
+  {
+    m_serialState.Init(m_serializeSize, (size_t)(CSettings::GetInstance().GetInt("gamesgeneral.rewindtime") * m_frameRate));
+
+    GAME_ERROR error = GAME_ERROR_FAILED;
+    try { LogError(error = m_pStruct->Serialize(m_serialState.GetState(), m_serialState.GetFrameSize()), "Serialize()"); }
+    catch (...) { LogException("Serialize()"); }
+
+    if (error != GAME_ERROR_NO_ERROR)
+    {
+      m_serializeSize = 0;
+      m_bRewindEnabled = false;
+      m_serialState.Reset();
+      CLog::Log(LOGERROR, "GAME: Unable to serialize state, proceeding without save or rewind");
+      return false;
+    }
+  }
+
+  m_bSerializationInited = true;
+
+  return true;
+}
+
+void CGameClient::Reset()
+{
+  if (m_bIsPlaying)
+  {
+    try { LogError(m_pStruct->Reset(), "Reset()"); }
+    catch (...) { LogException("Reset()"); }
+
+    if (m_bRewindEnabled)
+    {
+      m_serialState.ReInit();
+
+      GAME_ERROR error = GAME_ERROR_FAILED;
+      try { LogError(error = m_pStruct->Serialize(m_serialState.GetNextState(), m_serialState.GetFrameSize()), "Serialize()"); }
+      catch (...) { LogException("Serialize()"); }
+
+      if (error != GAME_ERROR_NO_ERROR)
+        m_bRewindEnabled = false;
+    }
+  }
+}
+
+void CGameClient::CloseFile()
+{
+  CSingleLock lock(m_critSection);
+
+  if (Initialized() && m_bIsPlaying)
+  {
+    try { LogError(m_pStruct->UnloadGame(), "UnloadGame()"); }
+    catch (...) { LogException("UnloadGame()"); }
+  }
+
+  ClearPorts();
+
+  if (m_bSupportsKeyboard)
+    CloseKeyboard();
+
+  m_bIsPlaying = false;
+  m_filePath.clear();
+  if (m_inputRateHandle)
+  {
+    m_inputRateHandle->Release();
+    m_inputRateHandle.reset();
+  }
+  m_demuxer = NULL;
+}
+
+bool CGameClient::OpenVideoStream(AVCodecID codec, AVPixelFormat pixelFormat, unsigned int width, unsigned int height)
+{
+  if (m_demuxer && !m_bHasVideo)
+  {
+    m_demuxer->OpenVideoStream(codec, pixelFormat, width, height);
+    m_bHasVideo = true;
+    m_bHasRawVideo = (codec == AV_CODEC_ID_NONE);
+    return true;
+  }
+  return false;
+}
+
+void CGameClient::AddVideoData(const uint8_t* data, unsigned int size)
+{
+  if (m_bHasVideo)
+  {
+    CSingleLock lock(m_demuxMutex);
+
+    // Ensure buffer doesn't grow too large
+    if (m_videoBuffer.size() > MAX_VIDEO_BUFFER_SIZE)
+      m_videoBuffer.clear();
+
+    if (m_bHasRawVideo)
+      m_videoBuffer.assign(data, data + size); // Only store most recent frame
+    else
+      m_videoBuffer.insert(m_videoBuffer.end(), data, data + size);
+
+    m_demuxEvent.Set();
+  }
+}
+
+void CGameClient::CloseVideoStream()
+{
+  if (m_bHasVideo)
+    m_demuxer->CloseVideoStream();
+  m_bHasVideo = false;
+}
+
+bool CGameClient::OpenAudioStream(AVCodecID codec, unsigned int samplerate, const CAEChannelInfo& channelLayout)
+{
+  if (m_demuxer && !m_bHasAudio)
+  {
+    m_demuxer->OpenAudioStream(codec, samplerate, channelLayout);
+    m_bHasAudio = true;
+    return true;
+  }
+  return false;
+}
+
+void CGameClient::AddAudioData(const uint8_t* data, unsigned int size)
+{
+  if (m_bHasAudio)
+  {
+    CSingleLock lock(m_demuxMutex);
+
+    // Ensure buffer doesn't grow too large
+    if (m_audioBuffer.size() > MAX_AUDIO_BUFFER_SIZE)
+      m_audioBuffer.clear();
+
+    m_audioBuffer.insert(m_audioBuffer.end(), data, data + size);
+
+    m_demuxEvent.Set();
+  }
+}
+
+void CGameClient::CloseAudioStream()
+{
+  if (m_bHasAudio)
+    m_demuxer->CloseAudioStream();
+  m_bHasAudio = false;
+}
+
+bool CGameClient::ReadDemux(std::vector<uint8_t>& buffer, STREAM_TYPE& streamType)
+{
+  streamType = STREAM_TYPE::NONE;
+
+  bool bHasPacket;
+  {
+    CSingleLock lock(m_demuxMutex);
+    bHasPacket = !m_videoBuffer.empty() || !m_audioBuffer.empty();
+  }
+
+  if (!bHasPacket)
+    m_demuxEvent.WaitMSec(1000);
+
+  {
+    CSingleLock lock(m_demuxMutex);
+
+    if (!m_videoBuffer.empty())
+    {
+      buffer = m_videoBuffer;
+      streamType = STREAM_TYPE::VIDEO;
+      m_videoBuffer.clear();
+    }
+    else if (!m_audioBuffer.empty())
+    {
+      buffer = m_audioBuffer;
+      streamType = STREAM_TYPE::AUDIO;
+      m_audioBuffer.clear();
+    }
+  }
+
+  return streamType != STREAM_TYPE::NONE;
+}
+
+void CGameClient::FlushDemux()
+{
+  CSingleLock lock(m_demuxMutex);
+
+  m_videoBuffer.clear();
+  m_audioBuffer.clear();
+}
+
+unsigned int CGameClient::RewindFrames(unsigned int frames)
+{
+  CSingleLock lock(m_critSection);
+
+  unsigned int rewound = 0;
+  if (m_bIsPlaying && m_bRewindEnabled)
+  {
+    rewound = m_serialState.RewindFrames(frames);
+    if (rewound != 0)
+    {
+      try { LogError(m_pStruct->Deserialize(m_serialState.GetState(), m_serialState.GetFrameSize()), "Deserialize()"); }
+      catch (...) { LogException("Deserialize()"); }
+    }
+  }
+  return rewound;
+}
+
+bool CGameClient::OpenPort(unsigned int port)
+{
+  ControllerVector controllers = GetControllers();
+  if (!controllers.empty())
+  {
+    // TODO: Choose controller
+    ControllerPtr& controller = controllers[0];
+
+    if (controller->LoadLayout())
+    {
+      ClosePort(port);
+
+      // Ensure port exists
+      if (port >= m_controllers.size())
+        m_controllers.resize(port + 1);
+
+      m_controllers[port] = new CGameClientInput(this, port, controller);
+
+      // If keyboard input is being captured by this add-on, force the port type to PERIPHERAL_JOYSTICK
+      PERIPHERALS::PeripheralType device = PERIPHERALS::PERIPHERAL_UNKNOWN;
+      if (m_bSupportsKeyboard)
+        device = PERIPHERALS::PERIPHERAL_JOYSTICK;
+
+      CPortManager::GetInstance().OpenPort(m_controllers[port], port, device);
+
+      UpdatePort(port, controllers[0]);
+
+      return true;
+    }
+  }
+
+  return false;
+}
+
+void CGameClient::ClosePort(unsigned int port)
+{
+  // Can't close port if it doesn't exist
+  if (port >= m_controllers.size())
+    return;
+
+  if (m_controllers[port] != NULL)
+  {
+    CPortManager::GetInstance().ClosePort(m_controllers[port]);
+
+    delete m_controllers[port];
+    m_controllers[port] = NULL;
+
+    UpdatePort(port, CController::EmptyPtr);
+  }
+}
+
+void CGameClient::UpdatePort(unsigned int port, const ControllerPtr& controller)
+{
+  if (controller != CController::EmptyPtr)
+  {
+    std::string strId = controller->ID();
+
+    game_controller controllerStruct;
+
+    controllerStruct.controller_id        = strId.c_str();
+    controllerStruct.digital_button_count = controller->Layout().FeatureCount(FEATURE_TYPE::SCALAR, INPUT_TYPE::DIGITAL);
+    controllerStruct.analog_button_count  = controller->Layout().FeatureCount(FEATURE_TYPE::SCALAR, INPUT_TYPE::ANALOG);
+    controllerStruct.analog_stick_count   = controller->Layout().FeatureCount(FEATURE_TYPE::ANALOG_STICK);
+    controllerStruct.accelerometer_count  = controller->Layout().FeatureCount(FEATURE_TYPE::ACCELEROMETER);
+    controllerStruct.key_count            = 0; // TODO
+    controllerStruct.rel_pointer_count    = 0; // TODO
+    controllerStruct.abs_pointer_count    = 0; // TODO
+
+    try { m_pStruct->UpdatePort(port, true, &controllerStruct); }
+    catch (...) { LogException("UpdatePort()"); }
+  }
+  else
+  {
+    try { m_pStruct->UpdatePort(port, false, NULL); }
+    catch (...) { LogException("UpdatePort()"); }
+  }
+}
+
+bool CGameClient::HasFeature(const std::string& controller, const std::string& feature)
+{
+  try { return m_pStruct->HasFeature(controller.c_str(), feature.c_str()); }
+  catch (...) { LogException("HasFeature()"); }
+
+  return false;
+}
+
+void CGameClient::ClearPorts(void)
+{
+  for (unsigned int i = 0; i < m_controllers.size(); i++)
+    ClosePort(i);
+}
+
+void CGameClient::OpenKeyboard(void)
+{
+  CInputManager::GetInstance().RegisterKeyboardHandler(this);
+}
+
+void CGameClient::CloseKeyboard(void)
+{
+  CInputManager::GetInstance().UnregisterKeyboardHandler(this);
+}
+
+ControllerVector CGameClient::GetControllers(void) const
+{
+  ControllerVector controllers;
+
+  const ADDONDEPS& dependencies = GetDeps();
+  for (ADDONDEPS::const_iterator it = dependencies.begin(); it != dependencies.end(); ++it)
+  {
+    AddonPtr addon;
+    if (CAddonMgr::GetInstance().GetAddon(it->first, addon, ADDON_GAME_CONTROLLER))
+    {
+      ControllerPtr controller = std::dynamic_pointer_cast<CController>(addon);
+      if (controller)
+        controllers.push_back(controller);
+    }
+  }
+
+  if (controllers.empty())
+  {
+    // Use the default controller
+    AddonPtr addon;
+    if (CAddonMgr::GetInstance().GetAddon(DEFAULT_CONTROLLER_ID, addon, ADDON_GAME_CONTROLLER))
+      controllers.push_back(std::static_pointer_cast<CController>(addon));
+  }
+
+  return controllers;
+}
+
+bool CGameClient::OnButtonPress(int port, const std::string& feature, bool bPressed)
+{
+  /* TODO
+  // Only allow activated input in fullscreen game
+  if (bPressed && g_windowManager.GetActiveWindowID() != WINDOW_FULLSCREEN_GAME)
+  {
+    CLog::Log(LOGDEBUG, "GameClient: button press ignored, not in fullscreen game");
+    return false;
+  }
+  */
+
+  std::string strControllerId = m_controllers[port]->ControllerID();
+
+  bool bHandled = false;
+
+  game_input_event event;
+
+  event.type                   = GAME_INPUT_EVENT_DIGITAL_BUTTON;
+  event.port                   = port;
+  event.controller_id          = strControllerId.c_str();
+  event.feature_name           = feature.c_str();
+  event.digital_button.pressed = bPressed;
+
+  try { bHandled = m_pStruct->InputEvent(port, &event); }
+  catch (...) { LogException("InputEvent()"); }
+
+  return bHandled;
+}
+
+bool CGameClient::OnButtonMotion(int port, const std::string& feature, float magnitude)
+{
+  /* TODO
+  // Only allow activated input in fullscreen game
+  if (magnitude && g_windowManager.GetActiveWindowID() != WINDOW_FULLSCREEN_GAME)
+    return false;
+  */
+
+  std::string strControllerId = m_controllers[port]->ControllerID();
+
+  bool bHandled = false;
+
+  game_input_event event;
+
+  event.type                    = GAME_INPUT_EVENT_ANALOG_BUTTON;
+  event.port                    = port;
+  event.controller_id           = strControllerId.c_str();
+  event.feature_name            = feature.c_str();
+  event.analog_button.magnitude = magnitude;
+
+  try { bHandled = m_pStruct->InputEvent(port, &event); }
+  catch (...) { LogException("InputEvent()"); }
+
+  return bHandled;
+}
+
+bool CGameClient::OnAnalogStickMotion(int port, const std::string& feature, float x, float y)
+{
+  /* TODO
+  // Only allow activated input in fullscreen game
+  if ((x || y) && g_windowManager.GetActiveWindowID() != WINDOW_FULLSCREEN_GAME)
+    return false;
+  */
+
+  std::string strControllerId = m_controllers[port]->ControllerID();
+
+  bool bHandled = false;
+
+  game_input_event event;
+
+  event.type           = GAME_INPUT_EVENT_ANALOG_STICK;
+  event.port           = port;
+  event.controller_id  = strControllerId.c_str();
+  event.feature_name   = feature.c_str();
+  event.analog_stick.x = x;
+  event.analog_stick.y = y;
+
+  try { bHandled = m_pStruct->InputEvent(port, &event); }
+  catch (...) { LogException("InputEvent()"); }
+
+  return bHandled;
+}
+
+bool CGameClient::OnAccelerometerMotion(int port, const std::string& feature, float x, float y, float z)
+{
+  /* TODO
+  // Only allow activated input in fullscreen game
+  if ((x || y || z) && g_windowManager.GetActiveWindowID() != WINDOW_FULLSCREEN_GAME)
+    return false;
+  */
+
+  std::string strControllerId = m_controllers[port]->ControllerID();
+
+  bool bHandled = false;
+
+  game_input_event event;
+
+  event.type            = GAME_INPUT_EVENT_ACCELEROMETER;
+  event.port            = port;
+  event.controller_id   = strControllerId.c_str();
+  event.feature_name    = feature.c_str();
+  event.accelerometer.x = x;
+  event.accelerometer.y = y;
+  event.accelerometer.z = z;
+
+  try { bHandled = m_pStruct->InputEvent(port, &event); }
+  catch (...) { LogException("InputEvent()"); }
+
+  return bHandled;
+}
+
+bool CGameClient::OnKeyPress(const CKey& key)
+{
+  /* TODO
+  // Only allow activated input in fullscreen game
+  if (g_windowManager.GetActiveWindowID() != WINDOW_FULLSCREEN_GAME)
+  {
+    CLog::Log(LOGDEBUG, "GameClient: key press ignored, not in fullscreen game");
+    return false;
+  }
+  */
+
+  bool bHandled = false;
+
+  game_input_event event;
+
+  event.type            = GAME_INPUT_EVENT_KEY;
+  event.port            = 0;
+  event.controller_id   = ""; // TODO
+  event.feature_name    = ""; // TODO
+  event.key.pressed     = true;
+  event.key.character   = key.GetButtonCode() & BUTTON_INDEX_MASK;
+  event.key.modifiers   = GetModifiers(static_cast<CKey::Modifier>(key.GetModifiers()));
+
+  if (event.key.character != 0)
+  {
+    try { bHandled = m_pStruct->InputEvent(0, &event); }
+    catch (...) { LogException("InputEvent()"); }
+  }
+
+  return bHandled;
+}
+
+void CGameClient::OnKeyRelease(const CKey& key)
+{
+  game_input_event event;
+
+  event.type            = GAME_INPUT_EVENT_KEY;
+  event.port            = 0;
+  event.controller_id   = ""; // TODO
+  event.feature_name    = ""; // TODO
+  event.key.pressed     = false;
+  event.key.character   = key.GetButtonCode() & BUTTON_INDEX_MASK;
+  event.key.modifiers   = GetModifiers(static_cast<CKey::Modifier>(key.GetModifiers()));
+
+  if (event.key.character != 0)
+  {
+    try { m_pStruct->InputEvent(0, &event); }
+    catch (...) { LogException("InputEvent()"); }
+  }
+}
+
+bool CGameClient::IsExtensionValid(const std::string& strExtension) const
+{
+  if (strExtension.empty())
+    return false;
+
+  if (m_extensions.empty())
+    return false; // Game client didn't provide any extensions
+
+  if (m_extensions.find(EXTENSION_WILDCARD) != m_extensions.end())
+    return true; // Game client accepts all extensions
+
+  return m_extensions.find(NormalizeExtension(strExtension)) != m_extensions.end();
+}
+
+std::vector<std::string> CGameClient::ParseExtensions(const std::string& strExtensionList)
+{
+  std::vector<std::string> extensions = StringUtils::Split(strExtensionList, EXTENSION_SEPARATOR);
+
+  std::transform(extensions.begin(), extensions.end(), extensions.begin(), NormalizeExtension);
+
+  return extensions;
+}
+
+/*
+void CGameClient::SetPlatforms(const string& strPlatformList)
+{
+  m_platforms.clear();
+
+  vector<string> platforms = StringUtils::Split(strPlatformList, EXTENSION_SEPARATOR);
+  for (vector<string>::iterator it = platforms.begin(); it != platforms.end(); it++)
+  {
+    StringUtils::Trim(*it);
+    GamePlatform id = CGameInfoTagLoader::GetPlatformInfoByName(*it).id;
+    if (id != PLATFORM_UNKNOWN)
+      m_platforms.insert(id);
+  }
+}
+*/
+
+GAME_KEY_MOD CGameClient::GetModifiers(CKey::Modifier modifier)
+{
+  unsigned int mods = GAME_KEY_MOD_NONE;
+
+  if (modifier & CKey::MODIFIER_CTRL)  mods = mods | GAME_KEY_MOD_CTRL;
+  if (modifier & CKey::MODIFIER_SHIFT) mods = mods | GAME_KEY_MOD_SHIFT;
+  if (modifier & CKey::MODIFIER_ALT)   mods = mods | GAME_KEY_MOD_ALT;
+  if (modifier & CKey::MODIFIER_RALT)  mods = mods | GAME_KEY_MOD_RALT;
+  if (modifier & CKey::MODIFIER_META)  mods = mods | GAME_KEY_MOD_META;
+
+  return static_cast<GAME_KEY_MOD>(mods);
+}
+
+bool CGameClient::LogError(GAME_ERROR error, const char* strMethod) const
+{
+  if (error != GAME_ERROR_NO_ERROR)
+  {
+    CLog::Log(LOGERROR, "GAME - %s - addon '%s' returned an error: %s",
+        strMethod, ID().c_str(), ToString(error));
+    return false;
+  }
+  return true;
+}
+
+void CGameClient::LogException(const char* strFunctionName) const
+{
+  CLog::Log(LOGERROR, "GAME: exception caught while trying to call '%s' on add-on %s",
+      strFunctionName, ID().c_str());
+  CLog::Log(LOGERROR, "Please contact the developer of this add-on: %s", Author().c_str());
+}
+
+void CGameClient::LogAddonProperties(void) const
+{
+  std::vector<std::string> vecExtensions(m_extensions.begin(), m_extensions.end());
+
+  CLog::Log(LOGINFO, "GAME: ------------------------------------");
+  CLog::Log(LOGINFO, "GAME: Loaded DLL for %s", ID().c_str());
+  CLog::Log(LOGINFO, "GAME: Client: %s at version %s", Name().c_str(), Version().asString().c_str());
+  CLog::Log(LOGINFO, "GAME: Valid extensions: %s", StringUtils::Join(vecExtensions, " ").c_str());
+  CLog::Log(LOGINFO, "GAME: Supports VFS: %s", m_bSupportsVFS ? "yes" : "no");
+  CLog::Log(LOGINFO, "GAME: Supports standalone execution: %s", m_bSupportsStandalone ? "yes" : "no");
+  CLog::Log(LOGINFO, "GAME: ------------------------------------");
+}
+
+const char* CGameClient::ToString(GAME_ERROR error)
+{
+  switch (error)
+  {
+    case GAME_ERROR_NO_ERROR:
+      return "no error";
+    case GAME_ERROR_NOT_IMPLEMENTED:
+      return "not implemented";
+    case GAME_ERROR_REJECTED:
+      return "rejected by the client";
+    case GAME_ERROR_INVALID_PARAMETERS:
+      return "invalid parameters for this method";
+    case GAME_ERROR_FAILED:
+      return "the command failed";
+    case GAME_ERROR_UNKNOWN:
+    default:
+      return "unknown error";
+  }
+}
diff --git a/xbmc/games/addons/GameClient.h b/xbmc/games/addons/GameClient.h
new file mode 100644
index 0000000..42aef89
--- /dev/null
+++ b/xbmc/games/addons/GameClient.h
@@ -0,0 +1,241 @@
+/*
+ *      Copyright (C) 2012-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+/*
+ * Adding new functions and callbacks to the XBMC Game API
+ *
+ * The Game API is spread out across various files. Adding new functions and
+ * callbacks is an adventure that spans many layers of abstraction. Necessary
+ * steps can easily be omitted, so the process of adding functions and
+ * callbacks is documented here.
+ *
+ * The Game API is layed out in three files:
+ *   - kodi_game_dll.h        (API function declarations)
+ *   - kodi_game_callbacks.h  (API callback pointers)
+ *   - kodi_game_types.h      (API enums and structs)
+ *
+ * To add a new API function:
+ *   1.  Declare the function in kodi_game_dll.h with some helpful documentation
+ *   2.  Assign the function pointer in get_addon() of the same file. get_addon()
+ *       (aliased to GetAddon()) is called in AddonDll.h immediately after
+ *       loading the shared library.
+ *   3.  Add the function to the GameClient struct in kodi_game_types.h. This
+ *       struct contains pointers to all the API functions. It is populated in
+ *       get_addon(). CGameClient invokes API functions through this struct.
+ *   4.  Define the function in the cpp file of the game client project
+ *
+ * To add a new API callback:
+ *   1.  Declare the callback as a function pointer in the CB_GameLib struct of
+ *       kodi_game_callbacks.h with some helpful documentation. The first
+ *       parameter, addonData, is the CAddonCallbacksGame object associated with
+ *       the game client instance.
+ *   2.  Declare the callback as a static member function of CAddonCallbacksGame
+ *   3.  Define the function in AddonCallbacksGame.cpp and assign the callback
+ *       to the callbacks table in the constructor.
+ *   4.  Expose the function to the game client in libKODI_game.cpp. This shared
+ *       library allows for ABI compatibility if the API is unchanged across
+ *       releases.
+ *   5.  Add the callback to the helper class in libKODI_game.h. Requires three
+ *       modifications: register the symbol exported from the shared library,
+ *       expose the callback using a member function wrapper, and declare the
+ *       function pointer as a protected member variable.
+ */
+
+#include "GameClientProperties.h"
+#include "addons/Addon.h"
+#include "addons/AddonDll.h"
+#include "addons/DllGameClient.h"
+#include "games/controllers/ControllerTypes.h"
+#include "games/GameTypes.h"
+#include "games/SerialState.h"
+#include "input/keyboard/IKeyboardHandler.h"
+#include "input/Key.h"
+#include "peripherals/EventScanRate.h"
+#include "threads/CriticalSection.h"
+
+#include "libavcodec/avcodec.h"
+#include "libavutil/pixfmt.h"
+
+#include <map>
+#include <set>
+#include <string>
+#include <vector>
+
+class CAEChannelInfo;
+class CFileItem;
+
+namespace GAME
+{
+
+class CGameClientInput;
+
+class IGameDemuxCallback
+{
+public:
+  virtual ~IGameDemuxCallback() { }
+
+  virtual void OpenVideoStream(AVCodecID codec, AVPixelFormat pixfmt, unsigned int width, unsigned int height) = 0;
+  virtual void CloseVideoStream() = 0;
+  virtual void OpenAudioStream(AVCodecID codec, unsigned int samplerate, const CAEChannelInfo& channelLayout) = 0;
+  virtual void CloseAudioStream() = 0;
+};
+
+class CGameClient : public ADDON::CAddonDll<DllGameClient, GameClient, game_client_properties>,
+                    public KEYBOARD::IKeyboardHandler
+{
+public:
+  enum class STREAM_TYPE
+  {
+    NONE,
+    VIDEO,
+    AUDIO,
+  };
+
+  static std::unique_ptr<CGameClient> FromExtension(ADDON::AddonProps props, const cp_extension_t* ext);
+
+  CGameClient(ADDON::AddonProps props, const std::vector<std::string>& extensions, bool bSupportsVFS, bool bSupportsStandalone, bool bSupportsDirectory, bool bSupportsKeyboard);
+
+  virtual ~CGameClient(void);
+
+  bool Initialize(void);
+
+  // Implementation of IAddon via CAddonDll
+  virtual bool              IsType(ADDON::TYPE type) const override { return type == ADDON::ADDON_GAME; }
+  virtual const std::string LibPath() const override;
+  virtual void              OnDisabled() override;
+  virtual void              OnEnabled() override;
+  virtual ADDON::AddonPtr   GetRunningInstance() const override;
+
+  // Query properties of the game client
+  const std::set<std::string>& GetExtensions() const    { return m_extensions; }
+  bool                         SupportsVFS() const      { return m_bSupportsVFS; }
+  //const GamePlatforms&         GetPlatforms() const     { return m_platforms; }
+  bool                         IsExtensionValid(const std::string& strExtension) const;
+  bool                         IsStandalone() const { return m_bSupportsStandalone; }
+
+  // Query properties of the running game
+  bool               IsPlaying() const     { return m_bIsPlaying; }
+  const std::string& GetFilePath() const   { return m_filePath; }
+  GAME_REGION        GetRegion() const     { return m_region; }
+
+  bool CanOpen(const CFileItem& file) const;
+  bool CanOpenFile(std::string strPath) const;
+  bool CanOpenDirectory(std::string strPath) const;
+  std::string ResolvePath(const CFileItem& file) const;
+  bool ResolveDirectory(const std::string& strPath, CFileItemList& files) const;
+  bool GetDirectory(std::string strPath, CFileItemList& files, CFileItemList& directories) const;
+
+  // Game API functions
+  bool OpenFile(const CFileItem& file, IGameDemuxCallback* demuxer);
+  void Reset();
+  void CloseFile();
+  bool OpenVideoStream(AVCodecID codec, AVPixelFormat pixelFormat, unsigned int width, unsigned int height);
+  void AddVideoData(const uint8_t* data, unsigned int size);
+  void CloseVideoStream();
+  bool OpenAudioStream(AVCodecID codec, unsigned int samplerate, const CAEChannelInfo& channelLayout);
+  void AddAudioData(const uint8_t* data, unsigned int size);
+  void CloseAudioStream();
+  bool ReadDemux(std::vector<uint8_t>& buffer, STREAM_TYPE& streamType);
+  void FlushDemux();
+
+  unsigned int RewindFrames(unsigned int frames); // Returns number of frames rewound
+  size_t GetAvailableFrames() const { return m_bRewindEnabled ? m_serialState.GetFramesAvailable() : 0; }
+  size_t GetMaxFrames() const { return m_bRewindEnabled ? m_serialState.GetMaxFrames() : 0; }
+
+  bool OpenPort(unsigned int port);
+  void ClosePort(unsigned int port);
+  void UpdatePort(unsigned int port, const ControllerPtr& controller);
+  bool HasFeature(const std::string& controller, const std::string& feature);
+
+  bool OnButtonPress(int port, const std::string& feature, bool bPressed);
+  bool OnButtonMotion(int port, const std::string& feature, float magnitude);
+  bool OnAnalogStickMotion(int port, const std::string& feature, float x, float y);
+  bool OnAccelerometerMotion(int port, const std::string& feature, float x, float y, float z);
+
+  // implementation of IKeyboardHandler
+  virtual bool OnKeyPress(const CKey& key) override;
+  virtual void OnKeyRelease(const CKey& key) override;
+
+private:
+  // Called by the constructors
+  void InitializeProperties(void);
+
+  // Private Game API functions
+  bool LoadGameInfo();
+  bool InitSerialization();
+
+  void ClearPorts(void);
+  void OpenKeyboard(void);
+  void CloseKeyboard(void);
+  ControllerVector GetControllers(void) const;
+
+  // Helper functions
+  static std::string ToArchivePath(const std::string& strPath);
+  static std::vector<std::string> ParseExtensions(const std::string& strExtensionList);
+  //void SetPlatforms(const std::string& strPlatformList);
+  static GAME_KEY_MOD GetModifiers(CKey::Modifier modifier);
+  bool LogError(GAME_ERROR error, const char* strMethod) const;
+  void LogException(const char* strFunctionName) const;
+  void LogAddonProperties(void) const; // Unused currently
+  static const char* ToString(GAME_ERROR error);
+
+  ADDON::AddonVersion   m_apiVersion;
+  CGameClientProperties m_libraryProps;        // Properties to pass to the DLL
+
+  // Game API xml parameters
+  std::set<std::string> m_extensions;
+  bool                  m_bSupportsVFS;
+  bool                  m_bSupportsStandalone;
+  bool                  m_bSupportsDirectory;
+  bool                  m_bSupportsKeyboard;
+  //GamePlatforms         m_platforms;
+
+  // Properties of the current playing file
+  bool                  m_bIsPlaying;          // This is true between OpenFile() and CloseFile()
+  std::string           m_filePath;            // The current playing file
+  IGameDemuxCallback*   m_demuxer;             // The demuxer passed to OpenFile()
+  PERIPHERALS::EventRateHandle m_inputRateHandle; // Handle while keeping the input sampling rate at the frame rate
+  GAME_REGION           m_region;              // Region of the loaded game
+  double                m_frameRate;           // Video framerate
+  double                m_sampleRate;          // Audio frequency
+
+  // Video/audio streams
+  bool                  m_bHasVideo;           // True if a video stream is open
+  bool                  m_bHasRawVideo;        // True if video stream is raw pixels, false for encoded data
+  bool                  m_bHasAudio;           // True if an audio stream is open
+  std::vector<uint8_t>  m_videoBuffer;
+  std::vector<uint8_t>  m_audioBuffer;
+  CCriticalSection      m_demuxMutex;
+  CEvent                m_demuxEvent;
+
+  // Save/rewind functionality
+  bool                  m_bSerializationInited;
+  unsigned int          m_serializeSize;
+  bool                  m_bRewindEnabled;
+  CSerialState          m_serialState;
+
+  // Input
+  std::vector<CGameClientInput*> m_controllers;
+
+  CCriticalSection      m_critSection;
+};
+
+} // namespace GAME
diff --git a/xbmc/games/addons/GameClientInput.cpp b/xbmc/games/addons/GameClientInput.cpp
new file mode 100644
index 0000000..bd97bf1
--- /dev/null
+++ b/xbmc/games/addons/GameClientInput.cpp
@@ -0,0 +1,80 @@
+/*
+ *      Copyright (C) 2015-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "GameClientInput.h"
+#include "GameClient.h"
+#include "games/controllers/Controller.h"
+
+#include <algorithm>
+#include <assert.h>
+
+using namespace GAME;
+
+CGameClientInput::CGameClientInput(CGameClient* addon, int port, const ControllerPtr& controller) :
+  m_addon(addon),
+  m_port(port),
+  m_controller(controller)
+{
+  assert(m_addon != NULL);
+  assert(controller.get() != NULL);
+}
+
+std::string CGameClientInput::ControllerID(void) const
+{
+  return m_controller->ID();
+}
+
+bool CGameClientInput::HasFeature(const std::string& feature) const
+{
+  return m_addon->HasFeature(m_controller->ID(), feature);
+}
+
+JOYSTICK::INPUT_TYPE CGameClientInput::GetInputType(const std::string& feature) const
+{
+  const std::vector<CControllerFeature>& features = m_controller->Layout().Features();
+
+  for (std::vector<CControllerFeature>::const_iterator it = features.begin(); it != features.end(); ++it)
+  {
+    if (feature == it->Name())
+      return it->InputType();
+  }
+
+  return JOYSTICK::INPUT_TYPE::UNKNOWN;
+}
+
+bool CGameClientInput::OnButtonPress(const std::string& feature, bool bPressed)
+{
+  return m_addon->OnButtonPress(m_port, feature, bPressed);
+}
+
+bool CGameClientInput::OnButtonMotion(const std::string& feature, float magnitude)
+{
+  return m_addon->OnButtonMotion(m_port, feature, magnitude);
+}
+
+bool CGameClientInput::OnAnalogStickMotion(const std::string& feature, float x, float y)
+{
+  return m_addon->OnAnalogStickMotion(m_port, feature, x, y);
+}
+
+bool CGameClientInput::OnAccelerometerMotion(const std::string& feature, float x, float y, float z)
+{
+  return m_addon->OnAccelerometerMotion(m_port, feature, x, y, z);
+}
diff --git a/xbmc/games/addons/GameClientInput.h b/xbmc/games/addons/GameClientInput.h
new file mode 100644
index 0000000..e3fbe78
--- /dev/null
+++ b/xbmc/games/addons/GameClientInput.h
@@ -0,0 +1,50 @@
+/*
+ *      Copyright (C) 2015-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+#include "games/controllers/ControllerTypes.h"
+#include "input/joysticks/IInputHandler.h"
+
+namespace GAME
+{
+  class CGameClient;
+
+  class CGameClientInput : public JOYSTICK::IInputHandler
+  {
+  public:
+    CGameClientInput(CGameClient* addon, int port, const ControllerPtr& controller);
+
+    // Implementation of IJoystickInputHandler
+    virtual std::string ControllerID(void) const override;
+    virtual bool HasFeature(const std::string& feature) const override;
+    virtual JOYSTICK::INPUT_TYPE GetInputType(const std::string& feature) const override;
+    virtual bool OnButtonPress(const std::string& feature, bool bPressed) override;
+    virtual bool OnButtonMotion(const std::string& feature, float magnitude) override;
+    virtual bool OnAnalogStickMotion(const std::string& feature, float x, float y) override;
+    virtual bool OnAccelerometerMotion(const std::string& feature, float x, float y, float z) override;
+
+    //const ControllerPtr& Controller(void) const { return m_controller; }
+
+  private:
+    CGameClient* const  m_addon;
+    const int           m_port;
+    const ControllerPtr m_controller;
+  };
+}
diff --git a/xbmc/games/addons/GameClientProperties.cpp b/xbmc/games/addons/GameClientProperties.cpp
new file mode 100644
index 0000000..5d530a7
--- /dev/null
+++ b/xbmc/games/addons/GameClientProperties.cpp
@@ -0,0 +1,145 @@
+/*
+ *      Copyright (C) 2012-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "GameClientProperties.h"
+#include "GameClient.h"
+#include "addons/IAddon.h"
+#include "addons/AddonManager.h"
+#include "filesystem/Directory.h"
+#include "filesystem/SpecialProtocol.h"
+#include "settings/Settings.h"
+
+#include <cstring>
+
+using namespace ADDON;
+using namespace GAME;
+using namespace XFILE;
+
+#define GAME_CLIENT_SAVE_DIRECTORY    "save"
+#define GAME_CLIENT_SYSTEM_DIRECTORY  "system"
+
+CGameClientProperties::CGameClientProperties(const CGameClient* parent, game_client_properties*& props)
+  : m_parent(parent),
+    m_properties()
+{
+  // Allow the caller to access the property structure directly
+  props = &m_properties;
+}
+
+void CGameClientProperties::ReleaseResources(void)
+{
+  for (std::vector<char*>::const_iterator it = m_proxyDllPaths.begin(); it != m_proxyDllPaths.end(); ++it)
+    delete[] *it;
+  m_proxyDllPaths.clear();
+}
+
+void CGameClientProperties::InitializeProperties(void)
+{
+  ReleaseResources();
+
+  m_properties.game_client_dll_path = GetLibraryPath();
+  m_properties.proxy_dll_paths      = GetProxyDllPaths();
+  m_properties.proxy_dll_count      = GetProxyDllCount();
+  m_properties.system_directory     = GetSystemDirectory();
+  m_properties.content_directory    = GetContentDirectory();
+  m_properties.save_directory       = GetSaveDirectory();
+}
+
+const char* CGameClientProperties::GetLibraryPath(void)
+{
+  if (m_strLibraryPath.empty())
+  {
+    // Get the parent add-on's real path
+    std::string strLibPath = dynamic_cast<const CGameClient*>(m_parent)->CAddon::LibPath();
+    m_strLibraryPath = CSpecialProtocol::TranslatePath(strLibPath);
+  }
+  return m_strLibraryPath.c_str();
+}
+
+const char** CGameClientProperties::GetProxyDllPaths(void)
+{
+  // Add all game client dependencies
+  // TODO: Compare helper version with required dependency
+  const ADDONDEPS& dependencies = m_parent->GetDeps();
+  for (ADDONDEPS::const_iterator it = dependencies.begin(); it != dependencies.end(); ++it)
+    AddProxyDll(it->first);
+
+  return !m_proxyDllPaths.empty() ? const_cast<const char**>(m_proxyDllPaths.data()) : NULL;
+}
+
+const char* CGameClientProperties::GetSystemDirectory(void)
+{
+  if (m_strSystemDirectory.empty())
+  {
+    m_strSystemDirectory = CSpecialProtocol::TranslatePath(URIUtils::AddFileToFolder(m_parent->Profile(), GAME_CLIENT_SYSTEM_DIRECTORY));
+    if (!CDirectory::Exists(m_strSystemDirectory))
+      CDirectory::Create(m_strSystemDirectory);
+  }
+  return m_strSystemDirectory.c_str();
+}
+
+const char* CGameClientProperties::GetContentDirectory(void)
+{
+  if (m_strContentDirectory.empty())
+    m_strContentDirectory = CSpecialProtocol::TranslatePath(m_parent->Path());
+  return m_strContentDirectory.c_str();
+}
+
+const char* CGameClientProperties::GetSaveDirectory(void)
+{
+  if (m_strSaveDirectory.empty())
+  {
+    m_strSaveDirectory = CSpecialProtocol::TranslatePath(URIUtils::AddFileToFolder(m_parent->Profile(), GAME_CLIENT_SAVE_DIRECTORY));
+    if (!CDirectory::Exists(m_strSaveDirectory))
+      CDirectory::Create(m_strSaveDirectory);
+  }
+  return m_strSaveDirectory.c_str();
+}
+
+bool CGameClientProperties::AddProxyDll(const std::string& strAddonId)
+{
+  // Ignore add-on if it isn't a game client
+  AddonPtr addon;
+  if (CAddonMgr::GetInstance().GetAddon(strAddonId, addon, ADDON_GAMEDLL) && addon)
+  {
+    // Get the add-on's real path
+    std::string strLibPath = dynamic_cast<const CGameClient*>(addon.get())->CAddon::LibPath();
+
+    // Ignore add-on if it is already added
+    if (!HasProxyDll(strLibPath))
+    {
+      char* libPath = new char[strLibPath.length() + 1];
+      std::strcpy(libPath, strLibPath.c_str());
+      m_proxyDllPaths.push_back(libPath);
+      return true;
+    }
+  }
+  return false;
+}
+
+bool CGameClientProperties::HasProxyDll(const std::string& strLibPath) const
+{
+  for (std::vector<char*>::const_iterator it = m_proxyDllPaths.begin(); it != m_proxyDllPaths.end(); ++it)
+  {
+    if (strLibPath == *it)
+      return true;
+  }
+  return false;
+}
diff --git a/xbmc/games/addons/GameClientProperties.h b/xbmc/games/addons/GameClientProperties.h
new file mode 100644
index 0000000..45b7382
--- /dev/null
+++ b/xbmc/games/addons/GameClientProperties.h
@@ -0,0 +1,83 @@
+/*
+ *      Copyright (C) 2012-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+#include "addons/kodi-addon-dev-kit/include/kodi/kodi_game_types.h"
+
+#include <string>
+#include <vector>
+
+struct game_client_properties;
+
+namespace GAME
+{
+
+class CGameClient;
+
+/**
+ * \brief Wrapper for game client properties declared in kodi_game_types.h
+ */
+class CGameClientProperties
+{
+public:
+  CGameClientProperties(const CGameClient* parent, game_client_properties*& props);
+  ~CGameClientProperties(void) { ReleaseResources(); }
+
+  void InitializeProperties(void);
+
+private:
+  // Release mutable resources
+  void ReleaseResources(void);
+
+  // Equal to parent's real library path
+  const char* GetLibraryPath(void);
+
+  // List of proxy DLLs needed to load the game client
+  const char** GetProxyDllPaths(void);
+
+  // Number of proxy DLLs needed to load the game client
+  unsigned int GetProxyDllCount(void) const { return m_proxyDllPaths.size(); }
+
+  // Equal to special://profile/addon_data/<parent's id>/system
+  const char* GetSystemDirectory(void);
+
+  // Equal to parent's add-on path
+  const char* GetContentDirectory(void);
+
+  // Equal to special://profile/addon_data/<parent's id>/save
+  const char* GetSaveDirectory(void);
+
+  // Helper functions
+  bool AddProxyDll(const std::string& strLibPath);
+  bool HasProxyDll(const std::string& strLibPath) const;
+
+  const CGameClient* const  m_parent;
+  game_client_properties    m_properties;
+
+  // Buffers to hold the strings
+  std::string        m_strLibraryPath;      // immutable
+  std::vector<char*> m_proxyDllPaths;       // mutable
+  std::string        m_strNetplayServer;    // immutable
+  std::string        m_strSystemDirectory;  // immutable
+  std::string        m_strContentDirectory; // immutable
+  std::string        m_strSaveDirectory;    // immutable
+};
+
+} // namespace GAME
diff --git a/xbmc/games/addons/Makefile b/xbmc/games/addons/Makefile
new file mode 100644
index 0000000..4864497
--- /dev/null
+++ b/xbmc/games/addons/Makefile
@@ -0,0 +1,8 @@
+SRCS=GameClient.cpp \
+     GameClientInput.cpp \
+     GameClientProperties.cpp \
+
+LIB=gameaddons.a
+
+include ../../../Makefile.include
+-include $(patsubst %.cpp,%.P,$(patsubst %.c,%.P,$(SRCS)))
diff --git a/xbmc/games/controllers/Controller.h b/xbmc/games/controllers/Controller.h
index 7b871cc..0160d32 100644
--- a/xbmc/games/controllers/Controller.h
+++ b/xbmc/games/controllers/Controller.h
@@ -39,6 +39,9 @@ public:
 
   static const ControllerPtr EmptyPtr;
 
+  // implementation of IAddon via CAddon
+  virtual bool IsType(ADDON::TYPE type) const override { return type == ADDON::ADDON_GAME; }
+
   std::string Label(void);
   std::string ImagePath(void) const;
   std::string OverlayPath(void) const;
diff --git a/xbmc/games/controllers/windows/GUIConfigurationWizard.cpp b/xbmc/games/controllers/windows/GUIConfigurationWizard.cpp
index b48986b..33f43b1 100644
--- a/xbmc/games/controllers/windows/GUIConfigurationWizard.cpp
+++ b/xbmc/games/controllers/windows/GUIConfigurationWizard.cpp
@@ -32,8 +32,10 @@ using namespace GAME;
 
 #define ESC_KEY_CODE  27
 
-CGUIConfigurationWizard::CGUIConfigurationWizard() :
-  CThread("GUIConfigurationWizard")
+CGUIConfigurationWizard::CGUIConfigurationWizard(bool bEmulation, unsigned int controllerNumber /* = 0 */) :
+  CThread("GUIConfigurationWizard"),
+  m_bEmulation(bEmulation),
+  m_controllerNumber(controllerNumber)
 {
   InitializeState();
 }
@@ -217,14 +219,19 @@ void CGUIConfigurationWizard::InstallHooks(void)
 
   g_peripherals.RegisterJoystickButtonMapper(this);
   g_peripherals.RegisterObserver(this);
-  CInputManager::GetInstance().RegisterKeyboardHandler(this);
+
+  // If we're not using emulation, allow keyboard input to abort prompt
+  if (!m_bEmulation)
+    CInputManager::GetInstance().RegisterKeyboardHandler(this);
 }
 
 void CGUIConfigurationWizard::RemoveHooks(void)
 {
   using namespace PERIPHERALS;
 
-  CInputManager::GetInstance().UnregisterKeyboardHandler(this);
+  if (!m_bEmulation)
+    CInputManager::GetInstance().UnregisterKeyboardHandler(this);
+
   g_peripherals.UnregisterObserver(this);
   g_peripherals.UnregisterJoystickButtonMapper(this);
 }
diff --git a/xbmc/games/controllers/windows/GUIConfigurationWizard.h b/xbmc/games/controllers/windows/GUIConfigurationWizard.h
index 1c924e4..a47004c 100644
--- a/xbmc/games/controllers/windows/GUIConfigurationWizard.h
+++ b/xbmc/games/controllers/windows/GUIConfigurationWizard.h
@@ -41,7 +41,7 @@ namespace GAME
                                   protected CThread
   {
   public:
-    CGUIConfigurationWizard();
+    CGUIConfigurationWizard(bool bEmulation, unsigned int controllerNumber = 0);
 
     virtual ~CGUIConfigurationWizard(void) { }
 
@@ -52,6 +52,8 @@ namespace GAME
 
     // implementation of IButtonMapper
     virtual std::string ControllerID(void) const override { return m_strControllerId; }
+    virtual bool Emulation(void) const override { return m_bEmulation; }
+    virtual unsigned int ControllerNumber(void) const override { return m_controllerNumber; }
     virtual bool MapPrimitive(JOYSTICK::IButtonMap* buttonMap, const JOYSTICK::CDriverPrimitive& primitive) override;
 
     // implementation of IKeyboardHandler
@@ -71,6 +73,10 @@ namespace GAME
     void InstallHooks(void);
     void RemoveHooks(void);
 
+    // Construction parameters
+    const bool                           m_bEmulation;
+    const unsigned int                   m_controllerNumber;
+
     // Run() parameters
     std::string                          m_strControllerId;
     std::vector<IFeatureButton*>         m_buttons;
diff --git a/xbmc/games/controllers/windows/GUIControllerWindow.cpp b/xbmc/games/controllers/windows/GUIControllerWindow.cpp
index 598caa8..ad583a2 100644
--- a/xbmc/games/controllers/windows/GUIControllerWindow.cpp
+++ b/xbmc/games/controllers/windows/GUIControllerWindow.cpp
@@ -62,8 +62,8 @@ bool CGUIControllerWindow::OnMessage(CGUIMessage& message)
   {
     case GUI_MSG_WINDOW_INIT:
     {
-      // TODO: Process parameter
-      //std::string strParam = message.GetStringParam();
+      // TODO: Process params here, don't just record them for later
+      m_param = message.GetStringParam();
       break;
     }
     case GUI_MSG_CLICKED:
@@ -151,7 +151,7 @@ void CGUIControllerWindow::OnInitWindow(void)
 
   if (!m_featureList)
   {
-    m_featureList = new CGUIFeatureList(this);
+    m_featureList = new CGUIFeatureList(this, m_param);
     if (!m_featureList->Initialize())
     {
       delete m_featureList;
diff --git a/xbmc/games/controllers/windows/GUIControllerWindow.h b/xbmc/games/controllers/windows/GUIControllerWindow.h
index ca8c442..7c9fe64 100644
--- a/xbmc/games/controllers/windows/GUIControllerWindow.h
+++ b/xbmc/games/controllers/windows/GUIControllerWindow.h
@@ -60,5 +60,6 @@ namespace GAME
 
     IControllerList* m_controllerList;
     IFeatureList*    m_featureList;
+    std::string      m_param; // First auxiliary parameter in call to ActivateWindow()
   };
 }
diff --git a/xbmc/games/controllers/windows/GUIFeatureList.cpp b/xbmc/games/controllers/windows/GUIFeatureList.cpp
index 862055b..85adc4d 100644
--- a/xbmc/games/controllers/windows/GUIFeatureList.cpp
+++ b/xbmc/games/controllers/windows/GUIFeatureList.cpp
@@ -30,12 +30,25 @@
 
 using namespace GAME;
 
-CGUIFeatureList::CGUIFeatureList(CGUIWindow* window) :
+CGUIFeatureList::CGUIFeatureList(CGUIWindow* window, const std::string& windowParam) :
   m_window(window),
   m_guiList(nullptr),
   m_guiButtonTemplate(nullptr),
-  m_wizard(new CGUIConfigurationWizard)
+  m_wizard(nullptr)
 {
+  if (windowParam.empty())
+  {
+    // Run wizard for all physical controllers
+    m_wizard = new CGUIConfigurationWizard(false);
+  }
+  else
+  {
+    // Run wizard for specified emulated controller
+    unsigned int number;
+    std::istringstream str(windowParam);
+    str >> number;
+    m_wizard = new CGUIConfigurationWizard(true, number);
+  }
 }
 
 CGUIFeatureList::~CGUIFeatureList(void)
diff --git a/xbmc/games/controllers/windows/GUIFeatureList.h b/xbmc/games/controllers/windows/GUIFeatureList.h
index eb4b890..e1b9275 100644
--- a/xbmc/games/controllers/windows/GUIFeatureList.h
+++ b/xbmc/games/controllers/windows/GUIFeatureList.h
@@ -32,7 +32,7 @@ namespace GAME
   class CGUIFeatureList : public IFeatureList
   {
   public:
-    CGUIFeatureList(CGUIWindow* window);
+    CGUIFeatureList(CGUIWindow* window, const std::string& windowParam);
     virtual ~CGUIFeatureList(void);
 
     // implementation of IFeatureList
diff --git a/xbmc/games/ports/Makefile b/xbmc/games/ports/Makefile
new file mode 100644
index 0000000..4f1829e
--- /dev/null
+++ b/xbmc/games/ports/Makefile
@@ -0,0 +1,7 @@
+SRCS=PortManager.cpp \
+     PortMapper.cpp \
+
+LIB=gameports.a
+
+include ../../../Makefile.include
+-include $(patsubst %.cpp,%.P,$(patsubst %.c,%.P,$(SRCS)))
diff --git a/xbmc/games/ports/PortManager.cpp b/xbmc/games/ports/PortManager.cpp
new file mode 100644
index 0000000..708a6e3
--- /dev/null
+++ b/xbmc/games/ports/PortManager.cpp
@@ -0,0 +1,199 @@
+/*
+ *      Copyright (C) 2015-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "PortManager.h"
+#include "peripherals/devices/PeripheralJoystick.h"
+#include "threads/SingleLock.h"
+
+#include <algorithm>
+
+using namespace GAME;
+
+CPortManager& CPortManager::GetInstance()
+{
+  static CPortManager instance;
+  return instance;
+}
+
+using namespace GAME;
+using namespace JOYSTICK;
+using namespace PERIPHERALS;
+
+void CPortManager::OpenPort(IInputHandler* handler, unsigned int port,
+                            PERIPHERALS::PeripheralType device /* = PERIPHERALS::PERIPHERAL_UNKNOWN) */)
+{
+  CSingleLock lock(m_mutex);
+
+  SPort newPort;
+  newPort.handler = handler;
+  newPort.port = port;
+  newPort.type = device;
+  m_ports.push_back(newPort);
+
+  SetChanged();
+  NotifyObservers(ObservableMessagePortsChanged);
+}
+
+void CPortManager::ClosePort(IInputHandler* handler)
+{
+  CSingleLock lock(m_mutex);
+
+  m_ports.erase(std::remove_if(m_ports.begin(), m_ports.end(), PortInputHandlerEqual(handler)), m_ports.end());
+
+  SetChanged();
+  NotifyObservers(ObservableMessagePortsChanged);
+}
+
+void CPortManager::MapDevices(const std::vector<CPeripheral*>& devices,
+                              std::map<CPeripheral*, IInputHandler*>& deviceToPortMap)
+{
+  CSingleLock lock(m_mutex);
+
+  if (m_ports.empty())
+    return; // Nothing to do
+
+  // Force the keyboard to disconnect so that joysticks get priority
+  for (std::vector<CPeripheral*>::const_iterator itDevice = devices.begin(); itDevice != devices.end(); ++itDevice)
+  {
+    if ((*itDevice)->Type() == PERIPHERAL_JOYSTICK_EMULATION)
+    {
+      const CPeripheral* keyboard = *itDevice;
+      for (std::vector<SPort>::iterator itPort = m_ports.begin(); itPort != m_ports.end(); ++itPort)
+      {
+        std::vector<SDevice>& portDevices = itPort->devices;
+        portDevices.erase(std::remove_if(portDevices.begin(), portDevices.end(),
+          [keyboard](const SDevice& portDevice)
+          {
+            return portDevice.device == keyboard;
+          }), portDevices.end());
+      }
+    }
+  }
+
+  // Look for connected/removed devices
+  for (std::vector<SPort>::iterator itPort = m_ports.begin(); itPort != m_ports.end(); ++itPort)
+  {
+    for (std::vector<SDevice>::iterator itPortDevice = itPort->devices.begin(); itPortDevice != itPort->devices.end(); ++itPortDevice)
+    {
+      if (std::find(devices.begin(), devices.end(), itPortDevice->device) != devices.end())
+      {
+        itPortDevice->bConnected = true;
+        deviceToPortMap[static_cast<CPeripheral*>(itPortDevice->device)] = itPort->handler;
+      }
+      else
+      {
+        itPortDevice->bConnected = false;
+      }
+    }
+  }
+
+  // Look for new devices
+  std::vector<PERIPHERALS::CPeripheral*> newDevices;
+  for (std::vector<CPeripheral*>::const_iterator itDevice = devices.begin(); itDevice != devices.end(); ++itDevice)
+  {
+    const CPeripheral* device = *itDevice;
+
+    bool bFound = false;
+
+    for (std::vector<SPort>::const_iterator itPort = m_ports.begin(); itPort != m_ports.end(); ++itPort)
+    {
+      bFound = std::count_if(itPort->devices.begin(), itPort->devices.end(),
+        [device](const SDevice& portDevice)
+        {
+          return portDevice.device == device;
+        }) > 0;
+
+      if (bFound)
+        break;
+    }
+
+    if (!bFound)
+      newDevices.push_back(*itDevice);
+  }
+
+  // Add new devices to disconnected ports
+  for (std::vector<CPeripheral*>::const_iterator itDevice = newDevices.begin(); itDevice != newDevices.end(); ++itDevice)
+  {
+    int targetPort = GetTargetPort(GetRequestedPort(*itDevice), (*itDevice)->Type());
+
+    if (targetPort >= 0)
+    {
+      SPort& port = m_ports[targetPort];
+
+      // Clear the port of all disconnected devices before adding this device
+      // except for keyboard (we expect the keyboard to hop around)
+      if ((*itDevice)->Type() != PERIPHERAL_JOYSTICK_EMULATION)
+      {
+        port.devices.erase(std::remove_if(port.devices.begin(), port.devices.end(),
+          [](const SDevice& portDevice)
+            {
+              return !portDevice.bConnected; 
+            }), port.devices.end());
+      }
+
+      SDevice portDevice = { *itDevice, true };
+      port.devices.push_back(portDevice);
+      deviceToPortMap[*itDevice] = m_ports[targetPort].handler;
+    }
+  }
+}
+
+int CPortManager::GetTargetPort(int requestedPort, PeripheralType deviceType) const
+{
+  for (unsigned int i = 0; i < m_ports.size(); i++)
+  {
+    // Check port number if port number was requested
+    const bool bPortRequested = (requestedPort != JOYSTICK_PORT_UNKNOWN);
+    if (bPortRequested && requestedPort != (int)m_ports[i].port)
+      continue;
+
+    // Check device type if port requires a specific device
+    const bool bRequiresDeviceType = (m_ports[i].type != PERIPHERAL_UNKNOWN);
+    if (bRequiresDeviceType && m_ports[i].type != deviceType)
+      continue;
+
+    unsigned int connectedDeviceCount = std::count_if(m_ports[i].devices.begin(), m_ports[i].devices.end(),
+      [](const SDevice& portDevice)
+      {
+        return portDevice.bConnected;
+      });
+
+    if (connectedDeviceCount > 0)
+      continue;
+
+    return i;
+  }
+
+  return -1;
+}
+
+int CPortManager::GetRequestedPort(const CPeripheral* device)
+{
+  int requestedPort = JOYSTICK_PORT_UNKNOWN;
+
+  if (device->Type() == PERIPHERAL_JOYSTICK)
+  {
+    const CPeripheralJoystick* joystick = static_cast<const CPeripheralJoystick*>(device);
+    if (joystick->RequestedPort() != JOYSTICK_PORT_UNKNOWN)
+      requestedPort = joystick->RequestedPort();
+  }
+
+  return requestedPort;
+}
diff --git a/xbmc/games/ports/PortManager.h b/xbmc/games/ports/PortManager.h
new file mode 100644
index 0000000..c30492b
--- /dev/null
+++ b/xbmc/games/ports/PortManager.h
@@ -0,0 +1,121 @@
+/*
+ *      Copyright (C) 2015-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+#include "peripherals/PeripheralTypes.h"
+#include "threads/CriticalSection.h"
+#include "utils/Observer.h"
+
+#include <map>
+#include <vector>
+
+namespace JOYSTICK { class IInputHandler; }
+namespace PERIPHERALS { class CPeripheral; }
+
+namespace GAME
+{
+  /*!
+   * \brief Class to manage ports opened by game clients
+   */
+  class CPortManager : public Observable
+  {
+  private:
+    CPortManager(void) { }
+
+  public:
+    static CPortManager& GetInstance();
+
+    /*!
+     * \brief Request a new port be opened with input on that port sent to the
+     *        specified handler.
+     *
+     * \param handler  The instance accepting all input delivered to the port
+     * \param port     The port number belonging to the game client
+     */
+    void OpenPort(JOYSTICK::IInputHandler* handler, unsigned int port,
+      PERIPHERALS::PeripheralType device = PERIPHERALS::PERIPHERAL_UNKNOWN);
+
+    /*!
+     * \brief Close an opened port
+     *
+     * \param handler  The handler used to open the port
+     */
+    void ClosePort(JOYSTICK::IInputHandler* handler);
+
+    /*!
+     * \brief Map a list of devices to the available ports
+     *
+     * \param devices  The devices capable of providing input to the ports
+     * \param portMap  The resulting map of devices to ports
+     *
+     * If there are more devices than open ports, multiple devices may be assigned
+     * to the same port. If a device requests a specific port, this function will
+     * attempt to honor that request.
+     */
+    void MapDevices(const std::vector<PERIPHERALS::CPeripheral*>& devices,
+      std::map<PERIPHERALS::CPeripheral*, JOYSTICK::IInputHandler*>& deviceToPortMap);
+
+  private:
+    struct SDevice
+    {
+      void* device;
+      bool  bConnected;
+    };
+
+    struct SPort
+    {
+      JOYSTICK::IInputHandler*    handler; // Input handler for this port
+      unsigned int                port;    // Port number belonging to the game client
+      PERIPHERALS::PeripheralType type;
+      std::vector<SDevice>        devices;
+    };
+
+    /*!
+     * \brief Functor to match ports against a specified input handler
+     */
+    struct PortInputHandlerEqual
+    {
+      PortInputHandlerEqual(JOYSTICK::IInputHandler* handler) : handler(handler) { }
+
+      bool operator()(const SPort& port) { return port.handler == handler; }
+
+      JOYSTICK::IInputHandler* const handler;
+    };
+
+    /*!
+     * \brief Helper function to find the next open port, round-robin fashion,
+     *        starting from the given port.
+     *
+     * A port is considered open if no other ports have a fewer number of devices
+     * connected.
+     */
+    int GetTargetPort(int requestedPort, PERIPHERALS::PeripheralType deviceType) const;
+
+    /*!
+     * \brief Helper function to get the device's requested port
+     * \param device If device is not a joystick, this returns JOYSTICK_PORT_UNKNOWN
+     * \return the requested port, or JOYSTICK_PORT_UNKNOWN if no port is requested
+     */
+    static int GetRequestedPort(const PERIPHERALS::CPeripheral* device);
+
+    std::vector<SPort> m_ports;
+    CCriticalSection   m_mutex;
+  };
+}
diff --git a/xbmc/games/ports/PortMapper.cpp b/xbmc/games/ports/PortMapper.cpp
new file mode 100644
index 0000000..e3df1e6
--- /dev/null
+++ b/xbmc/games/ports/PortMapper.cpp
@@ -0,0 +1,86 @@
+/*
+ *      Copyright (C) 2015-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "PortMapper.h"
+#include "PortManager.h"
+#include "peripherals/devices/Peripheral.h"
+#include "peripherals/Peripherals.h"
+
+using namespace GAME;
+using namespace JOYSTICK;
+using namespace PERIPHERALS;
+
+CPortMapper::CPortMapper()
+{
+  CPortManager::GetInstance().RegisterObserver(this);
+}
+
+CPortMapper::~CPortMapper()
+{
+  CPortManager::GetInstance().UnregisterObserver(this);
+}
+
+void CPortMapper::Notify(const Observable &obs, const ObservableMessage msg)
+{
+  switch (msg)
+  {
+    case ObservableMessagePeripheralsChanged:
+    case ObservableMessagePortsChanged:
+      ProcessPeripherals();
+      break;
+    default:
+      break;
+  }
+}
+
+void CPortMapper::ProcessPeripherals()
+{
+  std::map<CPeripheral*, IInputHandler*>& oldPortMap = m_portMap;
+
+  std::vector<CPeripheral*> devices;
+  g_peripherals.GetPeripheralsWithFeature(devices, FEATURE_JOYSTICK);
+
+  std::map<CPeripheral*, IInputHandler*> newPortMap;
+  CPortManager::GetInstance().MapDevices(devices, newPortMap);
+
+  for (std::vector<CPeripheral*>::iterator it = devices.begin(); it != devices.end(); ++it)
+  {
+    CPeripheral* device = *it;
+
+    std::map<CPeripheral*, IInputHandler*>::const_iterator itOld = oldPortMap.find(device);
+    std::map<CPeripheral*, IInputHandler*>::const_iterator itNew = newPortMap.find(device);
+
+    IInputHandler* oldHandler = itOld != oldPortMap.end() ? itOld->second : NULL;
+    IInputHandler* newHandler = itNew != newPortMap.end() ? itNew->second : NULL;
+
+    if (oldHandler != newHandler)
+    {
+      // Unregister old handler
+      if (oldHandler != NULL)
+        device->UnregisterJoystickInputHandler(oldHandler);
+
+      // Register new handler
+      if (newHandler != NULL)
+        device->RegisterJoystickInputHandler(newHandler);
+    }
+  }
+
+  oldPortMap.swap(newPortMap);
+}
diff --git a/xbmc/games/ports/PortMapper.h b/xbmc/games/ports/PortMapper.h
new file mode 100644
index 0000000..e6119a1
--- /dev/null
+++ b/xbmc/games/ports/PortMapper.h
@@ -0,0 +1,45 @@
+/*
+ *      Copyright (C) 2015-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+#include "utils/Observer.h"
+
+#include <map>
+
+namespace JOYSTICK { class IInputHandler; }
+namespace PERIPHERALS { class CPeripheral; }
+
+namespace GAME
+{
+  class CPortMapper : public Observer
+  {
+  public:
+    CPortMapper();
+
+    virtual ~CPortMapper();
+
+    virtual void Notify(const Observable& obs, const ObservableMessage msg) override;
+
+  private:
+    void ProcessPeripherals();
+
+    std::map<PERIPHERALS::CPeripheral*, JOYSTICK::IInputHandler*>  m_portMap;
+  };
+}
diff --git a/xbmc/games/tags/GameInfoTag.cpp b/xbmc/games/tags/GameInfoTag.cpp
new file mode 100644
index 0000000..e54e166
--- /dev/null
+++ b/xbmc/games/tags/GameInfoTag.cpp
@@ -0,0 +1,122 @@
+/*
+ *      Copyright (C) 2012-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "GameInfoTag.h"
+#include "utils/Archive.h"
+#include "utils/Variant.h"
+
+#include <string>
+
+using namespace GAME;
+
+void CGameInfoTag::Reset()
+{
+  m_bLoaded = false;
+  m_strURL.clear();
+  m_strName.clear();
+  m_strPlatform.clear();
+  m_strID.clear();
+  m_strRegion.clear();
+  m_strPublisher.clear();
+  m_strFormat.clear();
+  m_strCartridgeType.clear();
+}
+
+const CGameInfoTag& CGameInfoTag::operator=(const CGameInfoTag& tag)
+{
+  if (this != &tag)
+  {
+    m_bLoaded          = tag.m_bLoaded;
+    m_strURL           = tag.m_strURL;
+    m_strName          = tag.m_strName;
+    m_strPlatform      = tag.m_strPlatform;
+    m_strID            = tag.m_strID;
+    m_strRegion        = tag.m_strRegion;
+    m_strPublisher     = tag.m_strPublisher;
+    m_strFormat        = tag.m_strFormat;
+    m_strCartridgeType = tag.m_strCartridgeType;
+  }
+  return *this;
+}
+
+bool CGameInfoTag::operator==(const CGameInfoTag& tag) const
+{
+  if (this != &tag)
+  {
+    // Two tags can't be equal if they aren't loaded
+    if (!m_bLoaded || !tag.m_bLoaded) return false;
+
+    if (m_strURL           != tag.m_strURL)           return false;
+    if (m_strName          != tag.m_strName)          return false;
+    if (m_strPlatform      != tag.m_strPlatform)      return false;
+    if (m_strID            != tag.m_strID)            return false;
+    if (m_strRegion        != tag.m_strRegion)        return false;
+    if (m_strPublisher     != tag.m_strPublisher)     return false;
+    if (m_strFormat        != tag.m_strFormat)        return false;
+    if (m_strCartridgeType != tag.m_strCartridgeType) return false;
+  }
+  return true;
+}
+
+void CGameInfoTag::Archive(CArchive& ar)
+{
+  if (ar.IsStoring())
+  {
+    ar << m_bLoaded;
+    ar << std::string(m_strURL);
+    ar << std::string(m_strName);
+    ar << std::string(m_strPlatform);
+    ar << std::string(m_strID);
+    ar << std::string(m_strRegion);
+    ar << std::string(m_strPublisher);
+    ar << std::string(m_strFormat);
+    ar << std::string(m_strCartridgeType);
+  }
+  else
+  {
+    ar >> m_bLoaded;
+    ar >> m_strURL;
+    ar >> m_strName;
+    ar >> m_strPlatform;
+    ar >> m_strID;
+    ar >> m_strRegion;
+    ar >> m_strPublisher;
+    ar >> m_strFormat;
+    ar >> m_strCartridgeType;
+  }
+}
+
+void CGameInfoTag::Serialize(CVariant& value) const
+{
+  value["loaded"]        = m_bLoaded;
+  value["url"]           = m_strURL;
+  value["name"]          = m_strName;
+  value["platform"]      = m_strPlatform;
+  value["id"]            = m_strID;
+  value["region"]        = m_strRegion;
+  value["publisher"]     = m_strPublisher;
+  value["format"]        = m_strFormat;
+  value["cartridgetype"] = m_strCartridgeType;
+}
+
+void CGameInfoTag::ToSortable(SortItem& sortable, Field field) const
+{
+  // No database entries for games (...yet)
+}
diff --git a/xbmc/games/tags/GameInfoTag.h b/xbmc/games/tags/GameInfoTag.h
new file mode 100644
index 0000000..42a9a67
--- /dev/null
+++ b/xbmc/games/tags/GameInfoTag.h
@@ -0,0 +1,94 @@
+/*
+ *      Copyright (C) 2012-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+#include "utils/IArchivable.h"
+#include "utils/ISerializable.h"
+#include "utils/ISortable.h"
+
+#include <string>
+
+namespace GAME
+{
+  class CGameInfoTag : public IArchivable,
+                       public ISerializable,
+                       public ISortable
+  {
+  public:
+    CGameInfoTag() { Reset(); }
+    CGameInfoTag(const CGameInfoTag& tag) { *this = tag; }
+    const CGameInfoTag& operator=(const CGameInfoTag& tag);
+    ~CGameInfoTag() { }
+    void Reset();
+
+    bool operator==(const CGameInfoTag& tag) const;
+    bool operator!=(const CGameInfoTag& tag) const { return !(*this == tag); }
+
+    bool IsLoaded() const { return m_bLoaded; }
+    void SetLoaded(bool bOnOff = true) { m_bLoaded = bOnOff; }
+
+    // File path
+    const std::string& GetURL() const { return m_strURL; }
+    void SetURL(const std::string& strURL) { m_strURL = strURL; }
+
+    // Title
+    const std::string& GetTitle() const { return m_strName; }
+    void SetTitle(const std::string& strName) { m_strName = strName; }
+
+    // Platform
+    const std::string& GetPlatform() const { return m_strPlatform; }
+    void SetPlatform(const std::string& strPlatform) { m_strPlatform = strPlatform; }
+
+    // Game Code (ID)
+    const std::string& GetID() const { return m_strID; }
+    void SetID(const std::string& strID) { m_strID = strID; }
+
+    // Region
+    const std::string& GetRegion() const { return m_strRegion; }
+    void SetRegion(const std::string& strRegion) { m_strRegion = strRegion; }
+
+    // Publisher / Licensee
+    const std::string& GetPublisher() const { return m_strPublisher; }
+    void SetPublisher(const std::string& strPublisher) { m_strPublisher = strPublisher; }
+
+    // Format (PAL/NTSC)
+    const std::string& GetFormat() const { return m_strFormat; }
+    void SetFormat(const std::string& strFormat) { m_strFormat = strFormat; }
+
+    // Cartridge Type, e.g. "ROM+MBC5+RAM+BATT" or "CD"
+    const std::string& GetCartridgeType() const { return m_strCartridgeType; }
+    void SetCartridgeType(const std::string& strCartridgeType) { m_strCartridgeType = strCartridgeType; }
+
+    virtual void Archive(CArchive& ar) override;
+    virtual void Serialize(CVariant& value) const override;
+    virtual void ToSortable(SortItem& sortable, Field field) const override;
+
+  private:
+    bool        m_bLoaded;
+    std::string m_strURL;
+    std::string m_strName;
+    std::string m_strPlatform;
+    std::string m_strID;
+    std::string m_strRegion;
+    std::string m_strPublisher;
+    std::string m_strFormat;
+    std::string m_strCartridgeType;
+  };
+}
diff --git a/xbmc/games/tags/Makefile b/xbmc/games/tags/Makefile
new file mode 100644
index 0000000..7c47526
--- /dev/null
+++ b/xbmc/games/tags/Makefile
@@ -0,0 +1,6 @@
+SRCS=GameInfoTag.cpp \
+
+LIB=gameinfotags.a
+
+include ../../../Makefile.include
+-include $(patsubst %.cpp,%.P,$(patsubst %.c,%.P,$(SRCS)))
diff --git a/xbmc/games/windows/GUIViewStateWindowGames.cpp b/xbmc/games/windows/GUIViewStateWindowGames.cpp
new file mode 100644
index 0000000..31f69e7
--- /dev/null
+++ b/xbmc/games/windows/GUIViewStateWindowGames.cpp
@@ -0,0 +1,93 @@
+/*
+ *      Copyright (C) 2012-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "GUIViewStateWindowGames.h"
+#include "games/GameManager.h"
+#include "FileItem.h"
+#include "guilib/GraphicContext.h" // include before ViewState.h
+#include "guilib/LocalizeStrings.h"
+#include "guilib/WindowIDs.h"
+#include "input/Key.h"
+#include "settings/Settings.h"
+#include "utils/StringUtils.h"
+#include "view/ViewState.h"
+#include "view/ViewStateSettings.h"
+
+using namespace GAME;
+
+CGUIViewStateWindowGames::CGUIViewStateWindowGames(const CFileItemList& items) : CGUIViewState(items)
+{
+  if (items.IsVirtualDirectoryRoot())
+  {
+    AddSortMethod(SortByNone, 551, LABEL_MASKS("%F", "%I", "%L", ""));  // Filename, Size | Label, empty
+    SetSortMethod(SortByNone);
+    SetViewAsControl(DEFAULT_VIEW_LIST);
+    SetSortOrder(SortOrderNone);
+  }
+  else
+  {
+    AddSortMethod(SortByFile, 561, LABEL_MASKS("%F", "%I", "%L", ""));  // Filename, Size | Label, empty
+    AddSortMethod(SortBySize, 553, LABEL_MASKS("%L", "%I", "%L", "%I"));  // Filename, Size | Label, Size
+    SetSortMethod(SortByFile);
+
+    const CViewState *viewState = CViewStateSettings::GetInstance().Get("games");
+    SetSortMethod(viewState->m_sortDescription);
+    SetViewAsControl(viewState->m_viewMode);
+    SetSortOrder(viewState->m_sortDescription.sortOrder);
+  }
+
+  LoadViewState(items.GetPath(), WINDOW_GAMES);
+}
+
+std::string CGUIViewStateWindowGames::GetLockType()
+{
+  return "games";
+}
+
+std::string CGUIViewStateWindowGames::GetExtensions()
+{
+  std::vector<std::string> exts;
+  CGameManager::GetInstance().GetExtensions(exts);
+  return StringUtils::Join(exts, "|");
+}
+
+VECSOURCES& CGUIViewStateWindowGames::GetSources()
+{
+  m_sources.clear();
+
+  // Files
+  {
+    CMediaSource share;
+    share.strPath = "sources://games/";
+    share.strName = g_localizeStrings.Get(744); // Files
+    share.m_iDriveType = CMediaSource::SOURCE_TYPE_LOCAL;
+    share.m_strThumbnailImage = "DefaultFolder.png";
+    m_sources.push_back(share);
+  }
+
+  // Add-ons
+  AddAddonsSource("game", g_localizeStrings.Get(27016), "DefaultAddonGame.png"); // Game Add-ons
+  return CGUIViewState::GetSources();
+}
+
+void CGUIViewStateWindowGames::SaveViewState()
+{
+  SaveViewToDb(m_items.GetPath(), WINDOW_GAMES, CViewStateSettings::GetInstance().Get("games"));
+}
diff --git a/xbmc/games/windows/GUIViewStateWindowGames.h b/xbmc/games/windows/GUIViewStateWindowGames.h
new file mode 100644
index 0000000..d7a4ab6
--- /dev/null
+++ b/xbmc/games/windows/GUIViewStateWindowGames.h
@@ -0,0 +1,36 @@
+/*
+ *      Copyright (C) 2012-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+#include "view/GUIViewState.h"
+
+class CGUIViewStateWindowGames : public CGUIViewState
+{
+public:
+  CGUIViewStateWindowGames(const CFileItemList& items);
+
+  // implementation of CGUIViewState
+  virtual std::string GetLockType() override;
+  virtual std::string GetExtensions() override;
+  virtual VECSOURCES& GetSources() override;
+
+protected:
+  virtual void SaveViewState() override;
+};
diff --git a/xbmc/games/windows/GUIWindowGames.cpp b/xbmc/games/windows/GUIWindowGames.cpp
new file mode 100644
index 0000000..e5209f5
--- /dev/null
+++ b/xbmc/games/windows/GUIWindowGames.cpp
@@ -0,0 +1,256 @@
+/*
+ *      Copyright (C) 2012-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "GUIWindowGames.h"
+#include "addons/GUIDialogAddonInfo.h"
+#include "Application.h"
+#include "dialogs/GUIDialogProgress.h"
+#include "FileItem.h"
+#include "games/tags/GameInfoTag.h"
+#include "guilib/GUIWindowManager.h"
+#include "guilib/WindowIDs.h"
+#include "GUIPassword.h"
+#include "input/Key.h"
+#include "settings/Settings.h"
+#include "URL.h"
+#include "Util.h"
+#include "utils/StringUtils.h"
+
+#define CONTROL_BTNVIEWASICONS      2
+#define CONTROL_BTNSORTBY           3
+#define CONTROL_BTNSORTASC          4
+//#define CONTROL_LABELFILES         12
+
+using namespace XFILE;
+
+CGUIWindowGames::CGUIWindowGames() :
+  CGUIMediaWindow(WINDOW_GAMES, "MyGames.xml")
+{
+}
+
+bool CGUIWindowGames::OnMessage(CGUIMessage& message)
+{
+  switch (message.GetMessage())
+  {
+  case GUI_MSG_WINDOW_INIT:
+    {
+      m_rootDir.AllowNonLocalSources(false);
+
+      // Is this the first time the window is opened?
+      if (m_vecItems->GetPath() == "?" && message.GetStringParam().empty())
+        m_vecItems->SetPath("");
+
+      m_dlgProgress = dynamic_cast<CGUIDialogProgress*>(g_windowManager.GetWindow(WINDOW_DIALOG_PROGRESS));
+    }
+    break;
+
+  case GUI_MSG_CLICKED:
+    {
+      int iControl = message.GetSenderId();
+      if (m_viewControl.HasControl(iControl))  // list/thumb control
+      {
+        int iItem = m_viewControl.GetSelectedItem();
+        CFileItemPtr pItem = m_vecItems->Get(iItem);
+        int iAction = message.GetParam1();
+
+        if (iAction == ACTION_DELETE_ITEM)
+        {
+          if (CSettings::GetInstance().GetBool("filelists.allowfiledeletion"))
+          {
+            OnDeleteItem(iItem);
+            return true;
+          }
+        }
+        else if (iAction == ACTION_PLAYER_PLAY)
+        {
+          return OnClick(iItem);
+        }
+        else if (iAction == ACTION_SHOW_INFO)
+        {
+          if (!m_vecItems->IsPlugin() && pItem && (pItem->IsPlugin() || pItem->IsScript()))
+          {
+            CGUIDialogAddonInfo::ShowForItem(pItem);
+            return true;
+          }
+        }
+      }
+    }
+    break;
+  }
+  return CGUIMediaWindow::OnMessage(message);
+}
+
+void CGUIWindowGames::SetupShares()
+{
+  CGUIMediaWindow::SetupShares();
+  // XBMC downloads a list of supported extensions from the remote add-ons
+  // repo. Zip files are treated as directories and scanned recursively; if
+  // they don't contain valid extensions (such as MAME arcade games), the
+  // entire zip will be missing from the MyGames window. Skipping the recursive
+  // scan always shows zip files (note: entering the zip will show an empty
+  // folder) and speeds up directory listing as a nice side effect.
+  m_rootDir.SetFlags(DIR_FLAG_NO_FILE_DIRS);
+}
+
+void CGUIWindowGames::GetContextButtons(int itemNumber, CContextButtons &buttons)
+{
+  CFileItemPtr item = m_vecItems->Get(itemNumber);
+
+  if (item && !item->GetProperty("pluginreplacecontextitems").asBoolean())
+  {
+    if (m_vecItems->IsSourcesPath())
+    {
+      // Context buttons for a sources path, like "Add source", "Remove Source", etc.
+      CGUIDialogContextMenu::GetContextButtons("games", item, buttons);
+    }
+    else if (!m_vecItems->IsVirtualDirectoryRoot())
+    {
+      if (item->IsGame())
+      {
+        buttons.Add(CONTEXT_BUTTON_PLAY_ITEM, 208); // Play
+        // Let RetroPlayer handle this one
+        //buttons.Add(CONTEXT_BUTTON_PLAY_WITH, 15213); // Play With...
+      }
+
+      if (!m_vecItems->IsPlugin() && (item->IsPlugin() || item->IsScript()))
+        buttons.Add(CONTEXT_BUTTON_INFO, 24003); // Add-on info
+
+      if (CSettings::GetInstance().GetBool("filelists.allowfiledeletion") && !item->IsReadOnly())
+      {
+        buttons.Add(CONTEXT_BUTTON_DELETE, 117);
+        buttons.Add(CONTEXT_BUTTON_RENAME, 118);
+      }
+
+      if (item->IsPlugin() || item->IsScript() || m_vecItems->IsPlugin())
+      {
+        buttons.Add(CONTEXT_BUTTON_PLUGIN_SETTINGS, 1045);
+      }
+    }
+    else
+    {
+      // We are virtual directory root
+      buttons.Add(CONTEXT_BUTTON_SWITCH_MEDIA, 523); // Switch media
+    }
+  }
+
+  CGUIMediaWindow::GetContextButtons(itemNumber, buttons);
+
+  if (item && !item->GetProperty("pluginreplacecontextitems").asBoolean())
+    buttons.Add(CONTEXT_BUTTON_SETTINGS, 5); // Settings
+}
+
+bool CGUIWindowGames::OnContextButton(int itemNumber, CONTEXT_BUTTON button)
+{
+  CFileItemPtr item = m_vecItems->Get(itemNumber);
+  if (item && m_vecItems->IsSourcesPath())
+  {
+    if (CGUIDialogContextMenu::OnContextButton("games", item, button))
+    {
+      Update("sources://games/");
+      return true;
+    }
+  }
+  switch (button)
+  {
+  case CONTEXT_BUTTON_PLAY_ITEM:
+  case CONTEXT_BUTTON_PLAY_WITH:
+    return item && PlayGame(*item);
+  case CONTEXT_BUTTON_INFO:
+    OnItemInfo(itemNumber);
+    return true;
+  case CONTEXT_BUTTON_DELETE:
+    OnDeleteItem(itemNumber);
+    return true;
+  case CONTEXT_BUTTON_RENAME:
+    OnRenameItem(itemNumber);
+    return true;
+  case CONTEXT_BUTTON_SETTINGS:
+    g_windowManager.ActivateWindow(WINDOW_SETTINGS_MYGAMES);
+    return true;
+  default:
+    break;
+  }
+  return CGUIMediaWindow::OnContextButton(itemNumber, button);
+}
+
+bool CGUIWindowGames::OnClick(int iItem, const std::string &player /* = "" */)
+{
+  CFileItemPtr item = m_vecItems->Get(iItem);
+  if (!item)
+    return true;
+
+  if (!(item->m_bIsFolder || item->IsFileFolder()) && item->IsGame())
+    return PlayGame(*item);
+  else
+    return CGUIMediaWindow::OnClick(iItem);
+}
+
+void CGUIWindowGames::OnItemInfo(int itemNumber)
+{
+  CFileItemPtr item = m_vecItems->Get(itemNumber);
+  if (!item)
+    return;
+
+  if (!m_vecItems->IsPlugin() && (item->IsPlugin() || item->IsScript()))
+    CGUIDialogAddonInfo::ShowForItem(item);
+}
+
+bool CGUIWindowGames::PlayGame(const CFileItem &item)
+{
+  // Decode zip:// path for zip root directory
+  CFileItem gameFile = item;
+  CURL url(item.GetPath());
+  if (url.GetProtocol() == "zip" && url.GetFileName() == "")
+    gameFile.SetPath(url.GetHostName());
+
+  // Allocate a game info tag to let the player know it's a game
+  gameFile.GetGameInfoTag();
+
+  // Let RetroPlayer choose the right action
+  return g_application.PlayFile(gameFile, "") == PLAYBACK_OK;
+}
+
+std::string CGUIWindowGames::GetStartFolder(const std::string &dir)
+{
+  if (StringUtils::EqualsNoCase(dir, "plugins") ||
+      StringUtils::EqualsNoCase(dir, "addons"))
+  {
+    return "addons://sources/game/";
+  }
+
+  SetupShares();
+  VECSOURCES shares;
+  m_rootDir.GetSources(shares);
+  bool bIsSourceName = false;
+  int iIndex = CUtil::GetMatchingSource(dir, shares, bIsSourceName);
+  if (iIndex >= 0)
+  {
+    if (iIndex < (int)shares.size() && shares[iIndex].m_iHasLock == 2)
+    {
+      CFileItem item(shares[iIndex]);
+      if (!g_passwordManager.IsItemUnlocked(&item, "games"))
+        return "";
+    }
+    if (bIsSourceName)
+      return shares[iIndex].strPath;
+    return dir;
+  }
+  return CGUIMediaWindow::GetStartFolder(dir);
+}
diff --git a/xbmc/games/windows/GUIWindowGames.h b/xbmc/games/windows/GUIWindowGames.h
new file mode 100644
index 0000000..72e357a
--- /dev/null
+++ b/xbmc/games/windows/GUIWindowGames.h
@@ -0,0 +1,45 @@
+/*
+ *      Copyright (C) 2012-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+#include "windows/GUIMediaWindow.h"
+
+class CGUIDialogProgress;
+
+class CGUIWindowGames : public CGUIMediaWindow
+{
+public:
+  CGUIWindowGames();
+  virtual ~CGUIWindowGames() { }
+  virtual bool OnMessage(CGUIMessage& message);
+
+protected:
+  // implementation of CGUIMediaWindow
+  virtual void SetupShares() override;
+  virtual bool OnClick(int iItem, const std::string &player = "") override;
+  virtual void GetContextButtons(int itemNumber, CContextButtons &buttons) override;
+  virtual bool OnContextButton(int itemNumber, CONTEXT_BUTTON button) override;
+  virtual std::string GetStartFolder(const std::string &dir) override;
+
+  void OnItemInfo(int itemNumber);
+  bool PlayGame(const CFileItem &item);
+
+  CGUIDialogProgress *m_dlgProgress;
+};
diff --git a/xbmc/games/windows/Makefile b/xbmc/games/windows/Makefile
new file mode 100644
index 0000000..f800574
--- /dev/null
+++ b/xbmc/games/windows/Makefile
@@ -0,0 +1,7 @@
+SRCS=GUIViewStateWindowGames.cpp \
+     GUIWindowGames.cpp \
+
+LIB=gamewindows.a
+
+include ../../../Makefile.include
+-include $(patsubst %.cpp,%.P,$(patsubst %.c,%.P,$(SRCS)))
diff --git a/xbmc/guiinfo/GUIInfoLabels.h b/xbmc/guiinfo/GUIInfoLabels.h
index 047ae1a..cedae90 100644
--- a/xbmc/guiinfo/GUIInfoLabels.h
+++ b/xbmc/guiinfo/GUIInfoLabels.h
@@ -309,41 +309,39 @@
 #define CONTAINER_TOTALUNWATCHED    380
 #define CONTAINER_VIEWCOUNT         381
 #define CONTAINER_SHOWTITLE         382
-#define CONTAINER_PLUGINCATEGORY    383
-
-#define MUSICPM_ENABLED             390
-#define MUSICPM_SONGSPLAYED         391
-#define MUSICPM_MATCHINGSONGS       392
-#define MUSICPM_MATCHINGSONGSPICKED 393
-#define MUSICPM_MATCHINGSONGSLEFT   394
-#define MUSICPM_RELAXEDSONGSPICKED  395
-#define MUSICPM_RANDOMSONGSPICKED   396
-
-#define PLAYLIST_LENGTH             400
-#define PLAYLIST_POSITION           401
-#define PLAYLIST_RANDOM             402
-#define PLAYLIST_REPEAT             403
-#define PLAYLIST_ISRANDOM           404
-#define PLAYLIST_ISREPEAT           405
-#define PLAYLIST_ISREPEATONE        406
-
-#define VISUALISATION_LOCKED        410
-#define VISUALISATION_PRESET        411
-#define VISUALISATION_NAME          412
-#define VISUALISATION_ENABLED       413
-#define VISUALISATION_HAS_PRESETS   414
-
-#define STRING_IS_EMPTY             420
-#define STRING_IS_EQUAL             421
-#define STRING_STARTS_WITH          422
-#define STRING_ENDS_WITH            423
-#define STRING_CONTAINS             424
+#define MUSICPM_ENABLED             383
+#define MUSICPM_SONGSPLAYED         384
+#define MUSICPM_MATCHINGSONGS       385
+#define MUSICPM_MATCHINGSONGSPICKED 386
+#define MUSICPM_MATCHINGSONGSLEFT   387
+#define MUSICPM_RELAXEDSONGSPICKED  388
+#define MUSICPM_RANDOMSONGSPICKED   389
+
+#define PLAYLIST_LENGTH             390
+#define PLAYLIST_POSITION           391
+#define PLAYLIST_RANDOM             392
+#define PLAYLIST_REPEAT             393
+#define PLAYLIST_ISRANDOM           394
+#define PLAYLIST_ISREPEAT           395
+#define PLAYLIST_ISREPEATONE        396
+
+#define VISUALISATION_LOCKED        400
+#define VISUALISATION_PRESET        401
+#define VISUALISATION_NAME          402
+#define VISUALISATION_ENABLED       403
+#define VISUALISATION_HAS_PRESETS   404
+
+#define STRING_IS_EMPTY             410
+#define STRING_IS_EQUAL             411
+#define STRING_STARTS_WITH          412
+#define STRING_ENDS_WITH            413
+#define STRING_CONTAINS             414
 // deprecated begin
 // should be removed before L*** v18
-#define STRING_COMPARE              425
-#define STRING_STR                  426
-#define STRING_STR_LEFT             428
-#define STRING_STR_RIGHT            429
+#define STRING_COMPARE              415
+#define STRING_STR                  416
+#define STRING_STR_LEFT             418
+#define STRING_STR_RIGHT            419
 // deprecated end
 
 #define INTEGER_IS_EQUAL            450
@@ -756,7 +754,6 @@
 #define LISTITEM_ADDON_INSTALL_DATE (LISTITEM_START + 172)
 #define LISTITEM_ADDON_LAST_UPDATED (LISTITEM_START + 173)
 #define LISTITEM_ADDON_LAST_USED    (LISTITEM_START + 174)
-#define LISTITEM_STATUS             (LISTITEM_START + 175)
 
 #define LISTITEM_PROPERTY_START     (LISTITEM_START + 200)
 #define LISTITEM_PROPERTY_END       (LISTITEM_PROPERTY_START + 1300)
diff --git a/xbmc/guilib/CMakeLists.txt b/xbmc/guilib/CMakeLists.txt
index b07b274..f443bd4 100644
--- a/xbmc/guilib/CMakeLists.txt
+++ b/xbmc/guilib/CMakeLists.txt
@@ -241,5 +241,4 @@ if(CORE_SYSTEM_NAME STREQUAL windows)
                   ps_4_0_level_9_1
                   PS)
   endforeach()
-  add_dependencies(guilib d3dx11effects)
 endif()
diff --git a/xbmc/guilib/FFmpegImage.cpp b/xbmc/guilib/FFmpegImage.cpp
index dcc3574..9e7b77d 100644
--- a/xbmc/guilib/FFmpegImage.cpp
+++ b/xbmc/guilib/FFmpegImage.cpp
@@ -327,7 +327,7 @@ AVFrame* CFFmpegImage::ExtractFrame()
   }
 
   av_frame_free(&frame);
-  av_packet_unref(&pkt);
+  av_free_packet(&pkt);
 
   return clone;
 }
@@ -375,28 +375,24 @@ bool CFFmpegImage::Decode(unsigned char * const pixels, unsigned int width, unsi
 
 bool CFFmpegImage::DecodeFrame(AVFrame* frame, unsigned int width, unsigned int height, unsigned int pitch, unsigned char * const pixels)
 {
-  AVFrame* pictureRGB = av_frame_alloc();
+  AVPicture* pictureRGB = static_cast<AVPicture*>(av_mallocz(sizeof(AVPicture)));
   if (!pictureRGB)
   {
-    CLog::LogFunction(LOGERROR, __FUNCTION__, "AVFrame could not be allocated");
+    CLog::LogFunction(LOGERROR, __FUNCTION__, "AVPicture could not be allocated");
     return false;
   }
 
-  int size = av_image_fill_arrays(pictureRGB->data, pictureRGB->linesize, NULL, AV_PIX_FMT_RGB32, width, height, 16);
+  int size = avpicture_fill(pictureRGB, NULL, AV_PIX_FMT_RGB32, width, height);
   if (size < 0)
   {
-    CLog::LogFunction(LOGERROR, __FUNCTION__, "Could not allocate AVFrame member with %i x %i pixes", width, height);
-    av_frame_free(&pictureRGB);
+    CLog::LogFunction(LOGERROR, __FUNCTION__, "Could not allocate AVPicture member with %i x %i pixes", width, height);
+    av_free(pictureRGB);
     return false;
   }
 
   bool needsCopy = false;
   int pixelsSize = pitch * height;
-  bool aligned = (((uintptr_t)(const void *)(pixels)) % (16) == 0);
-  if (!aligned)
-    CLog::Log(LOGDEBUG, "Alignment of external buffer is not suitable for ffmpeg intrinsics - please fix your malloc");
-
-  if (aligned && size == pixelsSize && (int)pitch == pictureRGB->linesize[0])
+  if (size == pixelsSize && (int)pitch == pictureRGB->linesize[0])
   {
     // We can use the pixels buffer directly
     pictureRGB->data[0] = pixels;
@@ -404,13 +400,10 @@ bool CFFmpegImage::DecodeFrame(AVFrame* frame, unsigned int width, unsigned int
   else
   {
     // We need an extra buffer and copy it manually afterwards
-    pictureRGB->format = AV_PIX_FMT_RGB32;
-    pictureRGB->width = width;
-    pictureRGB->height = height;
-    if (av_frame_get_buffer(pictureRGB, 16) < 0)
+    if (avpicture_alloc(pictureRGB, AV_PIX_FMT_RGB32, width, height) < 0)
     {
       CLog::LogFunction(LOGERROR, __FUNCTION__, "Could not allocate temp buffer of size %i bytes", size);
-      av_frame_free(&pictureRGB);
+      av_free(pictureRGB);
       return false;
     }
     needsCopy = true;
@@ -471,14 +464,12 @@ bool CFFmpegImage::DecodeFrame(AVFrame* frame, unsigned int width, unsigned int
       src += pictureRGB->linesize[0];
       dst += pitch;
     }
-    av_frame_free(&pictureRGB);
-  }
-  else
-  {
-    // we only lended the data so don't get it deleted
-    pictureRGB->data[0] = nullptr;
-    av_frame_free(&pictureRGB);
+
+    avpicture_free(pictureRGB);
   }
+  pictureRGB->data[0] = nullptr;
+  avpicture_free(pictureRGB);
+  av_free(pictureRGB);
 
   // update width and height original dimensions are kept
   m_height = nHeight;
@@ -540,7 +531,7 @@ bool CFFmpegImage::CreateThumbnailFromSurface(unsigned char* bufferin, unsigned
 
   unsigned int internalBufOutSize = 0;
 
-  int size = av_image_get_buffer_size(tdm.avOutctx->pix_fmt, tdm.avOutctx->width, tdm.avOutctx->height, 16);
+  int size = avpicture_get_size(tdm.avOutctx->pix_fmt, tdm.avOutctx->width, tdm.avOutctx->height);
   if (size < 0)
   {
     CLog::Log(LOGERROR, "Could not compute picture size for thumbnail: %s", destFile.c_str());
@@ -591,7 +582,7 @@ bool CFFmpegImage::CreateThumbnailFromSurface(unsigned char* bufferin, unsigned
     return false;
   }
 
-  if (av_image_fill_arrays(tdm.frame_temporary->data, tdm.frame_temporary->linesize, tdm.intermediateBuffer, jpg_output ? AV_PIX_FMT_YUV420P : AV_PIX_FMT_RGBA, width, height, 16) < 0)
+  if (avpicture_fill((AVPicture*)tdm.frame_temporary, tdm.intermediateBuffer, jpg_output ? AV_PIX_FMT_YUV420P : AV_PIX_FMT_RGBA, width, height) < 0)
   {
     CLog::Log(LOGERROR, "Could not fill picture for thumbnail: %s", destFile.c_str());
     CleanupLocalOutputBuffer();
diff --git a/xbmc/guilib/GUIBaseContainer.cpp b/xbmc/guilib/GUIBaseContainer.cpp
index 1dec42b..700870b 100644
--- a/xbmc/guilib/GUIBaseContainer.cpp
+++ b/xbmc/guilib/GUIBaseContainer.cpp
@@ -19,6 +19,7 @@
  */
 
 #include "GUIBaseContainer.h"
+#include "ContextMenuManager.h"
 #include "utils/CharsetConverter.h"
 #include "GUIInfoManager.h"
 #include "utils/TimeUtils.h"
@@ -354,22 +355,15 @@ bool CGUIBaseContainer::OnAction(const CAction &action)
       int selected = GetSelectedItem();
       if (selected >= 0 && selected < m_items.size())
       {
-        m_listProvider->OnContextMenu(m_items[selected]);
+        CFileItemPtr fileItem = std::dynamic_pointer_cast<CFileItem>(m_items[selected]);
+        if (fileItem)
+          CONTEXTMENU::ShowFor(fileItem);
         return true;
       }
     }
     break;
   case ACTION_SHOW_INFO:
-    if (m_listProvider)
-    {
-      int selected = GetSelectedItem();
-      if (selected >= 0 && selected < m_items.size())
-      {
-        m_listProvider->OnInfo(m_items[selected]);
-        return true;
-      }
-    }
-    else if (OnInfo())
+    if (OnInfo())
       return true;
     else if (action.GetID())
       return OnClick(action.GetID());
diff --git a/xbmc/guilib/GUIIncludes.cpp b/xbmc/guilib/GUIIncludes.cpp
index 63cb7b2..69c9099 100644
--- a/xbmc/guilib/GUIIncludes.cpp
+++ b/xbmc/guilib/GUIIncludes.cpp
@@ -304,7 +304,7 @@ void CGUIIncludes::ResolveIncludesForNode(TiXmlElement *node, std::map<INFO::Inf
     Params params;
     std::string tagName;
     // determine which form of include call we have
-    const char *name = include->Attribute("content");
+    const char *name = include->Attribute("name");
     if (name)
     {
       // 1. <include name="MyControl" />
diff --git a/xbmc/guilib/GUIWindowManager.cpp b/xbmc/guilib/GUIWindowManager.cpp
index 3090643..b61fc07 100644
--- a/xbmc/guilib/GUIWindowManager.cpp
+++ b/xbmc/guilib/GUIWindowManager.cpp
@@ -143,6 +143,7 @@
 
 /* Game related include files */
 #include "games/controllers/windows/GUIControllerWindow.h"
+#include "games/windows/GUIWindowGames.h"
 
 using namespace PVR;
 using namespace PERIPHERALS;
@@ -290,6 +291,7 @@ void CGUIWindowManager::CreateWindows()
   Add(new CGUIWindowEventLog);
 
   Add(new GAME::CGUIControllerWindow);
+  Add(new CGUIWindowGames);
 }
 
 bool CGUIWindowManager::DestroyWindows()
@@ -393,6 +395,7 @@ bool CGUIWindowManager::DestroyWindows()
     Delete(WINDOW_PICTURES);
     Delete(WINDOW_WEATHER);
     Delete(WINDOW_DIALOG_GAME_CONTROLLERS);
+    Delete(WINDOW_GAMES);
 
     Delete(WINDOW_SETTINGS_MYPICTURES);
     Remove(WINDOW_SETTINGS_MYPROGRAMS);
@@ -403,6 +406,7 @@ bool CGUIWindowManager::DestroyWindows()
     Remove(WINDOW_SETTINGS_SERVICE);
     Remove(WINDOW_SETTINGS_APPEARANCE);
     Remove(WINDOW_SETTINGS_MYPVR);
+    Remove(WINDOW_SETTINGS_MYGAMES);
     Remove(WINDOW_DIALOG_KAI_TOAST);
 
     Remove(WINDOW_DIALOG_SEEK_BAR);
@@ -822,8 +826,7 @@ void CGUIWindowManager::CloseDialogs(bool forceClose) const
   if (m_activeDialogs.empty())
     return;
 
-  auto activeDialogs = m_activeDialogs;
-  for (const auto& dialog : activeDialogs)
+  for (const auto& dialog : m_activeDialogs)
   {
     dialog->Close(forceClose);
   }
@@ -835,8 +838,7 @@ void CGUIWindowManager::CloseInternalModalDialogs(bool forceClose) const
   if (m_activeDialogs.empty())
     return;
 
-  auto activeDialogs = m_activeDialogs;
-  for (const auto& dialog : activeDialogs)
+  for (const auto& dialog : m_activeDialogs)
   {
     if (dialog->IsModalDialog() && !IsAddonWindow(dialog->GetID()) && !IsPythonWindow(dialog->GetID()))
       dialog->Close(forceClose);
diff --git a/xbmc/guilib/GraphicContext.cpp b/xbmc/guilib/GraphicContext.cpp
index 092c6f3..0ef95dd 100644
--- a/xbmc/guilib/GraphicContext.cpp
+++ b/xbmc/guilib/GraphicContext.cpp
@@ -331,7 +331,7 @@ void CGraphicContext::SetFullScreenVideo(bool bOnOff)
   {
     bool allowDesktopRes = CSettings::GetInstance().GetInt(CSettings::SETTING_VIDEOPLAYER_ADJUSTREFRESHRATE) == ADJUST_REFRESHRATE_ALWAYS;
     if (m_bFullScreenVideo || (!allowDesktopRes && g_application.m_pPlayer->IsPlayingVideo()))
-      g_application.m_pPlayer->TriggerUpdateResolution();
+      SetVideoResolution(g_application.m_pPlayer->GetRenderResolution());
     else if (CDisplaySettings::GetInstance().GetCurrentResolution() > RES_DESKTOP)
       SetVideoResolution(CDisplaySettings::GetInstance().GetCurrentResolution());
     else
diff --git a/xbmc/guilib/Texture.cpp b/xbmc/guilib/Texture.cpp
index 419148d..d84d1ef 100644
--- a/xbmc/guilib/Texture.cpp
+++ b/xbmc/guilib/Texture.cpp
@@ -35,9 +35,6 @@
 #include "URL.h"
 #include "filesystem/AndroidAppFile.h"
 #endif
-#ifdef TARGET_POSIX
-#include "linux/XMemUtils.h"
-#endif
 
 /************************************************************************/
 /*                                                                      */
@@ -52,8 +49,7 @@ CBaseTexture::CBaseTexture(unsigned int width, unsigned int height, unsigned int
 
 CBaseTexture::~CBaseTexture()
 {
-  _aligned_free(m_pixels);
-  m_pixels = NULL;
+  delete[] m_pixels;
 }
 
 void CBaseTexture::Allocate(unsigned int width, unsigned int height, unsigned int format)
@@ -102,12 +98,11 @@ void CBaseTexture::Allocate(unsigned int width, unsigned int height, unsigned in
   CLAMP(m_imageWidth, m_textureWidth);
   CLAMP(m_imageHeight, m_textureHeight);
 
-  _aligned_free(m_pixels);
+  delete[] m_pixels;
   m_pixels = NULL;
   if (GetPitch() * GetRows() > 0)
   {
-    size_t size = GetPitch() * GetRows();
-    m_pixels = (unsigned char*) _aligned_malloc(size, 16);
+    m_pixels = new unsigned char[GetPitch() * GetRows()];
   }
 }
 
diff --git a/xbmc/guilib/Texture.h b/xbmc/guilib/Texture.h
index 9506ebf..2783b78 100644
--- a/xbmc/guilib/Texture.h
+++ b/xbmc/guilib/Texture.h
@@ -23,9 +23,6 @@
 #include "system.h"
 #include "XBTF.h"
 #include "guilib/imagefactory.h"
-#ifdef TARGET_POSIX
-#include "linux/XMemUtils.h"
-#endif
 
 #pragma pack(1)
 struct COLOR {unsigned char b,g,r,x;};	// Windows GDI expects 4bytes per color
diff --git a/xbmc/guilib/TextureDX.cpp b/xbmc/guilib/TextureDX.cpp
index ec25f46..465d34f 100644
--- a/xbmc/guilib/TextureDX.cpp
+++ b/xbmc/guilib/TextureDX.cpp
@@ -181,7 +181,7 @@ void CDXTexture::LoadToGPU()
     }
     m_texture.UnlockRect(0);
   }
-  _aligned_free(m_pixels);
+  delete [] m_pixels;
   m_pixels = nullptr;
 
   m_loadedToGPU = true;
diff --git a/xbmc/guilib/TextureGL.cpp b/xbmc/guilib/TextureGL.cpp
index a18bda0..58c2b00 100644
--- a/xbmc/guilib/TextureGL.cpp
+++ b/xbmc/guilib/TextureGL.cpp
@@ -24,9 +24,6 @@
 #include "utils/log.h"
 #include "utils/GLUtils.h"
 #include "guilib/TextureManager.h"
-#ifdef TARGET_POSIX
-#include "linux/XMemUtils.h"
-#endif
 
 #if defined(HAS_GL) || defined(HAS_GLES)
 
@@ -179,7 +176,7 @@ void CGLTexture::LoadToGPU()
 #endif
   VerifyGLState();
 
-  _aligned_free(m_pixels);
+  delete [] m_pixels;
   m_pixels = NULL;
 
   m_loadedToGPU = true;
diff --git a/xbmc/guilib/WindowIDs.h b/xbmc/guilib/WindowIDs.h
index 0e66f5f..3c77cdb 100644
--- a/xbmc/guilib/WindowIDs.h
+++ b/xbmc/guilib/WindowIDs.h
@@ -45,6 +45,7 @@
 
 #define WINDOW_SCRIPTS                    10020 // virtual window for backward compatibility
 #define WINDOW_SETTINGS_MYPVR             10021
+#define WINDOW_SETTINGS_MYGAMES           10022
 
 #define WINDOW_VIDEO_FILES                10024
 #define WINDOW_VIDEO_NAV                  10025
@@ -139,6 +140,7 @@
 #define WINDOW_TV_TIMER_RULES             10627
 #define WINDOW_RADIO_TIMER_RULES          10628
 #define WINDOW_DIALOG_GAME_CONTROLLERS    10629
+#define WINDOW_GAMES                      10630
 
 //#define WINDOW_VIRTUAL_KEYBOARD           11000
 // WINDOW_ID's from 11100 to 11199 reserved for Skins
diff --git a/xbmc/input/ButtonTranslator.cpp b/xbmc/input/ButtonTranslator.cpp
index de8cd1c..10a8226 100644
--- a/xbmc/input/ButtonTranslator.cpp
+++ b/xbmc/input/ButtonTranslator.cpp
@@ -314,6 +314,7 @@ static const ActionMapping windows[] =
     { "radiotimers"              , WINDOW_RADIO_TIMERS },
     { "radiosearch"              , WINDOW_RADIO_SEARCH },
     { "gamecontrollers"          , WINDOW_DIALOG_GAME_CONTROLLERS },
+    { "games"                    , WINDOW_GAMES },
     { "pvrguideinfo"             , WINDOW_DIALOG_PVR_GUIDE_INFO },
     { "pvrrecordinginfo"         , WINDOW_DIALOG_PVR_RECORDING_INFO },
     { "pvrradiordsinfo"          , WINDOW_DIALOG_PVR_RADIO_RDS_INFO },
@@ -341,6 +342,7 @@ static const ActionMapping windows[] =
     { "appearancesettings"       , WINDOW_SETTINGS_APPEARANCE },
     { "pvrsettings"              , WINDOW_SETTINGS_MYPVR },
     { "tvsettings"               , WINDOW_SETTINGS_MYPVR },            // backward compat
+    { "gamesettings"             , WINDOW_SETTINGS_MYGAMES },
     { "scripts"                  , WINDOW_PROGRAMS },                  // backward compat
     { "videofiles"               , WINDOW_VIDEO_FILES },
     { "videolibrary"             , WINDOW_VIDEO_NAV },
diff --git a/xbmc/input/XBMC_keysym.h b/xbmc/input/XBMC_keysym.h
index e7410ec..89c21f5 100644
--- a/xbmc/input/XBMC_keysym.h
+++ b/xbmc/input/XBMC_keysym.h
@@ -229,7 +229,6 @@ typedef enum {
   XBMCK_FAVORITES   = 0x14d,
   XBMCK_HOMEPAGE    = 0x14e,
   XBMCK_CONFIG      = 0x14f,
-  XBMCK_EPG         = 0x150,
 
   // Add any other keys here
 
diff --git a/xbmc/input/XBMC_keytable.cpp b/xbmc/input/XBMC_keytable.cpp
index 14fd384..4d05464 100644
--- a/xbmc/input/XBMC_keytable.cpp
+++ b/xbmc/input/XBMC_keytable.cpp
@@ -243,7 +243,6 @@ static const XBMCKEYTABLE XBMCKeyTable[] =
 , { XBMCK_FAVORITES,              0,    0, XBMCVK_FAVORITES,     "favorites" }
 , { XBMCK_HOMEPAGE ,              0,    0, XBMCVK_HOMEPAGE,      "homepage" }
 , { XBMCK_CONFIG,                 0,    0, XBMCVK_CONFIG,        "config" }
-, { XBMCK_EPG   ,                 0,    0, XBMCVK_EPG,           "epg" }
 };
 
 static int XBMCKeyTableSize = sizeof(XBMCKeyTable)/sizeof(XBMCKEYTABLE);
diff --git a/xbmc/input/XBMC_vkeys.h b/xbmc/input/XBMC_vkeys.h
index 4e3787c..af114c9 100644
--- a/xbmc/input/XBMC_vkeys.h
+++ b/xbmc/input/XBMC_vkeys.h
@@ -221,7 +221,6 @@ typedef enum {
   XBMCVK_FAVORITES      = 0xE9,
   XBMCVK_HOMEPAGE       = 0xEA,
   XBMCVK_CONFIG         = 0xEB,
-  XBMCVK_EPG            = 0xEC,
 
   XBMCVK_LAST           = 0xFF
 } XBMCVKey;
diff --git a/xbmc/input/joysticks/IButtonMapper.h b/xbmc/input/joysticks/IButtonMapper.h
index 0fbb927..0ffaac9 100644
--- a/xbmc/input/joysticks/IButtonMapper.h
+++ b/xbmc/input/joysticks/IButtonMapper.h
@@ -47,6 +47,22 @@ namespace JOYSTICK
     virtual std::string ControllerID(void) const = 0;
 
     /*!
+     * \brief Test if the mapping process is being performed for an emulated controller
+     *
+     * \return true if an emulated controller is being mapped, false otherwise
+     */
+    virtual bool Emulation(void) const = 0;
+
+    /*!
+     * \brief Get the number of the emulated controller being mapped
+     *
+     * \return The number, or 0 if an emulated controller is not being mapped
+     *
+     * \remark Emulated controllers are 1-indexed
+     */
+    virtual unsigned int ControllerNumber(void) const = 0;
+
+    /*!
      * \brief Handle button/hat press or axis threshold
      *
      * \param buttonMap  The button map being manipulated
diff --git a/xbmc/input/keyboard/generic/GenericKeyboardJoystick.cpp b/xbmc/input/keyboard/generic/GenericKeyboardJoystick.cpp
new file mode 100644
index 0000000..d62a028
--- /dev/null
+++ b/xbmc/input/keyboard/generic/GenericKeyboardJoystick.cpp
@@ -0,0 +1,82 @@
+/*
+ *      Copyright (C) 2015-2016 Team Kodi
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "GenericKeyboardJoystick.h"
+#include "GenericKeyboardJoystickHandling.h"
+#include "input/joysticks/IDriverHandler.h"
+#include "input/Key.h"
+#include "threads/SingleLock.h"
+
+using namespace KEYBOARD;
+
+void CGenericKeyboardJoystick::RegisterJoystickDriverHandler(JOYSTICK::IDriverHandler* handler, bool bPromiscuous)
+{
+  CSingleLock lock(m_mutex);
+
+  if (m_keyboardHandlers.find(handler) == m_keyboardHandlers.end())
+    m_keyboardHandlers[handler] = KeyboardHandle{new CGenericKeyboardJoystickHandling(handler), bPromiscuous};
+}
+
+void CGenericKeyboardJoystick::UnregisterJoystickDriverHandler(JOYSTICK::IDriverHandler* handler)
+{
+  CSingleLock lock(m_mutex);
+
+  KeyboardHandlers::iterator it = m_keyboardHandlers.find(handler);
+  if (it != m_keyboardHandlers.end())
+  {
+    delete it->second.handler;
+    m_keyboardHandlers.erase(it);
+  }
+}
+
+bool CGenericKeyboardJoystick::OnKeyPress(const CKey& key)
+{
+  CSingleLock lock(m_mutex);
+
+  bool bHandled = false;
+
+  // Process promiscuous handlers
+  for (KeyboardHandlers::iterator it = m_keyboardHandlers.begin(); it != m_keyboardHandlers.end(); ++it)
+  {
+    if (it->second.bPromiscuous)
+      it->second.handler->OnKeyPress(key);
+  }
+
+  // Process handlers until one is handled
+  for (KeyboardHandlers::iterator it = m_keyboardHandlers.begin(); it != m_keyboardHandlers.end(); ++it)
+  {
+    if (!it->second.bPromiscuous)
+    {
+      bHandled = it->second.handler->OnKeyPress(key);
+      if (bHandled)
+        break;
+    }
+  }
+
+  return bHandled;
+}
+
+void CGenericKeyboardJoystick::OnKeyRelease(const CKey& key)
+{
+  CSingleLock lock(m_mutex);
+
+  for (KeyboardHandlers::iterator it = m_keyboardHandlers.begin(); it != m_keyboardHandlers.end(); ++it)
+    it->second.handler->OnKeyRelease(key);
+}
diff --git a/xbmc/input/keyboard/generic/GenericKeyboardJoystick.h b/xbmc/input/keyboard/generic/GenericKeyboardJoystick.h
new file mode 100644
index 0000000..09b2f6f
--- /dev/null
+++ b/xbmc/input/keyboard/generic/GenericKeyboardJoystick.h
@@ -0,0 +1,60 @@
+/*
+ *      Copyright (C) 2015-2016 Team Kodi
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+#include "input/keyboard/IKeyboardHandler.h"
+#include "threads/CriticalSection.h"
+
+#include <map>
+
+namespace JOYSTICK
+{
+  class IDriverHandler;
+}
+
+namespace KEYBOARD
+{
+  class CGenericKeyboardJoystick : public IKeyboardHandler
+  {
+  public:
+    CGenericKeyboardJoystick(void) { }
+
+    virtual ~CGenericKeyboardJoystick(void) { }
+
+    void RegisterJoystickDriverHandler(JOYSTICK::IDriverHandler* handler, bool bPromiscuous);
+    void UnregisterJoystickDriverHandler(JOYSTICK::IDriverHandler* handler);
+
+    // implementation of IKeyboardHandler
+    virtual bool OnKeyPress(const CKey& key) override;
+    virtual void OnKeyRelease(const CKey& key) override;
+
+  private:
+    struct KeyboardHandle
+    {
+      IKeyboardHandler* handler;
+      bool              bPromiscuous;
+    };
+
+    typedef std::map<JOYSTICK::IDriverHandler*, KeyboardHandle> KeyboardHandlers;
+
+    KeyboardHandlers m_keyboardHandlers;
+    CCriticalSection m_mutex;
+  };
+}
diff --git a/xbmc/input/keyboard/generic/GenericKeyboardJoystickHandling.cpp b/xbmc/input/keyboard/generic/GenericKeyboardJoystickHandling.cpp
new file mode 100644
index 0000000..a90d4c2
--- /dev/null
+++ b/xbmc/input/keyboard/generic/GenericKeyboardJoystickHandling.cpp
@@ -0,0 +1,108 @@
+/*
+ *      Copyright (C) 2015-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "GenericKeyboardJoystickHandling.h"
+#include "input/joysticks/IDriverHandler.h"
+#include "input/Key.h"
+
+#include <algorithm>
+#include <assert.h>
+
+#define BUTTON_INDEX_MASK  0x01ff
+
+using namespace KEYBOARD;
+
+CGenericKeyboardJoystickHandling::CGenericKeyboardJoystickHandling(JOYSTICK::IDriverHandler* handler) :
+  m_handler(handler)
+{
+  assert(m_handler);
+}
+
+bool CGenericKeyboardJoystickHandling::OnKeyPress(const CKey& key)
+{
+  bool bHandled = false;
+
+  unsigned int buttonIndex = GetButtonIndex(key);
+  if (buttonIndex != 0)
+    bHandled = OnPress(buttonIndex);
+
+  return bHandled;
+}
+
+void CGenericKeyboardJoystickHandling::OnKeyRelease(const CKey& key)
+{
+  unsigned int buttonIndex = GetButtonIndex(key);
+  if (buttonIndex != 0)
+    OnRelease(buttonIndex);
+}
+
+bool CGenericKeyboardJoystickHandling::OnPress(unsigned int buttonIndex)
+{
+  bool bHandled = false;
+
+  KeyEvent event;
+  if (GetEvent(buttonIndex, event))
+  {
+    bHandled = event.bHandled;
+  }
+  else
+  {
+    bHandled = m_handler->OnButtonMotion(buttonIndex, true);
+    m_pressedKeys.push_back({buttonIndex, bHandled});
+  }
+
+  return bHandled;
+}
+
+void CGenericKeyboardJoystickHandling::OnRelease(unsigned int buttonIndex)
+{
+  KeyEvent event;
+  if (GetEvent(buttonIndex, event))
+  {
+    m_handler->OnButtonMotion(buttonIndex, false);
+    m_pressedKeys.erase(std::remove_if(m_pressedKeys.begin(), m_pressedKeys.end(),
+      [buttonIndex](const KeyEvent& event)
+      {
+        return buttonIndex == event.buttonIndex;
+      }), m_pressedKeys.end());
+  }
+}
+
+bool CGenericKeyboardJoystickHandling::GetEvent(unsigned int buttonIndex, KeyEvent& event) const
+{
+  std::vector<KeyEvent>::const_iterator it = std::find_if(m_pressedKeys.begin(), m_pressedKeys.end(),
+    [buttonIndex](const KeyEvent& event)
+    {
+      return buttonIndex == event.buttonIndex;
+    });
+
+  if (it != m_pressedKeys.end())
+  {
+    event = *it;
+    return true;
+  }
+
+  return false;
+}
+
+unsigned int CGenericKeyboardJoystickHandling::GetButtonIndex(const CKey& key)
+{
+  return key.GetButtonCode() & BUTTON_INDEX_MASK;
+}
diff --git a/xbmc/input/keyboard/generic/GenericKeyboardJoystickHandling.h b/xbmc/input/keyboard/generic/GenericKeyboardJoystickHandling.h
new file mode 100644
index 0000000..cdf82e0
--- /dev/null
+++ b/xbmc/input/keyboard/generic/GenericKeyboardJoystickHandling.h
@@ -0,0 +1,64 @@
+/*
+ *      Copyright (C) 2015-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+#include "input/keyboard/IKeyboardHandler.h"
+
+#include <vector>
+
+namespace JOYSTICK
+{
+  class IDriverHandler;
+}
+
+namespace KEYBOARD
+{
+  /*!
+   * \brief Generic implementation of a handler for joysticks that use keyboard
+   *        drivers. It basically emulates a joystick with many buttons.
+   */
+  class CGenericKeyboardJoystickHandling : public IKeyboardHandler
+  {
+  public:
+    CGenericKeyboardJoystickHandling(JOYSTICK::IDriverHandler* handler);
+
+    virtual ~CGenericKeyboardJoystickHandling(void) { }
+
+    // implementation of IKeyboardHandler
+    virtual bool OnKeyPress(const CKey& key) override;
+    virtual void OnKeyRelease(const CKey& key) override;
+
+  private:
+    struct KeyEvent
+    {
+      unsigned int buttonIndex;
+      bool         bHandled;
+    };
+
+    bool OnPress(unsigned int buttonIndex);
+    void OnRelease(unsigned int buttonIndex);
+    bool GetEvent(unsigned int buttonIndex, KeyEvent& event) const;
+
+    static unsigned int GetButtonIndex(const CKey& key);
+
+    JOYSTICK::IDriverHandler* const m_handler;
+    std::vector<KeyEvent>           m_pressedKeys;
+  };
+}
diff --git a/xbmc/input/keyboard/generic/Makefile b/xbmc/input/keyboard/generic/Makefile
new file mode 100644
index 0000000..cab8b1a
--- /dev/null
+++ b/xbmc/input/keyboard/generic/Makefile
@@ -0,0 +1,7 @@
+SRCS=GenericKeyboardJoystick.cpp \
+     GenericKeyboardJoystickHandling.cpp \
+
+LIB=input_keyboard_generic.a
+
+include ../../../../Makefile.include
+-include $(patsubst %.cpp,%.P,$(patsubst %.c,%.P,$(SRCS)))
diff --git a/xbmc/input/linux/LinuxInputDevices.cpp b/xbmc/input/linux/LinuxInputDevices.cpp
index 5486e28..b97a40e 100644
--- a/xbmc/input/linux/LinuxInputDevices.cpp
+++ b/xbmc/input/linux/LinuxInputDevices.cpp
@@ -273,7 +273,6 @@ KeyMap keyMap[] = {
   { KEY_FILE          , XBMCK_LAUNCH_FILE_BROWSER},
   { KEY_SELECT        , XBMCK_RETURN      },
   { KEY_CONFIG        , XBMCK_CONFIG      },
-  { KEY_EPG           , XBMCK_EPG         },
   // The Little Black Box Remote Additions
   { 384               , XBMCK_LEFT        }, // Red
   { 378               , XBMCK_RIGHT       }, // Green
diff --git a/xbmc/interfaces/builtins/Builtins.cpp b/xbmc/interfaces/builtins/Builtins.cpp
index 260d81e..5d8bbbe 100644
--- a/xbmc/interfaces/builtins/Builtins.cpp
+++ b/xbmc/interfaces/builtins/Builtins.cpp
@@ -67,10 +67,6 @@ CBuiltins::CBuiltins()
   RegisterCommands<CSystemBuiltins>();
   RegisterCommands<CWeatherBuiltins>();
 
-#if defined(HAVE_LIBCEC)
-  RegisterCommands<CCECBuiltins>();
-#endif
-
 #if defined(TARGET_ANDROID)
   RegisterCommands<CAndroidBuiltins>();
 #endif
diff --git a/xbmc/interfaces/generic/ScriptInvocationManager.cpp b/xbmc/interfaces/generic/ScriptInvocationManager.cpp
index a9ea51a..4cadac5 100644
--- a/xbmc/interfaces/generic/ScriptInvocationManager.cpp
+++ b/xbmc/interfaces/generic/ScriptInvocationManager.cpp
@@ -33,10 +33,6 @@
 #include "utils/URIUtils.h"
 #include "utils/log.h"
 
-#ifdef TARGET_POSIX
-#include "linux/XTimeUtils.h"
-#endif
-
 using namespace XFILE;
 
 CScriptInvocationManager::CScriptInvocationManager()
diff --git a/xbmc/interfaces/json-rpc/AddonsOperations.cpp b/xbmc/interfaces/json-rpc/AddonsOperations.cpp
index d9ac821..bd98bea 100644
--- a/xbmc/interfaces/json-rpc/AddonsOperations.cpp
+++ b/xbmc/interfaces/json-rpc/AddonsOperations.cpp
@@ -61,6 +61,9 @@ JSONRPC_STATUS CAddonsOperations::GetAddons(const std::string &method, ITranspor
     case ADDON_IMAGE:
       content = CPluginSource::IMAGE;
       break;
+    case ADDON_GAME:
+      content = CPluginSource::GAME;
+      break;
     case ADDON_EXECUTABLE:
       content = CPluginSource::EXECUTABLE;
       break;
diff --git a/xbmc/interfaces/json-rpc/VideoLibrary.cpp b/xbmc/interfaces/json-rpc/VideoLibrary.cpp
index cf1393e..e058ceb 100644
--- a/xbmc/interfaces/json-rpc/VideoLibrary.cpp
+++ b/xbmc/interfaces/json-rpc/VideoLibrary.cpp
@@ -1113,8 +1113,6 @@ void CVideoLibrary::UpdateVideoTag(const CVariant &parameterObject, CVideoInfoTa
     details.SetTrailer(parameterObject["trailer"].asString());
   if (ParameterNotNull(parameterObject, "tagline"))
     details.SetTagLine(parameterObject["tagline"].asString());
-  if (ParameterNotNull(parameterObject, "status"))
-    details.SetStatus(parameterObject["status"].asString());
   if (ParameterNotNull(parameterObject, "plotoutline"))
     details.SetPlotOutline(parameterObject["plotoutline"].asString());
 
diff --git a/xbmc/interfaces/json-rpc/schema/methods.json b/xbmc/interfaces/json-rpc/schema/methods.json
index 8f4a4b9..965bf70 100644
--- a/xbmc/interfaces/json-rpc/schema/methods.json
+++ b/xbmc/interfaces/json-rpc/schema/methods.json
@@ -1501,8 +1501,7 @@
       { "name": "userrating", "$ref": "Optional.Integer" },
       { "name": "ratings", "$ref": "Video.Ratings" },
       { "name": "dateadded", "$ref": "Optional.String" },
-      { "name": "runtime", "$ref": "Optional.Integer", "description": "Runtime in seconds" },
-      { "name": "status", "$ref": "Optional.String" }
+      { "name": "runtime", "$ref": "Optional.Integer", "description": "Runtime in seconds" }
     ],
     "returns": "string"
   },
diff --git a/xbmc/interfaces/json-rpc/schema/types.json b/xbmc/interfaces/json-rpc/schema/types.json
index c7211d9..106d23a 100644
--- a/xbmc/interfaces/json-rpc/schema/types.json
+++ b/xbmc/interfaces/json-rpc/schema/types.json
@@ -1004,7 +1004,7 @@
       "enum": [ "title", "plot", "plotoutline", "genre", "playcount",
                 "resume", "channel", "starttime","endtime", "runtime",
                 "lifetime", "icon", "art", "streamurl", "file",
-                "directory", "radio" ]
+                "directory" ]
     }
   },
   "PVR.Details.Recording": {
@@ -1026,8 +1026,7 @@
       "art": { "$ref": "Media.Artwork" },
       "streamurl": { "type": "string" },
       "file": { "type": "string" },
-      "directory": { "type": "string" },
-      "radio": { "type": "boolean" }
+      "directory": { "type": "string" }
     }
   },
   "Textures.Details.Size": {
diff --git a/xbmc/interfaces/json-rpc/schema/version.txt b/xbmc/interfaces/json-rpc/schema/version.txt
index 5f84a81..758bb9c 100644
--- a/xbmc/interfaces/json-rpc/schema/version.txt
+++ b/xbmc/interfaces/json-rpc/schema/version.txt
@@ -1 +1 @@
-7.12.0
+7.10.0
diff --git a/xbmc/interfaces/legacy/Addon.cpp b/xbmc/interfaces/legacy/Addon.cpp
index f869970..a9e80b1 100644
--- a/xbmc/interfaces/legacy/Addon.cpp
+++ b/xbmc/interfaces/legacy/Addon.cpp
@@ -37,7 +37,7 @@ namespace XBMCAddon
 
     String Addon::getAddonVersion() { return languageHook == NULL ? emptyString : languageHook->GetAddonVersion(); }
 
-    Addon::Addon(const char* cid)
+    Addon::Addon(const char* cid, bool installed /* = true */)
     {
       String id(cid ? cid : emptyString);
 
@@ -50,7 +50,15 @@ namespace XBMCAddon
       if (id.empty())
         throw AddonException("No valid addon id could be obtained. None was passed and the script wasn't executed in a normal xbmc manner.");
 
-      if (!ADDON::CAddonMgr::GetInstance().GetAddon(id.c_str(), pAddon))
+      bool success = ADDON::CAddonMgr::GetInstance().GetAddon(id.c_str(), pAddon);
+      if (!success && !installed)
+      {
+        CAddonDatabase addondb;
+        addondb.Open();
+        success = addondb.GetAddon(id, pAddon);
+      }
+
+      if (!success)
         throw AddonException("Unknown addon id '%s'.", id.c_str());
 
       CAddonMgr::GetInstance().AddToUpdateableAddons(pAddon);
@@ -63,16 +71,26 @@ namespace XBMCAddon
 
     String Addon::getLocalizedString(int id)
     {
+      AddonPtr temp;
+      if (!ADDON::CAddonMgr::GetInstance().GetAddon(pAddon->ID(), temp))
+        return ""; // Can't get a string for an addon that isn't installed
       return g_localizeStrings.GetAddonString(pAddon->ID(), id);
     }
 
     String Addon::getSetting(const char* id)
     {
+      AddonPtr temp;
+      if (!ADDON::CAddonMgr::GetInstance().GetAddon(pAddon->ID(), temp))
+        return "";
       return pAddon->GetSetting(id);
     }
 
     void Addon::setSetting(const char* id, const String& value)
     {
+      AddonPtr temp;
+      if (!ADDON::CAddonMgr::GetInstance().GetAddon(pAddon->ID(), temp))
+        return;
+
       DelayedCallGuard dcguard(languageHook);
       ADDON::AddonPtr addon(pAddon);
       bool save=true;
@@ -99,6 +117,10 @@ namespace XBMCAddon
 
     void Addon::openSettings()
     {
+      AddonPtr temp;
+      if (!ADDON::CAddonMgr::GetInstance().GetAddon(pAddon->ID(), temp))
+        return;
+
       DelayedCallGuard dcguard(languageHook);
       // show settings dialog
       ADDON::AddonPtr addon(pAddon);
@@ -135,6 +157,22 @@ namespace XBMCAddon
         return ADDON::TranslateType(pAddon->Type());
       else if (strcmpi(id, "version") == 0)
         return pAddon->Version().asString();
+      else if (strcmpi(id, "platforms") == 0)
+      {
+        InfoMap::const_iterator it;
+        if ((it = pAddon->Props().extrainfo.find("platforms")) != pAddon->Props().extrainfo.end())
+          return String(it->second.c_str());
+        else
+          return String();
+      }
+      else if (strcmpi(id, "extensions") == 0)
+      {
+        InfoMap::const_iterator it;
+        if ((it = pAddon->Props().extrainfo.find("extensions")) != pAddon->Props().extrainfo.end())
+          return String(it->second.c_str());
+        else
+          return String();
+      }
       else
         throw AddonException("'%s' is an invalid Id", id);
     }
diff --git a/xbmc/interfaces/legacy/Addon.h b/xbmc/interfaces/legacy/Addon.h
index f1f6921..fa5a55f 100644
--- a/xbmc/interfaces/legacy/Addon.h
+++ b/xbmc/interfaces/legacy/Addon.h
@@ -35,9 +35,10 @@ namespace XBMCAddon
     /**
      * Addon class.
      * 
-     * Addon([id]) -- Creates a new Addon class.
+     * Addon([id, installed]) -- Creates a new Addon class.
      * 
      * id          : [opt] string - id of the addon as specified in addon.xml
+     * installed   : [opt] boolean - False to use an uninstalled addon (default=True)
      * 
      * *Note, specifying the addon id is not needed.\n
      *  Important however is that the addon folder has the same name as the addon id provided in addon.xml.\n
@@ -59,9 +60,10 @@ namespace XBMCAddon
       /**
        * Addon class.
        * 
-       * Addon([id]) -- Creates a new Addon class.
+       * Addon([id, installed]) -- Creates a new Addon class.
        * 
        * id          : [opt] string - id of the addon as specified in addon.xml\n
+       * installed   : [opt] boolean - False to use an uninstalled addon (default=True)
        * 
        * *Note, specifying the addon id is not needed.\n
        *  Important however is that the addon folder has the same name as the addon id provided in addon.xml.\n
@@ -71,7 +73,7 @@ namespace XBMCAddon
        *  - self.Addon = xbmcaddon.Addon()
        *  - self.Addon = xbmcaddon.Addon('script.foo.bar')
        */
-      Addon(const char* id = NULL);
+      Addon(const char* id = NULL, bool installed = true);
 
       virtual ~Addon();
 
@@ -122,7 +124,9 @@ namespace XBMCAddon
        * id        : string - id of the property that the module needs to access.
        * 
        * *Note, choices are (author, changelog, description, disclaimer, fanart. icon, id, name, path,\n
-       *                     profile, stars, summary, type, version)
+       *                     profile, stars, summary, type, version, platforms, extensions)
+       * 
+       * *Note, platforms and extensions are only available for kodi.gameclient addons, and "" otherwise
        * 
        * example:
        *   - version = self.Addon.getAddonInfo('version')
diff --git a/xbmc/interfaces/legacy/Dialog.cpp b/xbmc/interfaces/legacy/Dialog.cpp
index 2345b84..f36c400 100644
--- a/xbmc/interfaces/legacy/Dialog.cpp
+++ b/xbmc/interfaces/legacy/Dialog.cpp
@@ -35,9 +35,6 @@
 #include "WindowException.h"
 #include "messaging/ApplicationMessenger.h"
 #include "Dialog.h"
-#ifdef TARGET_POSIX
-#include "linux/XTimeUtils.h"
-#endif
 
 using namespace KODI::MESSAGING;
 
diff --git a/xbmc/interfaces/legacy/ListItem.cpp b/xbmc/interfaces/legacy/ListItem.cpp
index 09c9c3d..858f902 100644
--- a/xbmc/interfaces/legacy/ListItem.cpp
+++ b/xbmc/interfaces/legacy/ListItem.cpp
@@ -27,6 +27,7 @@
 #include "video/VideoInfoTag.h"
 #include "music/tags/MusicInfoTag.h"
 #include "pictures/PictureInfoTag.h"
+#include "games/tags/GameInfoTag.h"
 #include "utils/log.h"
 #include "utils/Variant.h"
 #include "utils/StringUtils.h"
@@ -470,13 +471,6 @@ namespace XBMCAddon
             item->GetMusicInfoTag()->SetMusicBrainzAlbumArtistID(StringUtils::Split(value, g_advancedSettings.m_musicItemSeparator));
           else if (key == "comment")
             item->GetMusicInfoTag()->SetComment(value);
-          else if (key == "mediatype")
-          {
-            if (CMediaTypes::IsValidMediaType(value))
-              item->GetMusicInfoTag()->SetType(value);
-            else
-              CLog::Log(LOGWARNING, "Invalid media type \"%s\"", value.c_str());
-          }
           else if (key == "date")
           {
             if (strlen(value.c_str()) == 10)
@@ -532,6 +526,31 @@ namespace XBMCAddon
           }
         }
       }
+      else if (strcmpi(type, "game") == 0)
+      {
+        for (InfoLabelDict::const_iterator it = infoLabels.begin(); it != infoLabels.end(); it++)
+        {
+          String key = it->first;
+          StringUtils::ToLower(key);
+
+          const InfoLabelValue& alt = it->second;
+          const String value(alt.which() == first ? alt.former() : emptyString);
+
+          if (key == "title")
+          {
+            item->m_strTitle = value;
+            item->GetGameInfoTag()->SetTitle(value);
+          }
+          else if (key == "platform")
+            item->GetGameInfoTag()->SetPlatform(value);
+          else if (key == "region")
+            item->GetGameInfoTag()->SetRegion(value);
+          else if (key == "publisher")
+            item->GetGameInfoTag()->SetPublisher(value);
+          else if (key == "gameclient")
+            item->SetProperty("Addon.ID", value);
+        }
+      }
     } // end ListItem::setInfo
 
     void ListItem::addStreamInfo(const char* cType, const Properties& dictionary)
diff --git a/xbmc/interfaces/legacy/ListItem.h b/xbmc/interfaces/legacy/ListItem.h
index daa4d6d..0c82e84 100644
--- a/xbmc/interfaces/legacy/ListItem.h
+++ b/xbmc/interfaces/legacy/ListItem.h
@@ -241,11 +241,16 @@ namespace XBMCAddon
        *     - lyrics        : string (On a dark desert highway...)
        *     - playcount     : integer (2) - number of times this item has been played
        *     - lastplayed    : string (%Y-%m-%d %h:%m:%s = 2009-04-05 23:16:04)
-       *     - mediatype     : string - "music", "song", "album", "artist"
        * - Picture Values:
        *     - title         : string (In the last summer-1)
        *     - picturepath   : string (/home/username/pictures/img001.jpg)
        *     - exif*         : string (See CPictureInfoTag::TranslateString in PictureInfoTag.cpp for valid strings)
+       * - Game Value:
+       *     - title         : string (Pokemon Blue)
+       *     - platform      : string (Atari 2600) - see GameManager.cpp for a list of platforms
+       *     - region        : string (USA and Canada) - in the future, this might be a single letter (U/J)
+       *     - publisher     : string (Nintendo)
+       *     - gameclient    : string (gameclient.snes9x.next)
        * 
        * example:\n
        *   - self.list.getSelectedItem().setInfo('video', { 'genre': 'Comedy' })n\n
diff --git a/xbmc/interfaces/legacy/ModuleXbmc.cpp b/xbmc/interfaces/legacy/ModuleXbmc.cpp
index d7e65ab..737b86f 100644
--- a/xbmc/interfaces/legacy/ModuleXbmc.cpp
+++ b/xbmc/interfaces/legacy/ModuleXbmc.cpp
@@ -62,10 +62,6 @@
 
 using namespace KODI::MESSAGING;
 
-#ifdef TARGET_POSIX
-#include "linux/XMemUtils.h"
-#endif
-
 namespace XBMCAddon
 {
 
diff --git a/xbmc/interfaces/python/PythonInvoker.cpp b/xbmc/interfaces/python/PythonInvoker.cpp
index e3788a0..4cbcac3 100644
--- a/xbmc/interfaces/python/PythonInvoker.cpp
+++ b/xbmc/interfaces/python/PythonInvoker.cpp
@@ -49,9 +49,6 @@
 #include "utils/log.h"
 #include "utils/StringUtils.h"
 #include "utils/URIUtils.h"
-#ifdef TARGET_POSIX
-#include "linux/XTimeUtils.h"
-#endif
 
 #ifdef TARGET_WINDOWS
 #pragma comment(lib, "python27.lib")
diff --git a/xbmc/linux/PlatformDefs.h b/xbmc/linux/PlatformDefs.h
index cd74de8..1582d20 100644
--- a/xbmc/linux/PlatformDefs.h
+++ b/xbmc/linux/PlatformDefs.h
@@ -129,6 +129,8 @@
 
 #ifdef TARGET_POSIX
 
+#define XXLog(a,b) printf("%s", (b))
+
 #ifndef INSTALL_PATH
 #define INSTALL_PATH    "/usr/share/xbmc"
 #endif
@@ -177,6 +179,10 @@
 #define _declspec(X)
 #define __declspec(X)
 
+#define __try try
+#define EXCEPTION_EXECUTE_HANDLER ...
+//NOTE: dont try to define __except because it breaks g++ (already uses it).
+
 struct CXHandle; // forward declaration
 typedef CXHandle* HANDLE;
 
@@ -187,11 +193,16 @@ typedef unsigned int  DWORD;
 typedef unsigned short  WORD;
 typedef unsigned char   BYTE;
 typedef char        CHAR;
+typedef unsigned char UCHAR;
 typedef wchar_t     WCHAR;
 typedef int         BOOL;
+typedef BYTE        BOOLEAN;
+typedef short       SHORT;
+typedef unsigned short  USHORT;
 typedef int         INT;
 typedef unsigned int  UINT;
 // typedef int INT32;              // unused; must match Xmd.h but why bother
+typedef unsigned int  UINT32;
 typedef long long     INT64;
 typedef unsigned long long    UINT64;
 typedef long        LONG;
@@ -201,6 +212,7 @@ typedef UInt32          ULONG;
 #else
 typedef unsigned long   ULONG;
 #endif
+typedef float         FLOAT;
 typedef size_t        SIZE_T;
 typedef void*         PVOID;
 typedef void*         LPVOID;
@@ -208,6 +220,11 @@ typedef void*         LPVOID;
 #define INVALID_HANDLE_VALUE     ((HANDLE)~0U)
 typedef HANDLE        HDC;
 typedef void*       HWND;
+#if defined(TARGET_DARWIN_OSX)
+typedef SInt32      HRESULT;
+#else
+typedef LONG        HRESULT;
+#endif
 typedef BYTE*       LPBYTE;
 typedef DWORD*        LPDWORD;
 typedef CONST CHAR*   LPCSTR;
@@ -222,11 +239,14 @@ typedef LPCWSTR       LPCTSTR;
 typedef LPCSTR      LPCTSTR;
 #endif
 typedef unsigned __int64 ULONGLONG;
+typedef long        LONG_PTR;
 typedef unsigned long   ULONG_PTR;
 typedef ULONG_PTR     DWORD_PTR;
+typedef __int64     __time64_t;
 typedef intptr_t (*FARPROC)(void);
 
 #define MAXWORD   0xffff
+#define MAXDWORD  0xffffffff
 
 typedef DWORD LCID;
 typedef WORD* LPWORD;
@@ -410,6 +430,21 @@ typedef struct _MEMORYSTATUSEX
   uint64_t ullAvailVirtual;
 } MEMORYSTATUSEX, *LPMEMORYSTATUSEX;
 
+// Common HRESULT values
+#ifndef NOERROR
+#define NOERROR           (0L)
+#endif
+#ifndef S_OK
+#define S_OK            (0L)
+#endif
+#ifndef E_FAIL
+#define E_FAIL            (0x80004005L)
+#endif
+#ifndef E_OUTOFMEMORY
+#define E_OUTOFMEMORY         (0x8007000EL)
+#endif
+#define FAILED(Status)            ((HRESULT)(Status)<0)
+
 // Basic D3D stuff
 typedef struct _RECT {
   LONG left;
@@ -418,16 +453,97 @@ typedef struct _RECT {
   LONG bottom;
 } RECT, *PRECT;
 
+typedef DWORD D3DCOLOR;
+
 typedef enum _D3DFORMAT
 {
-  D3DFMT_A8R8G8B8     = 0x00000006,
+  D3DFMT_A8R8G8B8         = 0x00000006,
   D3DFMT_DXT1         = 0x0000000C,
   D3DFMT_DXT2         = 0x0000000E,
   D3DFMT_DXT4         = 0x0000000F,
-  D3DFMT_UNKNOWN      = 0xFFFFFFFF
+  D3DFMT_UNKNOWN          = 0xFFFFFFFF
 } D3DFORMAT;
 
+typedef enum D3DRESOURCETYPE
+{
+    D3DRTYPE_SURFACE = 1,
+    D3DRTYPE_VOLUME = 2,
+    D3DRTYPE_TEXTURE = 3,
+    D3DRTYPE_VOLUMETEXTURE = 4,
+    D3DRTYPE_CubeTexture = 5,
+    D3DRTYPE_VERTEXBUFFER = 6,
+    D3DRTYPE_INDEXBUFFER = 7,
+    D3DRTYPE_FORCE_DWORD = 0x7fffffff
+} D3DRESOURCETYPE, *LPD3DRESOURCETYPE;
+
+typedef enum D3DXIMAGE_FILEFORMAT
+{
+    D3DXIFF_BMP = 0,
+    D3DXIFF_JPG = 1,
+    D3DXIFF_TGA = 2,
+    D3DXIFF_PNG = 3,
+    D3DXIFF_DDS = 4,
+    D3DXIFF_PPM = 5,
+    D3DXIFF_DIB = 6,
+    D3DXIFF_HDR = 7,
+    D3DXIFF_PFM = 8,
+    D3DXIFF_FORCE_DWORD = 0x7fffffff
+} D3DXIMAGE_FILEFORMAT, *LPD3DXIMAGE_FILEFORMAT;
+
+typedef struct D3DXIMAGE_INFO {
+    UINT Width;
+    UINT Height;
+    UINT Depth;
+    UINT MipLevels;
+    D3DFORMAT Format;
+    D3DRESOURCETYPE ResourceType;
+    D3DXIMAGE_FILEFORMAT ImageFileFormat;
+} D3DXIMAGE_INFO, *LPD3DXIMAGE_INFO;
+
+typedef struct _D3DPRESENT_PARAMETERS_
+{
+    UINT                BackBufferWidth;
+    UINT                BackBufferHeight;
+    D3DFORMAT           BackBufferFormat;
+    UINT                BackBufferCount;
+    //D3DMULTISAMPLE_TYPE MultiSampleType;
+    //D3DSWAPEFFECT       SwapEffect;
+    //HWND                hDeviceWindow;
+    BOOL                Windowed;
+    BOOL                EnableAutoDepthStencil;
+    D3DFORMAT           AutoDepthStencilFormat;
+    DWORD               Flags;
+    UINT                FullScreen_RefreshRateInHz;
+    UINT                FullScreen_PresentationInterval;
+    //D3DSurface         *BufferSurfaces[3];
+    //D3DSurface         *DepthStencilSurface;
+} D3DPRESENT_PARAMETERS;
+
+typedef enum D3DPRIMITIVETYPE
+{
+    D3DPT_POINTLIST = 1,
+    D3DPT_LINELIST = 2,
+    D3DPT_LINESTRIP = 3,
+    D3DPT_TRIANGLELIST = 4,
+    D3DPT_TRIANGLESTRIP = 5,
+    D3DPT_TRIANGLEFAN = 6,
+    D3DPT_FORCE_DWORD = 0x7fffffff
+} D3DPRIMITIVETYPE, *LPD3DPRIMITIVETYPE;
+
+typedef struct _D3DMATRIX {
+    union {
+        struct {
+            float        _11, _12, _13, _14;
+            float        _21, _22, _23, _24;
+            float        _31, _32, _33, _34;
+            float        _41, _42, _43, _44;
+        } u;
+        float m[4][4];
+    };
+} D3DMATRIX;
+
 // Misc stuff found in the code, not really important
+#define PAGE_READONLY     0x02
 #define PAGE_READWRITE    0x04
 #define MAXULONG_PTR    ((ULONG) 0xffffffff)
 
@@ -484,5 +600,64 @@ WORD    cbSize;
 #define WAVE_FORMAT_IEEE_FLOAT        0x0003
 #define WAVE_FORMAT_EXTENSIBLE        0xFFFE
 
+#define SPEAKER_FRONT_LEFT            0x00001
+#define SPEAKER_FRONT_RIGHT           0x00002
+#define SPEAKER_FRONT_CENTER          0x00004
+#define SPEAKER_LOW_FREQUENCY         0x00008
+#define SPEAKER_BACK_LEFT             0x00010
+#define SPEAKER_BACK_RIGHT            0x00020
+#define SPEAKER_FRONT_LEFT_OF_CENTER  0x00040
+#define SPEAKER_FRONT_RIGHT_OF_CENTER 0x00080
+#define SPEAKER_BACK_CENTER           0x00100
+#define SPEAKER_SIDE_LEFT             0x00200
+#define SPEAKER_SIDE_RIGHT            0x00400
+#define SPEAKER_TOP_CENTER            0x00800
+#define SPEAKER_TOP_FRONT_LEFT        0x01000
+#define SPEAKER_TOP_FRONT_CENTER      0x02000
+#define SPEAKER_TOP_FRONT_RIGHT       0x04000
+#define SPEAKER_TOP_BACK_LEFT         0x08000
+#define SPEAKER_TOP_BACK_CENTER       0x10000
+#define SPEAKER_TOP_BACK_RIGHT        0x20000
+
+typedef struct tGUID
+{
+  DWORD Data1;
+  WORD  Data2, Data3;
+  BYTE  Data4[8];
+} __attribute__((__packed__)) GUID;
+
+static const GUID KSDATAFORMAT_SUBTYPE_UNKNOWN = {
+  WAVE_FORMAT_UNKNOWN,
+  0x0000, 0x0000,
+  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
+};
+
+static const GUID KSDATAFORMAT_SUBTYPE_PCM = {
+  WAVE_FORMAT_PCM,
+  0x0000, 0x0010,
+  {0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
+};
+
+static const GUID KSDATAFORMAT_SUBTYPE_IEEE_FLOAT = {
+  WAVE_FORMAT_IEEE_FLOAT,
+  0x0000, 0x0010,
+  {0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
+};
+
+typedef struct tWAVEFORMATEXTENSIBLE
+{
+  WAVEFORMATEX Format;
+  union
+  {
+    WORD wValidBitsPerSample;
+    WORD wSamplesPerBlock;
+    WORD wReserved;
+  } Samples;
+  DWORD dwChannelMask;
+  GUID SubFormat;
+} __attribute__((__packed__)) WAVEFORMATEXTENSIBLE;
+
+
+
 #endif
 
diff --git a/xbmc/linux/PlatformInclude.h b/xbmc/linux/PlatformInclude.h
index 57bdd20..3f63dbd 100644
--- a/xbmc/linux/PlatformInclude.h
+++ b/xbmc/linux/PlatformInclude.h
@@ -21,4 +21,9 @@
  */
 
 #include "PlatformDefs.h"
+#include "XHandlePublic.h"
+#include "XFileUtils.h"
+#include "XTimeUtils.h"
+#include "XMemUtils.h"
+#include "ConvUtils.h"
 
diff --git a/xbmc/linux/XFileUtils.cpp b/xbmc/linux/XFileUtils.cpp
index 78789553..84f06ae 100644
--- a/xbmc/linux/XFileUtils.cpp
+++ b/xbmc/linux/XFileUtils.cpp
@@ -21,6 +21,7 @@
 #include "system.h"
 #include "PlatformInclude.h"
 #include "XFileUtils.h"
+#include "XTimeUtils.h"
 #include "filesystem/SpecialProtocol.h"
 #include "utils/StringUtils.h"
 
@@ -49,6 +50,147 @@
 #include "storage/cdioSupport.h"
 
 #include "utils/log.h"
+#include "utils/RegExp.h"
+#include "utils/AliasShortcutUtils.h"
+
+HANDLE FindFirstFile(LPCSTR szPath,LPWIN32_FIND_DATA lpFindData)
+{
+  if (lpFindData == NULL || szPath == NULL)
+    return NULL;
+
+  std::string strPath(szPath);
+
+  if (IsAliasShortcut(strPath, false))
+    TranslateAliasShortcut(strPath);
+
+  if (strPath.empty())
+    return INVALID_HANDLE_VALUE;
+
+  StringUtils::Replace(strPath, '\\','/');
+
+  // if the file name is a directory then we add a * to look for all files in this directory
+#if defined(TARGET_DARWIN) || defined(TARGET_FREEBSD) || defined(TARGET_ANDROID)
+  DIR *testDir = opendir(strPath.c_str());
+#else
+  DIR *testDir = opendir(szPath);
+#endif
+  if (testDir)
+  {
+    strPath += "/*";
+    closedir(testDir);
+  }
+
+  size_t nFilePos = strPath.rfind(XBMC_FILE_SEP);
+
+  std::string strDir = ".";
+  std::string strFiles = strPath;
+
+  if (nFilePos > 0)
+  {
+    strDir = strPath.substr(0,nFilePos);
+    strFiles = strPath.substr(nFilePos + 1);
+  }
+
+  if (strFiles == "*.*")
+     strFiles = "*";
+
+  strFiles = '^' + strFiles + '$';
+  StringUtils::Replace(strFiles, ".","\\.");
+  StringUtils::Replace(strFiles, "*",".*");
+  StringUtils::Replace(strFiles, "?",".");
+
+  StringUtils::ToLower(strFiles);  // Do we really want this case insensitive?
+  CRegExp re(true);
+
+  if (!re.RegComp(strFiles.c_str()))
+    return(INVALID_HANDLE_VALUE);
+
+  struct dirent **namelist = NULL;
+#if defined(TARGET_ANDROID)
+  // android is more strict with the sort function. Let's hope it is implemented correctly.
+  typedef int (*sortFunc)(const struct dirent ** a, const struct dirent **b);
+  int n = scandir(strDir.c_str(), &namelist, 0, (sortFunc)alphasort);
+#else
+  int n = scandir(strDir.c_str(), &namelist, 0, alphasort);
+#endif
+
+  CXHandle *pHandle = new CXHandle(CXHandle::HND_FIND_FILE);
+    pHandle->m_FindFileDir = strDir;
+
+  while (n-- > 0)
+  {
+    std::string strComp(namelist[n]->d_name);
+    StringUtils::ToLower(strComp);
+
+    if (re.RegFind(strComp.c_str()) >= 0)
+      pHandle->m_FindFileResults.push_back(namelist[n]->d_name);
+    free(namelist[n]);
+  }
+  free(namelist);
+
+  if (pHandle->m_FindFileResults.empty())
+  {
+    delete pHandle;
+    return INVALID_HANDLE_VALUE;
+  }
+
+  FindNextFile(pHandle, lpFindData);
+
+  return pHandle;
+}
+
+BOOL   FindNextFile(HANDLE hHandle, LPWIN32_FIND_DATA lpFindData)
+{
+  if (lpFindData == NULL || hHandle == NULL || hHandle->GetType() != CXHandle::HND_FIND_FILE)
+    return FALSE;
+
+  if ((unsigned int) hHandle->m_nFindFileIterator >= hHandle->m_FindFileResults.size())
+    return FALSE;
+
+  std::string strFileName = hHandle->m_FindFileResults[hHandle->m_nFindFileIterator++];
+  std::string strFileNameTest = hHandle->m_FindFileDir + strFileName;
+
+  if (IsAliasShortcut(strFileNameTest, false))
+    TranslateAliasShortcut(strFileNameTest);
+
+  struct stat64 fileStat;
+  memset(&fileStat, 0, sizeof(fileStat));
+  stat64(strFileNameTest.c_str(), &fileStat);
+
+  bool bIsDir = false;
+  if (S_ISDIR(fileStat.st_mode))
+  {
+    bIsDir = true;
+  }
+
+  memset(lpFindData,0,sizeof(WIN32_FIND_DATA));
+
+  lpFindData->dwFileAttributes = FILE_ATTRIBUTE_NORMAL;
+  strcpy(lpFindData->cFileName, strFileName.c_str());
+
+  if (bIsDir)
+    lpFindData->dwFileAttributes |= FILE_ATTRIBUTE_DIRECTORY;
+
+  if (strFileName[0] == '.')
+    lpFindData->dwFileAttributes |= FILE_ATTRIBUTE_HIDDEN;
+
+  if (access(strFileName.c_str(), R_OK) == 0 && access(strFileName.c_str(), W_OK) != 0)
+    lpFindData->dwFileAttributes |= FILE_ATTRIBUTE_READONLY;
+
+  TimeTToFileTime(fileStat.st_ctime, &lpFindData->ftCreationTime);
+  TimeTToFileTime(fileStat.st_atime, &lpFindData->ftLastAccessTime);
+  TimeTToFileTime(fileStat.st_mtime, &lpFindData->ftLastWriteTime);
+
+  lpFindData->nFileSizeHigh = (DWORD)(fileStat.st_size >> 32);
+  lpFindData->nFileSizeLow =  (DWORD)fileStat.st_size;
+
+  return TRUE;
+}
+
+BOOL FindClose(HANDLE hFindFile)
+{
+  return CloseHandle(hFindFile);
+}
 
 HANDLE CreateFile(LPCTSTR lpFileName, DWORD dwDesiredAccess,
   DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition,
@@ -164,6 +306,181 @@ HANDLE CreateFile(LPCTSTR lpFileName, DWORD dwDesiredAccess,
   return result;
 }
 
+//
+// it is important that this method will not call CLog because it uses it.
+//
+BOOL DeleteFile(LPCTSTR lpFileName)
+{
+  if (unlink(lpFileName) == 0)
+    return 1;
+
+  if (errno == EACCES)
+  {
+    CLog::Log(LOGERROR,"%s - cant delete file, trying to change mode <%s>", __FUNCTION__, lpFileName);
+    if (chmod(lpFileName, 0600) != 0)
+    {
+      CLog::Log(LOGERROR,"%s - failed to change mode <%s>", __FUNCTION__, lpFileName);
+      return 0;
+    }
+
+    CLog::Log(LOGDEBUG,"%s - reattempt to delete file",__FUNCTION__);
+
+    if (unlink(lpFileName) == 0)
+      return 1;
+  }
+  else if (errno == ENOENT)
+  {
+    std::string strLower(lpFileName);
+    StringUtils::ToLower(strLower);
+    CLog::Log(LOGERROR,"%s - cant delete file <%s>. trying lower case <%s>", __FUNCTION__, lpFileName, strLower.c_str());
+    if (unlink(strLower.c_str()) == 0)
+    {
+      CLog::Log(LOGDEBUG,"%s - successfuly removed file <%s>", __FUNCTION__, strLower.c_str());
+      return 1;
+    }
+  }
+
+  return 0;
+}
+
+//
+// it is important that this method will not call CLog because it uses it.
+//
+BOOL MoveFile(LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName)
+{
+  if (rename(lpExistingFileName, lpNewFileName) == 0)
+    return 1;
+
+  if (errno == EACCES)
+  {
+    CLog::Log(LOGERROR,"%s - cant move file, trying to change mode <%s>", __FUNCTION__, lpExistingFileName);
+    if (chmod(lpExistingFileName, 0600) != 0)
+    {
+      CLog::Log(LOGERROR,"%s - failed to change mode <%s>", __FUNCTION__, lpExistingFileName);
+      return 0;
+    }
+
+    CLog::Log(LOGDEBUG,"%s - reattempt to move file",__FUNCTION__);
+
+    if (rename(lpExistingFileName, lpNewFileName) == 0)
+      return 1;
+  }
+  else if (errno == ENOENT)
+  {
+    std::string strLower(lpExistingFileName);
+    StringUtils::ToLower(strLower);
+    CLog::Log(LOGERROR,"%s - cant move file <%s>. trying lower case <%s>", __FUNCTION__, lpExistingFileName, strLower.c_str());
+    if (rename(strLower.c_str(), lpNewFileName) == 0) {
+      CLog::Log(LOGDEBUG,"%s - successfuly moved file <%s>", __FUNCTION__, strLower.c_str());
+      return 1;
+    }
+  }
+
+  // try the stupid
+  if (CopyFile(lpExistingFileName,lpNewFileName,TRUE))
+  {
+    if (DeleteFile(lpExistingFileName))
+      return 1;
+    // failed to remove original file - delete the copy we made
+    DeleteFile(lpNewFileName);
+  }
+
+  return 0;
+}
+
+BOOL CopyFile(LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName, BOOL bFailIfExists)
+{
+  // If the destination file exists and we should fail...guess what? we fail!
+  struct stat destStat;
+  bool isDestExists = (stat(lpNewFileName, &destStat) == 0);
+  if (isDestExists && bFailIfExists)
+  {
+    return 0;
+  }
+
+  std::string strResultFile(lpExistingFileName);
+
+  // Open the files
+  int sf = open(lpExistingFileName, O_RDONLY);
+  if (sf == -1 && errno == ENOENT) // important to check reason for fail. only if its "file does not exist" shall we try lower case.
+  {
+    std::string strLower(lpExistingFileName);
+    StringUtils::ToLower(strLower);
+
+    // failed to open file. maybe due to case sensitivity. try opening the same name in lower case.
+    CLog::Log(LOGWARNING,"%s, cant open file <%s>. trying to use lowercase <%s>", __FUNCTION__, lpExistingFileName, strLower.c_str());
+    sf = open(strLower.c_str(), O_RDONLY);
+    if (sf != -1)
+    {
+      CLog::Log(LOGDEBUG,"%s, successfuly opened <%s>", __FUNCTION__, strLower.c_str());
+      strResultFile = strLower;
+    }
+  }
+
+  if (sf == -1)
+  {
+    CLog::Log(LOGERROR,"%s - cant open source file <%s>", __FUNCTION__, lpExistingFileName);
+    return 0;
+  }
+
+  int df = open(lpNewFileName, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP);
+  if (df == -1)
+  {
+    if (errno == EACCES) {
+      CLog::Log(LOGWARNING,"%s - cant write to dest file, trying to change mode <%s>", __FUNCTION__, lpNewFileName);
+      if (chmod(lpNewFileName, 0600) != 0)
+      {
+        CLog::Log(LOGWARNING,"%s - failed to change mode <%s>", __FUNCTION__, lpNewFileName);
+        close(sf);
+        return 0;
+      }
+
+      CLog::Log(LOGDEBUG,"%s - reattempt to open dest file",__FUNCTION__);
+
+      df = open(lpNewFileName, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP);
+      if (df == -1)
+      {
+        CLog::Log(LOGERROR,"%s - cant open dest file <%s>", __FUNCTION__, lpNewFileName);
+        close(sf);
+        return 0;
+      }
+
+      CLog::Log(LOGDEBUG,"%s - successfuly opened dest file",__FUNCTION__);
+
+    }
+  }
+
+  // Read and write chunks of 16K
+  char buf[16384];
+  int64_t bytesRead = 1;
+  int64_t bytesWritten = 1;
+
+  if (sf != -1 && df != -1)
+  {
+    while (bytesRead > 0 && bytesWritten > 0)
+    {
+      bytesRead = read(sf, buf, sizeof(buf));
+      if (bytesRead > 0)
+        bytesWritten = write(df, buf, bytesRead);
+    }
+  }
+  else
+  {
+    bytesRead = -1;
+    bytesWritten = -1;
+  }
+
+  // Done
+  if (sf != -1)  
+    close(sf);
+  if (df != -1)
+    close(df);
+
+  if (bytesRead == -1 || bytesWritten == -1)
+    return 0;
+  return 1;
+}
+
 BOOL ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead,
   LPDWORD lpNumberOfBytesRead, LPVOID lpOverlapped)
 {
@@ -202,6 +519,41 @@ BOOL WriteFile(HANDLE hFile, const void * lpBuffer, DWORD nNumberOfBytesToWrite,
   return 1;
 }
 
+BOOL   CreateDirectory(LPCTSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
+{
+  if (mkdir(lpPathName, 0755) == 0)
+    return 1;
+
+  if (errno == ENOENT)
+  {
+    CLog::Log(LOGWARNING,"%s, cant create dir <%s>. trying lower case.", __FUNCTION__, lpPathName);
+    std::string strLower(lpPathName);
+    StringUtils::ToLower(strLower);
+
+    if (mkdir(strLower.c_str(), 0755) == 0)
+      return 1;
+  }
+
+  return 0;
+}
+
+BOOL   RemoveDirectory(LPCTSTR lpPathName)
+{
+  if (rmdir(lpPathName) == 0)
+    return 1;
+
+  if (errno == ENOENT)
+  {
+    CLog::Log(LOGWARNING,"%s, cant remove dir <%s>. trying lower case.", __FUNCTION__, lpPathName);
+    std::string strLower(lpPathName);
+    StringUtils::ToLower(strLower);
+
+    if (rmdir(strLower.c_str()) == 0 || errno == ENOENT)
+      return 1;
+  }
+  return 0;
+}
+
 DWORD  SetFilePointer(HANDLE hFile, int32_t lDistanceToMove,
                       int32_t *lpDistanceToMoveHigh, DWORD dwMoveMethod)
 {
@@ -288,6 +640,29 @@ DWORD GetTimeZoneInformation( LPTIME_ZONE_INFORMATION lpTimeZoneInformation )
   return TIME_ZONE_ID_UNKNOWN;
 }
 
+BOOL SetEndOfFile(HANDLE hFile)
+{
+  if (hFile == NULL)
+    return false;
+
+  // get the current offset
+#if defined(TARGET_DARWIN) || defined(TARGET_FREEBSD)
+  off64_t currOff = lseek(hFile->fd, 0, SEEK_CUR);
+#else
+  off64_t currOff = lseek64(hFile->fd, 0, SEEK_CUR);
+#endif
+  if (currOff >= 0)
+    return (ftruncate(hFile->fd, currOff) == 0);
+
+  return false;
+}
+
+DWORD SleepEx( DWORD dwMilliseconds,  BOOL bAlertable)
+{
+  usleep(dwMilliseconds * 1000);
+  return 0;
+}
+
 BOOL SetFilePointerEx(  HANDLE hFile,
             LARGE_INTEGER liDistanceToMove,
             PLARGE_INTEGER lpNewFilePointer,
@@ -314,6 +689,31 @@ BOOL SetFilePointerEx(  HANDLE hFile,
   return true;
 }
 
+BOOL GetFileSizeEx( HANDLE hFile, PLARGE_INTEGER lpFileSize)
+{
+  if (hFile == NULL || lpFileSize == NULL) {
+    return false;
+  }
+
+
+  struct stat64 fileStat;
+  if (fstat64(hFile->fd, &fileStat) != 0)
+    return false;
+
+  lpFileSize->QuadPart = fileStat.st_size;
+  return true;
+}
+
+BOOL FlushFileBuffers( HANDLE hFile )
+{
+  if (hFile == NULL)
+  {
+    return 0;
+  }
+
+  return (fsync(hFile->fd) == 0);
+}
+
 int _fstat64(int fd, struct __stat64 *buffer)
 {
   if (buffer == NULL)
@@ -330,5 +730,60 @@ int _stat64(   const char *path,   struct __stat64 *buffer )
 
   return stat64(path, buffer);
 }
+
+DWORD  GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh)
+{
+  if (hFile == NULL)
+  {
+    return 0;
+  }
+
+
+  struct stat64 fileStat;
+  if (fstat64(hFile->fd, &fileStat) != 0)
+    return 0;
+
+  if (lpFileSizeHigh)
+  {
+    *lpFileSizeHigh = (DWORD)(fileStat.st_size >> 32);
+  }
+
+  return (DWORD)fileStat.st_size;
+}
+
+DWORD  GetFileAttributes(LPCTSTR lpFileName)
+{
+  if (lpFileName == NULL)
+  {
+    return 0;
+  }
+
+  DWORD dwAttr = FILE_ATTRIBUTE_NORMAL;
+  DIR *tmpDir = opendir(lpFileName);
+  if (tmpDir)
+  {
+    dwAttr |= FILE_ATTRIBUTE_DIRECTORY;
+    closedir(tmpDir);
+  }
+
+  if (lpFileName[0] == '.')
+    dwAttr |= FILE_ATTRIBUTE_HIDDEN;
+
+  if (access(lpFileName, R_OK) == 0 && access(lpFileName, W_OK) != 0)
+    dwAttr |= FILE_ATTRIBUTE_READONLY;
+
+  return dwAttr;
+}
+
+DWORD  GetCurrentDirectory(DWORD nBufferLength, LPSTR lpBuffer)
+{
+  if (lpBuffer == NULL)
+    return 0;
+
+  if (getcwd(lpBuffer,nBufferLength) == NULL)
+    return 0;
+
+    return strlen(lpBuffer);
+}
 #endif
 
diff --git a/xbmc/linux/XFileUtils.h b/xbmc/linux/XFileUtils.h
index 8ca5005..9c4e658 100644
--- a/xbmc/linux/XFileUtils.h
+++ b/xbmc/linux/XFileUtils.h
@@ -23,22 +23,51 @@
 #include "PlatformDefs.h"
 #include "XHandlePublic.h"
 
+#ifdef TARGET_POSIX
+#define XBMC_FILE_SEP '/'
+#else
+#define XBMC_FILE_SEP '\\'
+#endif
+
+HANDLE FindFirstFile(LPCSTR,LPWIN32_FIND_DATA);
+
+BOOL   FindNextFile(HANDLE,LPWIN32_FIND_DATA);
+BOOL   FindClose(HANDLE hFindFile);
+
 #define CreateFileA CreateFile
 HANDLE CreateFile(LPCTSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode,
             LPSECURITY_ATTRIBUTES lpSecurityAttributes,  DWORD dwCreationDisposition,
             DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
 
+BOOL   CopyFile(LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName, BOOL bFailIfExists);
+BOOL   DeleteFile(LPCSTR);
+BOOL   MoveFile(LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName);
+
 BOOL   WriteFile(HANDLE hFile, const void * lpBuffer, DWORD nNumberOfBytesToWrite,  LPDWORD lpNumberOfBytesWritten, LPVOID lpOverlapped);
 BOOL   ReadFile( HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, void* unsupportedlpOverlapped);
+BOOL   FlushFileBuffers(HANDLE hFile);
+
+BOOL   CreateDirectory(LPCTSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
+BOOL   RemoveDirectory(LPCTSTR lpPathName);
+DWORD  GetCurrentDirectory(DWORD nBufferLength, LPSTR lpBuffer);
 
 DWORD  SetFilePointer(HANDLE hFile, int32_t lDistanceToMove,
                       int32_t *lpDistanceToMoveHigh, DWORD dwMoveMethod);
 BOOL   SetFilePointerEx(HANDLE hFile, LARGE_INTEGER liDistanceToMove,PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod);
+BOOL   SetEndOfFile(HANDLE hFile);
 
+DWORD SleepEx( DWORD dwMilliseconds,  BOOL bAlertable);
 DWORD GetTimeZoneInformation( LPTIME_ZONE_INFORMATION lpTimeZoneInformation );
+DWORD  GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh);
+BOOL   GetFileSizeEx(HANDLE hFile, PLARGE_INTEGER lpFileSize);
 int    _stat64(const char *path, struct __stat64 *buffer);
+int    _stati64(const char *path,struct _stati64 *buffer);
 int _fstat64(int fd, struct __stat64 *buffer);
 
+DWORD  GetFileAttributes(LPCTSTR lpFileName);
+
+#define ERROR_ALREADY_EXISTS EEXIST
+
 // uses statfs
 BOOL GetDiskFreeSpaceEx(
   LPCTSTR lpDirectoryName,
diff --git a/xbmc/listproviders/DirectoryProvider.cpp b/xbmc/listproviders/DirectoryProvider.cpp
index f5457bc..9fb36f3 100644
--- a/xbmc/listproviders/DirectoryProvider.cpp
+++ b/xbmc/listproviders/DirectoryProvider.cpp
@@ -23,15 +23,12 @@
 #include <memory>
 #include <utility>
 
-#include "addons/GUIDialogAddonInfo.h"
-#include "ContextMenuManager.h"
 #include "FileItem.h"
 #include "filesystem/Directory.h"
 #include "filesystem/FavouritesDirectory.h"
 #include "guilib/GUIWindowManager.h"
 #include "interfaces/AnnouncementManager.h"
 #include "messaging/ApplicationMessenger.h"
-#include "music/dialogs/GUIDialogMusicInfo.h"
 #include "music/MusicThumbLoader.h"
 #include "pictures/PictureThumbLoader.h"
 #include "settings/Settings.h"
@@ -42,9 +39,6 @@
 #include "utils/Variant.h"
 #include "utils/XMLUtils.h"
 #include "video/VideoThumbLoader.h"
-#include "video/dialogs/GUIDialogVideoInfo.h"
-
-
 
 using namespace XFILE;
 using namespace ANNOUNCEMENT;
@@ -105,21 +99,21 @@ public:
   {
     if (item->IsVideo())
     {
-      initThumbLoader<CVideoThumbLoader>(InfoTagType::VIDEO);
-      return m_thumbloaders[InfoTagType::VIDEO];
+      initThumbLoader<CVideoThumbLoader>(VIDEO);
+      return m_thumbloaders[VIDEO];
     }
     if (item->IsAudio())
     {
-      initThumbLoader<CMusicThumbLoader>(InfoTagType::AUDIO);
-      return m_thumbloaders[InfoTagType::AUDIO];
+      initThumbLoader<CMusicThumbLoader>(AUDIO);
+      return m_thumbloaders[AUDIO];
     }
     if (item->IsPicture())
     {
-      initThumbLoader<CPictureThumbLoader>(InfoTagType::PICTURE);
-      return m_thumbloaders[InfoTagType::PICTURE];
+      initThumbLoader<CPictureThumbLoader>(PICTURE);
+      return m_thumbloaders[PICTURE];
     }
-    initThumbLoader<CProgramThumbLoader>(InfoTagType::PROGRAM);
-    return m_thumbloaders[InfoTagType::PROGRAM];
+    initThumbLoader<CProgramThumbLoader>(PROGRAM);
+    return m_thumbloaders[PROGRAM];
   }
 
   template<class CThumbLoaderClass>
@@ -225,9 +219,9 @@ void CDirectoryProvider::Announce(AnnouncementFlag flag, const char *sender, con
     // we don't need to refresh anything if there are no fitting
     // items in this list provider for the announcement flag
     if (((flag & VideoLibrary) &&
-         (std::find(m_itemTypes.begin(), m_itemTypes.end(), InfoTagType::VIDEO) == m_itemTypes.end())) ||
+         (std::find(m_itemTypes.begin(), m_itemTypes.end(), VIDEO) == m_itemTypes.end())) ||
         ((flag & AudioLibrary) &&
-         (std::find(m_itemTypes.begin(), m_itemTypes.end(), InfoTagType::AUDIO) == m_itemTypes.end())))
+         (std::find(m_itemTypes.begin(), m_itemTypes.end(), AUDIO) == m_itemTypes.end())))
       return;
 
     // if we're in a database transaction, don't bother doing anything just yet
@@ -312,31 +306,6 @@ bool CDirectoryProvider::OnClick(const CGUIListItemPtr &item)
   return false;
 }
 
-bool CDirectoryProvider::OnInfo(const CGUIListItemPtr& item)
-{
-  auto fileItem = std::static_pointer_cast<CFileItem>(item);
-
-  if (fileItem->HasAddonInfo())
-    return CGUIDialogAddonInfo::ShowForItem(fileItem);
-  else if (fileItem->HasVideoInfoTag())
-  {
-    CGUIDialogVideoInfo::ShowFor(*fileItem.get());
-    return true;
-  }
-  else if (fileItem->HasMusicInfoTag())
-  {
-    CGUIDialogMusicInfo::ShowFor(*fileItem.get());
-    return true;
-  }
-  return false;
-}
-
-bool CDirectoryProvider::OnContextMenu(const CGUIListItemPtr& item)
-{
-  auto fileItem = std::static_pointer_cast<CFileItem>(item);
-  return CONTEXTMENU::ShowFor(fileItem);
-}
-
 bool CDirectoryProvider::IsUpdating() const
 {
   CSingleLock lock(m_section);
diff --git a/xbmc/listproviders/DirectoryProvider.h b/xbmc/listproviders/DirectoryProvider.h
index d8dad25..f9c3406 100644
--- a/xbmc/listproviders/DirectoryProvider.h
+++ b/xbmc/listproviders/DirectoryProvider.h
@@ -30,13 +30,13 @@
 class TiXmlElement;
 class CVariant;
 
-enum class InfoTagType
+typedef enum
 {
   VIDEO,
   AUDIO,
   PICTURE,
   PROGRAM
-};
+} InfoTagType;
 
 class CDirectoryProvider :
   public IListProvider,
@@ -59,8 +59,6 @@ public:
   virtual void Fetch(std::vector<CGUIListItemPtr> &items) const;
   virtual void Reset(bool immediately = false);
   virtual bool OnClick(const CGUIListItemPtr &item);
-  bool OnInfo(const CGUIListItemPtr &item) override;
-  bool OnContextMenu(const CGUIListItemPtr &item) override;
   virtual bool IsUpdating() const;
 
   // callback from directory job
diff --git a/xbmc/listproviders/IListProvider.h b/xbmc/listproviders/IListProvider.h
index 86473eb..137a8a1 100644
--- a/xbmc/listproviders/IListProvider.h
+++ b/xbmc/listproviders/IListProvider.h
@@ -71,18 +71,6 @@ public:
    */
   virtual bool OnClick(const CGUIListItemPtr &item)=0;
 
-  /*! \brief Open the info dialog for an item provided by this IListProvider.
-   \param item the item that was clicked.
-   \return true if the dialog was shown, false otherwise.
-   */
-  virtual bool OnInfo(const CGUIListItemPtr &item)=0;
-
-  /*! \brief Open the context menu for an item provided by this IListProvider.
-   \param item the item that was clicked.
-   \return true if the click was handled, false otherwise.
-   */
-  virtual bool OnContextMenu(const CGUIListItemPtr &item)=0;
-
   /*! \brief Set the default item to focus. For backwards compatibility.
    \param item the item to focus.
    \param always whether this item should always be used on first focus.
diff --git a/xbmc/listproviders/StaticProvider.h b/xbmc/listproviders/StaticProvider.h
index 5a869e8..5e3ce29 100644
--- a/xbmc/listproviders/StaticProvider.h
+++ b/xbmc/listproviders/StaticProvider.h
@@ -33,8 +33,6 @@ public:
   virtual bool Update(bool forceRefresh);
   virtual void Fetch(std::vector<CGUIListItemPtr> &items) const;
   virtual bool OnClick(const CGUIListItemPtr &item);
-  bool OnInfo(const CGUIListItemPtr &item) override { return false; }
-  bool OnContextMenu(const CGUIListItemPtr &item) override { return false; }
   virtual void SetDefaultItem(int item, bool always);
   virtual int  GetDefaultItem() const;
   virtual bool AlwaysFocusDefaultItem() const;
diff --git a/xbmc/music/ContextMenus.cpp b/xbmc/music/ContextMenus.cpp
index d582110..d26fdf1 100644
--- a/xbmc/music/ContextMenus.cpp
+++ b/xbmc/music/ContextMenus.cpp
@@ -20,7 +20,7 @@
 
 #include "ContextMenus.h"
 #include "guilib/GUIWindowManager.h"
-#include "music/dialogs/GUIDialogMusicInfo.h"
+#include "music/windows/GUIWindowMusicNav.h"
 #include "tags/MusicInfoTag.h"
 
 
@@ -37,8 +37,13 @@ bool CMusicInfo::IsVisible(const CFileItem& item) const
 
 bool CMusicInfo::Execute(const CFileItemPtr& item) const
 {
-  CGUIDialogMusicInfo::ShowFor(*item);
-  return true;
+  auto window = static_cast<CGUIWindowMusicNav*>(g_windowManager.GetWindow(WINDOW_MUSIC_NAV));
+  if (window)
+  {
+    window->OnItemInfo(item.get());
+    return true;
+  }
+  return false;
 }
 
 }
diff --git a/xbmc/music/dialogs/GUIDialogMusicInfo.cpp b/xbmc/music/dialogs/GUIDialogMusicInfo.cpp
index 3fca559..587f8cc 100644
--- a/xbmc/music/dialogs/GUIDialogMusicInfo.cpp
+++ b/xbmc/music/dialogs/GUIDialogMusicInfo.cpp
@@ -37,7 +37,6 @@
 #include "utils/StringUtils.h"
 #include "TextureCache.h"
 #include "music/MusicThumbLoader.h"
-#include "music/windows/GUIWindowMusicNav.h"
 #include "filesystem/Directory.h"
 
 using namespace XFILE;
@@ -625,9 +624,3 @@ void CGUIDialogMusicInfo::OnSetUserrating() const
   }
 }
 
-void CGUIDialogMusicInfo::ShowFor(CFileItem item)
-{
-  auto window = static_cast<CGUIWindowMusicNav*>(g_windowManager.GetWindow(WINDOW_MUSIC_NAV));
-  if (window)
-    window->OnItemInfo(&item);
-}
\ No newline at end of file
diff --git a/xbmc/music/dialogs/GUIDialogMusicInfo.h b/xbmc/music/dialogs/GUIDialogMusicInfo.h
index 8d79438..986981b 100644
--- a/xbmc/music/dialogs/GUIDialogMusicInfo.h
+++ b/xbmc/music/dialogs/GUIDialogMusicInfo.h
@@ -47,8 +47,6 @@ public:
   CFileItemPtr GetCurrentListItem(int offset = 0) override;
   const CFileItemList& CurrentDirectory() const { return *m_albumSongs; };
   static void AddItemPathToFileBrowserSources(VECSOURCES &sources, const CFileItem &item);
-
-  static void ShowFor(CFileItem item);
 protected:
   void OnInitWindow() override;
   void Update();
diff --git a/xbmc/music/infoscanner/MusicInfoScanner.cpp b/xbmc/music/infoscanner/MusicInfoScanner.cpp
index 8770c79..6aea1b5 100644
--- a/xbmc/music/infoscanner/MusicInfoScanner.cpp
+++ b/xbmc/music/infoscanner/MusicInfoScanner.cpp
@@ -35,7 +35,6 @@
 #include "filesystem/File.h"
 #include "filesystem/MusicDatabaseDirectory.h"
 #include "filesystem/MusicDatabaseDirectory/DirectoryNode.h"
-#include "filesystem/SmartPlaylistDirectory.h" 
 #include "GUIInfoManager.h"
 #include "guilib/GUIKeyboardFactory.h"
 #include "guilib/GUIWindowManager.h"
@@ -74,7 +73,6 @@ CMusicInfoScanner::CMusicInfoScanner() : CThread("MusicInfoScanner"), m_fileCoun
   m_currentItem=0;
   m_itemCount=0;
   m_flags = 0;
-  m_bClean = false;
 }
 
 CMusicInfoScanner::~CMusicInfoScanner()
@@ -318,14 +316,8 @@ void CMusicInfoScanner::FetchAlbumInfo(const std::string& strDirectory,
   }
   else
   {
-    if (URIUtils::IsMusicDb(strDirectory))
+    if (URIUtils::HasSlashAtEnd(strDirectory)) // directory
       CDirectory::GetDirectory(strDirectory,items);
-    else if (StringUtils::EndsWith(strDirectory, ".xsp"))
-    {
-      CURL url(strDirectory);
-      CSmartPlaylistDirectory dir;
-      dir.GetDirectory(url, items);
-    }
     else
     {
       CFileItemPtr item(new CFileItem(strDirectory,false));
@@ -363,19 +355,13 @@ void CMusicInfoScanner::FetchArtistInfo(const std::string& strDirectory,
   if (strDirectory.empty())
   {
     m_musicDatabase.Open();
-    m_musicDatabase.GetArtistsNav("musicdb://artists/", items, !CSettings::GetInstance().GetBool(CSettings::SETTING_MUSICLIBRARY_SHOWCOMPILATIONARTISTS), -1);
+    m_musicDatabase.GetArtistsNav("musicdb://artists/", items, false, -1);
     m_musicDatabase.Close();
   }
   else
   {
-    if (URIUtils::IsMusicDb(strDirectory))
+    if (URIUtils::HasSlashAtEnd(strDirectory)) // directory
       CDirectory::GetDirectory(strDirectory,items);
-    else if (StringUtils::EndsWith(strDirectory, ".xsp"))
-    {
-      CURL url(strDirectory);
-      CSmartPlaylistDirectory dir;
-      dir.GetDirectory(url, items);
-    }
     else
     {
       CFileItemPtr newItem(new CFileItem(strDirectory,false));
@@ -809,8 +795,6 @@ int CMusicInfoScanner::RetrieveMusicInfo(const std::string& strDirectory, CFileI
       if (!albumScraper || !artistScraper)
         continue;
 
-      bool albumartistsonly = !CSettings::GetInstance().GetBool(CSettings::SETTING_MUSICLIBRARY_SHOWCOMPILATIONARTISTS);
-
       INFO_RET albumScrapeStatus = INFO_NOT_FOUND;
       if (!m_musicDatabase.HasAlbumBeenScraped(album->idAlbum))
         albumScrapeStatus = UpdateDatabaseAlbumInfo(*album, albumScraper, false);
@@ -831,29 +815,27 @@ int CMusicInfoScanner::RetrieveMusicInfo(const std::string& strDirectory, CFileI
             UpdateDatabaseArtistInfo(artist, artistScraper, false);
           }
         }
-        if (!albumartistsonly)
+
+        for (VECSONGS::iterator song  = album->songs.begin();
+                                song != album->songs.end();
+                                ++song)
         {
-          for (VECSONGS::iterator song = album->songs.begin();
-            song != album->songs.end();
-            ++song)
+          if (m_bStop)
+            break;
+
+          for (VECARTISTCREDITS::const_iterator artistCredit  = song->artistCredits.begin();
+                                                artistCredit != song->artistCredits.end();
+                                              ++artistCredit)
           {
             if (m_bStop)
               break;
 
-            for (VECARTISTCREDITS::const_iterator artistCredit = song->artistCredits.begin();
-              artistCredit != song->artistCredits.end();
-              ++artistCredit)
+            CMusicArtistInfo musicArtistInfo;
+            if (!m_musicDatabase.HasArtistBeenScraped(artistCredit->GetArtistId()))
             {
-              if (m_bStop)
-                break;
-
-              CMusicArtistInfo musicArtistInfo;
-              if (!m_musicDatabase.HasArtistBeenScraped(artistCredit->GetArtistId()))
-              {
-                CArtist artist;
-                m_musicDatabase.GetArtist(artistCredit->GetArtistId(), artist);
-                UpdateDatabaseArtistInfo(artist, artistScraper, false);
-              }
+              CArtist artist;
+              m_musicDatabase.GetArtist(artistCredit->GetArtistId(), artist);
+              UpdateDatabaseArtistInfo(artist, artistScraper, false);
             }
           }
         }
diff --git a/xbmc/music/tags/MusicInfoTag.cpp b/xbmc/music/tags/MusicInfoTag.cpp
index 00648aa..90252b2 100644
--- a/xbmc/music/tags/MusicInfoTag.cpp
+++ b/xbmc/music/tags/MusicInfoTag.cpp
@@ -621,11 +621,6 @@ void CMusicInfoTag::SetAlbumReleaseType(CAlbum::ReleaseType releaseType)
   m_albumReleaseType = releaseType;
 }
 
-void CMusicInfoTag::SetType(const MediaType mediaType)
-{
-  m_type = mediaType;
-}
-
 void CMusicInfoTag::SetArtist(const CArtist& artist)
 {
   SetArtist(artist.strArtist);
diff --git a/xbmc/music/tags/MusicInfoTag.h b/xbmc/music/tags/MusicInfoTag.h
index 5c46a56..cfc247d 100644
--- a/xbmc/music/tags/MusicInfoTag.h
+++ b/xbmc/music/tags/MusicInfoTag.h
@@ -135,7 +135,6 @@ public:
   void SetCoverArtInfo(size_t size, const std::string &mimeType);
   void SetReplayGain(const ReplayGain& aGain);
   void SetAlbumReleaseType(CAlbum::ReleaseType releaseType);
-  void SetType(const MediaType mediaType);
 
   /*! \brief Append a unique artist to the artist list
    Checks if we have this artist already added, and if not adds it to the songs artist list.
@@ -203,7 +202,7 @@ protected:
   int m_iDuration;
   int m_iTrack;     // consists of the disk number in the high 16 bits, the track number in the low 16bits
   int m_iDbId;
-  MediaType m_type; ///< item type "music", "song", "album", "artist"
+  MediaType m_type; ///< item type "song", "album", "artist"
   bool m_bLoaded;
   float m_Rating;
   int m_Userrating;
diff --git a/xbmc/music/windows/GUIWindowMusicBase.cpp b/xbmc/music/windows/GUIWindowMusicBase.cpp
index fe98289..7d1e4b5 100644
--- a/xbmc/music/windows/GUIWindowMusicBase.cpp
+++ b/xbmc/music/windows/GUIWindowMusicBase.cpp
@@ -65,9 +65,6 @@
 #include "CueDocument.h"
 #include "Autorun.h"
 
-#ifdef TARGET_POSIX
-#include "linux/XTimeUtils.h"
-#endif
 
 using namespace XFILE;
 using namespace MUSICDATABASEDIRECTORY;
@@ -320,10 +317,12 @@ void CGUIWindowMusicBase::OnItemInfoAll(int iItem, bool bCurrent /* = false */,
   std::string strPath = m_vecItems->GetPath();
   if (bCurrent)
     strPath = m_vecItems->Get(iItem)->GetPath();
-  
-  if (StringUtils::EqualsNoCase(m_vecItems->GetContent(), "albums"))
+
+  if (dir.HasAlbumInfo(strPath) ||
+      CMusicDatabaseDirectory::GetDirectoryChildType(strPath) == 
+      MUSICDATABASEDIRECTORY::NODE_TYPE_ALBUM)
     g_application.StartMusicAlbumScan(strPath,refresh);
-  else if (StringUtils::EqualsNoCase(m_vecItems->GetContent(), "artists"))
+  else
     g_application.StartMusicArtistScan(strPath,refresh);
 }
 
@@ -901,7 +900,9 @@ void CGUIWindowMusicBase::GetContextButtons(int itemNumber, CContextButtons &but
 
 void CGUIWindowMusicBase::GetNonContextButtons(CContextButtons &buttons)
 {
-  if (CServiceBroker::GetADSP().IsProcessing())
+  if (!m_vecItems->IsVirtualDirectoryRoot())
+    buttons.Add(CONTEXT_BUTTON_GOTO_ROOT, 20128);
+  if (ActiveAE::CActiveAEDSP::GetInstance().IsProcessing())
     buttons.Add(CONTEXT_BUTTON_ACTIVE_ADSP_SETTINGS, 15047);
 }
 
@@ -971,6 +972,10 @@ bool CGUIWindowMusicBase::OnContextButton(int itemNumber, CONTEXT_BUTTON button)
       return true;
     }
 
+  case CONTEXT_BUTTON_GOTO_ROOT:
+    Update("");
+    return true;
+
   case CONTEXT_BUTTON_ACTIVE_ADSP_SETTINGS:
     g_windowManager.ActivateWindow(WINDOW_DIALOG_AUDIO_DSP_OSD_SETTINGS);
     return true;
diff --git a/xbmc/music/windows/GUIWindowMusicNav.cpp b/xbmc/music/windows/GUIWindowMusicNav.cpp
index db1856b..e604bd8 100644
--- a/xbmc/music/windows/GUIWindowMusicNav.cpp
+++ b/xbmc/music/windows/GUIWindowMusicNav.cpp
@@ -185,7 +185,7 @@ bool CGUIWindowMusicNav::OnAction(const CAction& action)
     int item = m_viewControl.GetSelectedItem();
     CMusicDatabaseDirectory dir;
     if (item > -1 && m_vecItems->Get(item)->m_bIsFolder
-                  && (m_vecItems->Get(item)->IsAlbum()||
+                  && (dir.HasAlbumInfo(m_vecItems->Get(item)->GetPath())||
                       dir.IsArtistDir(m_vecItems->Get(item)->GetPath())))
     {
       OnContextButton(item,CONTEXT_BUTTON_INFO);
@@ -482,14 +482,14 @@ void CGUIWindowMusicNav::GetContextButtons(int itemNumber, CContextButtons &butt
       CMusicDatabaseDirectory dir;
 
       // enable query all albums button only in album view
-      if (item->IsAlbum() && !dir.IsAllItem(item->GetPath()) &&
+      if (dir.HasAlbumInfo(item->GetPath()) && !dir.IsAllItem(item->GetPath()) &&
           item->m_bIsFolder && !item->IsVideoDb() && !item->IsParentFolder()   &&
          !item->IsPlugin() && !StringUtils::StartsWithNoCase(item->GetPath(), "musicsearch://"))
       {
         buttons.Add(CONTEXT_BUTTON_INFO_ALL, 20059);
       }
 
-      // enable query all artist button only in artist view
+      // enable query all artist button only in album view
       if (dir.IsArtistDir(item->GetPath()) && !dir.IsAllItem(item->GetPath()) &&
         item->m_bIsFolder && !item->IsVideoDb())
       {
@@ -617,8 +617,13 @@ bool CGUIWindowMusicNav::OnContextButton(int itemNumber, CONTEXT_BUTTON button)
 
       if (item->HasVideoInfoTag() && !item->GetVideoInfoTag()->m_strTitle.empty())
       {
-        CGUIDialogVideoInfo::ShowFor(*item);
-        Refresh();
+        CGUIWindowVideoNav* pWindow = (CGUIWindowVideoNav*)g_windowManager.GetWindow(WINDOW_VIDEO_NAV);
+        if (pWindow)
+        {
+          ADDON::ScraperPtr info;
+          pWindow->OnItemInfo(item.get(),info);
+          Refresh();
+        }
       }
       return true;
     }
diff --git a/xbmc/network/WakeOnAccess.cpp b/xbmc/network/WakeOnAccess.cpp
index 2112798..a6fd2af 100644
--- a/xbmc/network/WakeOnAccess.cpp
+++ b/xbmc/network/WakeOnAccess.cpp
@@ -41,9 +41,6 @@
 #include "utils/URIUtils.h"
 #include "utils/StringUtils.h"
 #include "utils/Variant.h"
-#ifdef TARGET_POSIX
-#include "linux/XTimeUtils.h"
-#endif
 
 #include "WakeOnAccess.h"
 
diff --git a/xbmc/network/linux/NetworkLinux.cpp b/xbmc/network/linux/NetworkLinux.cpp
index 5868845..9167c2b 100644
--- a/xbmc/network/linux/NetworkLinux.cpp
+++ b/xbmc/network/linux/NetworkLinux.cpp
@@ -201,7 +201,7 @@ std::string CNetworkInterfaceLinux::GetCurrentDefaultGateway(void)
 
 #if defined(TARGET_DARWIN)
   FILE* pipe = popen("echo \"show State:/Network/Global/IPv4\" | scutil | grep Router", "r");
-  usleep(100000);
+  Sleep(100);
   if (pipe)
   {
     std::string tmpStr;
@@ -473,7 +473,7 @@ std::vector<std::string> CNetworkLinux::GetNameServers(void)
 
 #if defined(TARGET_DARWIN)
   FILE* pipe = popen("scutil --dns | grep \"nameserver\" | tail -n2", "r");
-  usleep(100000);
+  Sleep(100);
   if (pipe)
   {
     std::vector<std::string> tmpStr;
diff --git a/xbmc/peripherals/PeripheralTypes.h b/xbmc/peripherals/PeripheralTypes.h
index f93adc2..1ab2592 100644
--- a/xbmc/peripherals/PeripheralTypes.h
+++ b/xbmc/peripherals/PeripheralTypes.h
@@ -45,6 +45,7 @@ namespace PERIPHERALS
 #ifdef TARGET_ANDROID
     PERIPHERAL_BUS_ANDROID,
 #endif
+    PERIPHERAL_BUS_APPLICATION,
   };
 
   enum PeripheralFeature
@@ -73,6 +74,7 @@ namespace PERIPHERALS
     PERIPHERAL_TUNER,
     PERIPHERAL_IMON,
     PERIPHERAL_JOYSTICK,
+    PERIPHERAL_JOYSTICK_EMULATION,
   };
 
   class CPeripheralAddon;
@@ -126,6 +128,8 @@ namespace PERIPHERALS
         return "imon";
       case PERIPHERAL_JOYSTICK:
         return "joystick";
+      case PERIPHERAL_JOYSTICK_EMULATION:
+        return "joystickemulation";
       default:
         return "unknown";
       }
@@ -154,6 +158,8 @@ namespace PERIPHERALS
         return PERIPHERAL_IMON;
       else if (strTypeLowerCase == "joystick")
         return PERIPHERAL_JOYSTICK;
+      else if (strTypeLowerCase == "joystickemulation")
+        return PERIPHERAL_JOYSTICK_EMULATION;
 
       return PERIPHERAL_UNKNOWN;
     };
@@ -176,6 +182,8 @@ namespace PERIPHERALS
       case PERIPHERAL_BUS_ANDROID:
         return "android";
 #endif
+      case PERIPHERAL_BUS_APPLICATION:
+        return "application";
       default:
         return "unknown";
       }
@@ -200,6 +208,8 @@ namespace PERIPHERALS
       else if (strTypeLowerCase == "android")
         return PERIPHERAL_BUS_ANDROID;
 #endif
+      else if (strTypeLowerCase == "application")
+        return PERIPHERAL_BUS_APPLICATION;
 
       return PERIPHERAL_BUS_UNKNOWN;
     };
diff --git a/xbmc/peripherals/Peripherals.cpp b/xbmc/peripherals/Peripherals.cpp
index 46fceba..807641a 100644
--- a/xbmc/peripherals/Peripherals.cpp
+++ b/xbmc/peripherals/Peripherals.cpp
@@ -36,6 +36,7 @@
 #include "devices/PeripheralHID.h"
 #include "devices/PeripheralImon.h"
 #include "devices/PeripheralJoystick.h"
+#include "devices/PeripheralJoystickEmulation.h"
 #include "devices/PeripheralNIC.h"
 #include "devices/PeripheralNyxboard.h"
 #include "devices/PeripheralTuner.h"
@@ -44,6 +45,8 @@
 #include "dialogs/GUIDialogPeripheralSettings.h"
 #include "dialogs/GUIDialogSelect.h"
 #include "FileItem.h"
+#include "bus/virtual/PeripheralBusApplication.h"
+#include "input/joysticks/IButtonMapper.h"
 #include "filesystem/Directory.h"
 #include "guilib/GUIWindowManager.h"
 #include "guilib/LocalizeStrings.h"
@@ -73,12 +76,14 @@ using namespace XFILE;
 CPeripherals::CPeripherals() :
   m_eventScanner(this)
 {
+  RegisterObserver(&m_portMapper);
   Clear();
 }
 
 CPeripherals::~CPeripherals()
 {
   Clear();
+  UnregisterObserver(&m_portMapper);
 }
 
 CPeripherals &CPeripherals::GetInstance()
@@ -112,6 +117,7 @@ void CPeripherals::Initialise()
 #if defined(TARGET_ANDROID)
     m_busses.push_back(std::make_shared<CPeripheralBusAndroid>(this));
 #endif
+    m_busses.push_back(std::make_shared<CPeripheralBusApplication>(this));
 
     /* initialise all known busses and run an initial scan for devices */
     for (auto& bus : m_busses)
@@ -323,6 +329,10 @@ CPeripheral *CPeripherals::CreatePeripheral(CPeripheralBus &bus, const Periphera
     peripheral = new CPeripheralJoystick(mappedResult, &bus);
     break;
 
+  case PERIPHERAL_JOYSTICK_EMULATION:
+    peripheral = new CPeripheralJoystickEmulation(mappedResult, &bus);
+    break;
+
   default:
     break;
   }
@@ -348,8 +358,17 @@ void CPeripherals::OnDeviceAdded(const CPeripheralBus &bus, const CPeripheral &p
 {
   OnDeviceChanged();
 
+  bool bNotify = true;
+
   // don't show a notification for devices detected during the initial scan
-  if (bus.IsInitialised())
+  if (!bus.IsInitialised())
+    bNotify = false;
+
+  // don't show a notification for emulated peripherals
+  if (peripheral.Type() == PERIPHERAL_JOYSTICK_EMULATION) // TODO: Change to peripheral.IsEmulated()
+    bNotify = false;
+
+  if (bNotify)
     CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Info, g_localizeStrings.Get(35005), peripheral.DeviceName());
 }
 
@@ -357,7 +376,14 @@ void CPeripherals::OnDeviceDeleted(const CPeripheralBus &bus, const CPeripheral
 {
   OnDeviceChanged();
 
-  CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Info, g_localizeStrings.Get(35006), peripheral.DeviceName());
+  bool bNotify = true;
+
+  // don't show a notification for emulated peripherals
+  if (peripheral.Type() == PERIPHERAL_JOYSTICK_EMULATION) // TODO: Change to peripheral.IsEmulated()
+    bNotify = false;
+
+  if (bNotify)
+    CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Info, g_localizeStrings.Get(35006), peripheral.DeviceName());
 }
 
 void CPeripherals::OnDeviceChanged()
@@ -782,7 +808,25 @@ void CPeripherals::RegisterJoystickButtonMapper(IButtonMapper* mapper)
   GetPeripheralsWithFeature(peripherals, FEATURE_JOYSTICK);
 
   for (auto& peripheral : peripherals)
+  {
+    if (mapper->Emulation())
+    {
+      if (peripheral->Type() != PERIPHERAL_JOYSTICK_EMULATION)
+        continue;
+
+      unsigned int controllerNumber = static_cast<const CPeripheralJoystickEmulation*>(peripheral)->ControllerNumber();
+
+      if (mapper->ControllerNumber() != controllerNumber)
+        continue;
+    }
+    else
+    {
+      if (peripheral->Type() != PERIPHERAL_JOYSTICK)
+        continue;
+    }
+
     peripheral->RegisterJoystickButtonMapper(mapper);
+  }
 }
 
 void CPeripherals::UnregisterJoystickButtonMapper(IButtonMapper* mapper)
@@ -868,8 +912,6 @@ void CPeripherals::OnSettingAction(const CSetting *setting)
       }
     } while (pDialog->IsConfirmed());
   }
-  else if (settingId == CSettings::SETTING_INPUT_CONTROLLERCONFIG)
-    g_windowManager.ActivateWindow(WINDOW_DIALOG_GAME_CONTROLLERS);
 }
 
 void CPeripherals::OnApplicationMessage(KODI::MESSAGING::ThreadMessage* pMsg)
diff --git a/xbmc/peripherals/Peripherals.h b/xbmc/peripherals/Peripherals.h
index 311af06..82bb9f3 100644
--- a/xbmc/peripherals/Peripherals.h
+++ b/xbmc/peripherals/Peripherals.h
@@ -22,6 +22,7 @@
 #include "EventScanner.h"
 #include "bus/PeripheralBus.h"
 #include "devices/Peripheral.h"
+#include "games/ports/PortMapper.h" // TODO: Find me a better place
 #include "messaging/IMessageTarget.h"
 #include "settings/lib/ISettingCallback.h"
 #include "system.h"
@@ -255,6 +256,7 @@ namespace PERIPHERALS
     std::vector<PeripheralBusPtr>        m_busses;
     std::vector<PeripheralDeviceMapping> m_mappings;
     CEventScanner                        m_eventScanner;
+	GAME::CPortMapper                    m_portMapper; // TODO: Find me a better place
     CCriticalSection                     m_critSection;
     CCriticalSection                     m_critSectionBusses;
     CCriticalSection                     m_critSectionMappings;
diff --git a/xbmc/peripherals/addons/PeripheralAddon.cpp b/xbmc/peripherals/addons/PeripheralAddon.cpp
index 2911123..850fc67 100644
--- a/xbmc/peripherals/addons/PeripheralAddon.cpp
+++ b/xbmc/peripherals/addons/PeripheralAddon.cpp
@@ -32,6 +32,7 @@
 #include "peripherals/Peripherals.h"
 #include "peripherals/bus/virtual/PeripheralBusAddon.h"
 #include "peripherals/devices/PeripheralJoystick.h"
+#include "peripherals/devices/PeripheralJoystickEmulation.h"
 #include "utils/log.h"
 #include "utils/StringUtils.h"
 
@@ -43,6 +44,9 @@ using namespace JOYSTICK;
 using namespace PERIPHERALS;
 using namespace XFILE;
 
+#define JOYSTICK_EMULATION_BUTTON_MAP_NAME  "Keyboard"
+#define JOYSTICK_EMULATION_PROVIDER         "application"
+
 #ifndef SAFE_DELETE
   #define SAFE_DELETE(p)  do { delete (p); (p) = NULL; } while (0)
 #endif
@@ -623,6 +627,13 @@ void CPeripheralAddon::GetJoystickInfo(const CPeripheral* device, ADDON::Joystic
     joystickInfo.SetHatCount(joystick->HatCount());
     joystickInfo.SetAxisCount(joystick->AxisCount());
   }
+  else if (device->Type() == PERIPHERAL_JOYSTICK_EMULATION)
+  {
+    const CPeripheralJoystickEmulation* joystick = static_cast<const CPeripheralJoystickEmulation*>(device);
+    joystickInfo.SetName(JOYSTICK_EMULATION_BUTTON_MAP_NAME); // Override name with non-localized version
+    joystickInfo.SetProvider(JOYSTICK_EMULATION_PROVIDER);
+    joystickInfo.SetIndex(joystick->ControllerNumber());
+  }
 }
 
 void CPeripheralAddon::SetJoystickInfo(CPeripheralJoystick& joystick, const ADDON::Joystick& joystickInfo)
diff --git a/xbmc/peripherals/bus/Makefile.in b/xbmc/peripherals/bus/Makefile.in
index df5250c..61a21c4 100644
--- a/xbmc/peripherals/bus/Makefile.in
+++ b/xbmc/peripherals/bus/Makefile.in
@@ -1,5 +1,6 @@
 SRCS  = PeripheralBus.cpp
 SRCS += virtual/PeripheralBusAddon.cpp
+SRCS += virtual/PeripheralBusApplication.cpp
 
 ifeq (@USE_ANDROID@,1)
 SRCS += android/AndroidJoystickState.cpp
diff --git a/xbmc/peripherals/bus/android/PeripheralBusAndroid.cpp b/xbmc/peripherals/bus/android/PeripheralBusAndroid.cpp
index 3ba40d8..d5a84b1 100644
--- a/xbmc/peripherals/bus/android/PeripheralBusAndroid.cpp
+++ b/xbmc/peripherals/bus/android/PeripheralBusAndroid.cpp
@@ -339,15 +339,13 @@ bool CPeripheralBusAndroid::GetDeviceId(const std::string& deviceLocation, int&
 bool CPeripheralBusAndroid::ConvertToPeripheralScanResult(const CJNIViewInputDevice& inputDevice, PeripheralScanResult& peripheralScanResult)
 {
   int deviceId = inputDevice.getId();
-  int sources = inputDevice.getSources();
   std::string deviceName = inputDevice.getName();
   if (inputDevice.isVirtual())
   {
     CLog::Log(LOGDEBUG, "CPeripheralBusAndroid: ignoring virtual input device \"%s\" with ID %d", deviceName.c_str(), deviceId);
     return false;
   }
-  if ((sources & CJNIViewInputDevice::SOURCE_JOYSTICK) != CJNIViewInputDevice::SOURCE_JOYSTICK &&
-      (sources & CJNIViewInputDevice::SOURCE_GAMEPAD) != CJNIViewInputDevice::SOURCE_GAMEPAD)
+  if (!inputDevice.supportsSource(CJNIViewInputDevice::SOURCE_JOYSTICK) && !inputDevice.supportsSource(CJNIViewInputDevice::SOURCE_GAMEPAD))
   {
     CLog::Log(LOGDEBUG, "CPeripheralBusAndroid: ignoring unknown input device \"%s\" with ID %d", deviceName.c_str(), deviceId);
     return false;
diff --git a/xbmc/peripherals/bus/virtual/PeripheralBusApplication.cpp b/xbmc/peripherals/bus/virtual/PeripheralBusApplication.cpp
new file mode 100644
index 0000000..e856d52
--- /dev/null
+++ b/xbmc/peripherals/bus/virtual/PeripheralBusApplication.cpp
@@ -0,0 +1,61 @@
+/*
+ *      Copyright (C) 2015-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "PeripheralBusApplication.h"
+#include "guilib/LocalizeStrings.h"
+#include "settings/Settings.h"
+#include "utils/StringUtils.h"
+
+using namespace PERIPHERALS;
+
+CPeripheralBusApplication::CPeripheralBusApplication(CPeripherals* manager) :
+    CPeripheralBus("PeripBusApplication", manager, PERIPHERAL_BUS_APPLICATION)
+{
+  // Initialize CPeripheralBus
+  m_bNeedsPolling = false;
+}
+
+bool CPeripheralBusApplication::PerformDeviceScan(PeripheralScanResults& results)
+{
+  const unsigned int controllerCount = CSettings::GetInstance().GetInt(CSettings::SETTING_GAMES_EMULATEDCONTROLLERS);
+
+  for (unsigned int i = 1; i <= controllerCount; i++)
+  {
+    PeripheralScanResult result(Type());
+    result.m_type          = PERIPHERAL_JOYSTICK_EMULATION;
+    result.m_strDeviceName = g_localizeStrings.Get(35073); // "Emulated controller"
+    result.m_strLocation   = MakeLocation(i);
+    result.m_iVendorId     = 0;
+    result.m_iProductId    = 0;
+    result.m_mappedType    = PERIPHERAL_JOYSTICK_EMULATION;
+    result.m_mappedBusType = Type();
+    result.m_iSequence     = 0;
+
+    if (!results.ContainsResult(result))
+      results.m_results.push_back(result);
+  }
+
+  return true;
+}
+
+std::string CPeripheralBusApplication::MakeLocation(unsigned int controllerIndex) const
+{
+  return StringUtils::Format("%u", controllerIndex);
+}
diff --git a/xbmc/peripherals/bus/virtual/PeripheralBusApplication.h b/xbmc/peripherals/bus/virtual/PeripheralBusApplication.h
new file mode 100644
index 0000000..b8e77f2
--- /dev/null
+++ b/xbmc/peripherals/bus/virtual/PeripheralBusApplication.h
@@ -0,0 +1,47 @@
+/*
+ *      Copyright (C) 2015-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+#include "peripherals/bus/PeripheralBus.h"
+
+namespace PERIPHERALS
+{
+  /*!
+   * @class CPeripheralBusApplication
+   *
+   * This exposes peripherals that exist logically at the application level,
+   * such as emulated joysticks.
+   */
+  class CPeripheralBusApplication : public CPeripheralBus
+  {
+  public:
+    CPeripheralBusApplication(CPeripherals* manager);
+    virtual ~CPeripheralBusApplication(void) { }
+
+    /*!
+     * \brief Get the location for the specified controller index
+     */
+    std::string MakeLocation(unsigned int controllerIndex) const;
+
+  protected:
+    // implementation of CPeripheralBus
+    virtual bool PerformDeviceScan(PeripheralScanResults& results) override;
+  };
+}
diff --git a/xbmc/peripherals/devices/Makefile.in b/xbmc/peripherals/devices/Makefile.in
index b79d94a..a0b0f25 100644
--- a/xbmc/peripherals/devices/Makefile.in
+++ b/xbmc/peripherals/devices/Makefile.in
@@ -4,6 +4,7 @@ SRCS += PeripheralDisk.cpp
 SRCS += PeripheralHID.cpp
 SRCS += PeripheralImon.cpp
 SRCS += PeripheralJoystick.cpp
+SRCS += PeripheralJoystickEmulation.cpp
 SRCS += PeripheralNIC.cpp
 SRCS += PeripheralNyxboard.cpp
 SRCS += PeripheralTuner.cpp
diff --git a/xbmc/peripherals/devices/PeripheralJoystickEmulation.cpp b/xbmc/peripherals/devices/PeripheralJoystickEmulation.cpp
new file mode 100644
index 0000000..b049f76
--- /dev/null
+++ b/xbmc/peripherals/devices/PeripheralJoystickEmulation.cpp
@@ -0,0 +1,78 @@
+/*
+ *      Copyright (C) 2015-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "PeripheralJoystickEmulation.h"
+#include "input/keyboard/generic/GenericKeyboardJoystick.h"
+#include "input/InputManager.h"
+
+#include <sstream>
+
+using namespace PERIPHERALS;
+
+CPeripheralJoystickEmulation::CPeripheralJoystickEmulation(const PeripheralScanResult& scanResult, CPeripheralBus* bus) :
+  CPeripheral(scanResult, bus),
+  m_keyboardHandler(nullptr)
+{
+  m_features.push_back(FEATURE_JOYSTICK);
+}
+
+CPeripheralJoystickEmulation::~CPeripheralJoystickEmulation(void)
+{
+  if (m_keyboardHandler)
+  {
+    CInputManager::GetInstance().UnregisterKeyboardHandler(m_keyboardHandler);
+    delete m_keyboardHandler;
+  }
+}
+
+bool CPeripheralJoystickEmulation::InitialiseFeature(const PeripheralFeature feature)
+{
+  bool bSuccess = false;
+
+  if (CPeripheral::InitialiseFeature(feature))
+  {
+    if (feature == FEATURE_JOYSTICK)
+    {
+      m_keyboardHandler = new KEYBOARD::CGenericKeyboardJoystick;
+      CInputManager::GetInstance().RegisterKeyboardHandler(m_keyboardHandler);
+    }
+    bSuccess = true;
+  }
+
+  return bSuccess;
+}
+
+void CPeripheralJoystickEmulation::RegisterJoystickDriverHandler(JOYSTICK::IDriverHandler* handler, bool bPromiscuous)
+{
+  m_keyboardHandler->RegisterJoystickDriverHandler(handler, bPromiscuous);
+}
+
+void CPeripheralJoystickEmulation::UnregisterJoystickDriverHandler(JOYSTICK::IDriverHandler* handler)
+{
+  m_keyboardHandler->UnregisterJoystickDriverHandler(handler);
+}
+
+unsigned int CPeripheralJoystickEmulation::ControllerNumber(void) const
+{
+  unsigned int number;
+  std::istringstream str(m_strLocation);
+  str >> number;
+  return number;
+}
diff --git a/xbmc/peripherals/devices/PeripheralJoystickEmulation.h b/xbmc/peripherals/devices/PeripheralJoystickEmulation.h
new file mode 100644
index 0000000..0f9fa19
--- /dev/null
+++ b/xbmc/peripherals/devices/PeripheralJoystickEmulation.h
@@ -0,0 +1,52 @@
+/*
+ *      Copyright (C) 2015-2016 Team Kodi
+ *      http://kodi.tv
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this Program; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+#include "Peripheral.h"
+
+namespace KEYBOARD
+{
+  class CGenericKeyboardJoystick;
+}
+
+namespace PERIPHERALS
+{
+  class CPeripheralJoystickEmulation : public CPeripheral
+  {
+  public:
+    CPeripheralJoystickEmulation(const PeripheralScanResult& scanResult, CPeripheralBus* bus);
+
+    virtual ~CPeripheralJoystickEmulation(void);
+
+    // implementation of CPeripheral
+    virtual bool InitialiseFeature(const PeripheralFeature feature);
+    virtual void RegisterJoystickDriverHandler(JOYSTICK::IDriverHandler* handler, bool bPromiscuous) override;
+    virtual void UnregisterJoystickDriverHandler(JOYSTICK::IDriverHandler* handler) override;
+
+    /*!
+     * \brief Number of the emulated controller (1-indexed)
+     */
+    unsigned int ControllerNumber(void) const;
+
+  private:
+    // Joystick emulation
+    KEYBOARD::CGenericKeyboardJoystick* m_keyboardHandler;
+  };
+}
diff --git a/xbmc/pictures/GUIWindowPictures.cpp b/xbmc/pictures/GUIWindowPictures.cpp
index 3b564a1..ae7fc4d 100644
--- a/xbmc/pictures/GUIWindowPictures.cpp
+++ b/xbmc/pictures/GUIWindowPictures.cpp
@@ -45,10 +45,6 @@
 #include "utils/StringUtils.h"
 #include "GUIWindowSlideShow.h"
 
-#ifdef TARGET_POSIX
-#include "linux/XTimeUtils.h"
-#endif
-
 #define CONTROL_BTNVIEWASICONS      2
 #define CONTROL_BTNSORTBY           3
 #define CONTROL_BTNSORTASC          4
@@ -485,7 +481,10 @@ void CGUIWindowPictures::GetContextButtons(int itemNumber, CContextButtons &butt
       }
 
       if (!item->IsPlugin() && !item->IsScript() && !m_vecItems->IsPlugin())
+      {
+        buttons.Add(CONTEXT_BUTTON_GOTO_ROOT, 20128);
         buttons.Add(CONTEXT_BUTTON_SWITCH_MEDIA, 523);
+      }
     }
   }
   CGUIMediaWindow::GetContextButtons(itemNumber, buttons);
@@ -523,6 +522,9 @@ bool CGUIWindowPictures::OnContextButton(int itemNumber, CONTEXT_BUTTON button)
   case CONTEXT_BUTTON_RENAME:
     OnRenameItem(itemNumber);
     return true;
+  case CONTEXT_BUTTON_GOTO_ROOT:
+    Update("");
+    return true;
   case CONTEXT_BUTTON_SWITCH_MEDIA:
     CGUIDialogContextMenu::SwitchMedia("pictures", m_vecItems->GetPath());
     return true;
diff --git a/xbmc/pictures/GUIWindowSlideShow.cpp b/xbmc/pictures/GUIWindowSlideShow.cpp
index 0f8face..5ad227f 100644
--- a/xbmc/pictures/GUIWindowSlideShow.cpp
+++ b/xbmc/pictures/GUIWindowSlideShow.cpp
@@ -45,9 +45,6 @@
 #include "interfaces/AnnouncementManager.h"
 #include "pictures/GUIViewStatePictures.h"
 #include "pictures/PictureThumbLoader.h"
-#ifdef TARGET_POSIX
-#include "linux/XTimeUtils.h"
-#endif
 
 using namespace XFILE;
 using namespace KODI::MESSAGING;
diff --git a/xbmc/platform/android/activity/JNIMainActivity.cpp b/xbmc/platform/android/activity/JNIMainActivity.cpp
index d1d4a15..aede234 100644
--- a/xbmc/platform/android/activity/JNIMainActivity.cpp
+++ b/xbmc/platform/android/activity/JNIMainActivity.cpp
@@ -103,14 +103,6 @@ void CJNIMainActivity::_onInputDeviceRemoved(JNIEnv *env, jobject context, jint
     m_appInstance->onInputDeviceRemoved(deviceId);
 }
 
-void CJNIMainActivity::_doFrame(JNIEnv *env, jobject context, jlong frameTimeNanos)
-{
-  (void)env;
-  (void)context;
-  if(m_appInstance)
-    m_appInstance->doFrame(frameTimeNanos);
-}
-
 CJNISurface CJNIMainActivity::getVideoViewSurface()
 {
   return call_method<jhobject>(m_context,
diff --git a/xbmc/platform/android/activity/JNIMainActivity.h b/xbmc/platform/android/activity/JNIMainActivity.h
index 318260b..80b5678 100644
--- a/xbmc/platform/android/activity/JNIMainActivity.h
+++ b/xbmc/platform/android/activity/JNIMainActivity.h
@@ -34,7 +34,6 @@ public:
   static void _onNewIntent(JNIEnv *env, jobject context, jobject intent);
   static void _onVolumeChanged(JNIEnv *env, jobject context, jint volume);
   static void _onAudioFocusChange(JNIEnv *env, jobject context, jint focusChange);
-  static void _doFrame(JNIEnv *env, jobject context, jlong frameTimeNanos);
   static void _onInputDeviceAdded(JNIEnv *env, jobject context, jint deviceId);
   static void _onInputDeviceChanged(JNIEnv *env, jobject context, jint deviceId);
   static void _onInputDeviceRemoved(JNIEnv *env, jobject context, jint deviceId);
@@ -55,5 +54,4 @@ protected:
   virtual void onNewIntent(CJNIIntent intent)=0;
   virtual void onVolumeChanged(int volume)=0;
   virtual void onAudioFocusChange(int focusChange)=0;
-  virtual void doFrame(int64_t frameTimeNanos)=0;
 };
diff --git a/xbmc/platform/android/activity/XBMCApp.cpp b/xbmc/platform/android/activity/XBMCApp.cpp
index c042d3b..5acef23 100644
--- a/xbmc/platform/android/activity/XBMCApp.cpp
+++ b/xbmc/platform/android/activity/XBMCApp.cpp
@@ -82,7 +82,6 @@
 #include "AndroidKey.h"
 
 #include "CompileInfo.h"
-#include "video/videosync/VideoSyncAndroid.h"
 
 #define GIGABYTES       1073741824
 
@@ -107,7 +106,6 @@ IInputDeviceCallbacks* CXBMCApp::m_inputDeviceCallbacks = nullptr;
 IInputDeviceEventHandler* CXBMCApp::m_inputDeviceEventHandler = nullptr;
 CCriticalSection CXBMCApp::m_applicationsMutex;
 std::vector<androidPackage> CXBMCApp::m_applications;
-CVideoSyncAndroid* CXBMCApp::m_syncImpl = NULL;
 
 
 CXBMCApp::CXBMCApp(ANativeActivity* nativeActivity)
@@ -831,22 +829,6 @@ void CXBMCApp::onAudioFocusChange(int focusChange)
   }
 }
 
-void CXBMCApp::InitFrameCallback(CVideoSyncAndroid* syncImpl)
-{
-  m_syncImpl = syncImpl;
-}
-
-void CXBMCApp::DeinitFrameCallback()
-{
-  m_syncImpl = NULL;
-}
-
-void CXBMCApp::doFrame(int64_t frameTimeNanos)
-{
-  if (m_syncImpl)
-    m_syncImpl->FrameCallback(frameTimeNanos);
-}
-
 void CXBMCApp::SetupEnv()
 {
   setenv("XBMC_ANDROID_SYSTEM_LIBS", CJNISystem::getProperty("java.library.path").c_str(), 0);
diff --git a/xbmc/platform/android/activity/XBMCApp.h b/xbmc/platform/android/activity/XBMCApp.h
index 29b7900..b7ca38d 100644
--- a/xbmc/platform/android/activity/XBMCApp.h
+++ b/xbmc/platform/android/activity/XBMCApp.h
@@ -44,7 +44,6 @@ class CAESinkAUDIOTRACK;
 class CVariant;
 class IInputDeviceCallbacks;
 class IInputDeviceEventHandler;
-class CVideoSyncAndroid;
 typedef struct _JNIEnv JNIEnv;
 
 struct androidIcon
@@ -72,7 +71,6 @@ public:
   virtual void onNewIntent(CJNIIntent intent);
   virtual void onVolumeChanged(int volume);
   virtual void onAudioFocusChange(int focusChange);
-  virtual void doFrame(int64_t frameTimeNanos);
 
   // implementation of CJNIInputManagerInputDeviceListener
   void onInputDeviceAdded(int deviceId) override;
@@ -142,9 +140,6 @@ public:
   static void UnregisterInputDeviceEventHandler();
   static bool onInputDeviceEvent(const AInputEvent* event);
 
-  static void InitFrameCallback(CVideoSyncAndroid *syncImpl);
-  static void DeinitFrameCallback();
-
   static CXBMCApp* get() { return m_xbmcappinstance; }
 
 protected:
@@ -179,8 +174,6 @@ private:
   static ANativeWindow* m_window;
   static CEvent m_windowCreated;
 
-  static CVideoSyncAndroid* m_syncImpl;
-
   void XBMC_Pause(bool pause);
   void XBMC_Stop();
   bool XBMC_DestroyDisplay();
diff --git a/xbmc/platform/android/activity/android_main.cpp b/xbmc/platform/android/activity/android_main.cpp
index f97a941..98dc377 100644
--- a/xbmc/platform/android/activity/android_main.cpp
+++ b/xbmc/platform/android/activity/android_main.cpp
@@ -105,13 +105,6 @@ extern "C" JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserved)
     };
     env->RegisterNatives(cMain, &mOnNewIntent, 1);
 
-    JNINativeMethod mDoFrame = {
-      "_doFrame",
-      "(J)V",
-      (void*)&CJNIMainActivity::_doFrame
-    };
-    env->RegisterNatives(cMain, &mDoFrame, 1);
-
     JNINativeMethod mCallNative = {
       "_callNative",
       "(JJ)V",
diff --git a/xbmc/platform/android/jni/View.cpp b/xbmc/platform/android/jni/View.cpp
index 86dd5e2..cfbe9d8 100644
--- a/xbmc/platform/android/jni/View.cpp
+++ b/xbmc/platform/android/jni/View.cpp
@@ -155,14 +155,12 @@ bool CJNIViewInputDevice::isVirtual() const
     "isVirtual", "()Z");
 }
 
-/* unavailable in API-19
 bool CJNIViewInputDevice::supportsSource(int source) const
 {
   return call_method<jboolean>(m_object,
     "supportsSource", "(I)Z",
     source);
 }
-*/
 
 const CJNIList<CJNIViewInputDeviceMotionRange> CJNIViewInputDevice::getMotionRanges() const
 {
diff --git a/xbmc/platform/android/jni/View.h b/xbmc/platform/android/jni/View.h
index 4e0bae4..0805ac8 100644
--- a/xbmc/platform/android/jni/View.h
+++ b/xbmc/platform/android/jni/View.h
@@ -66,7 +66,7 @@ public:
   const CJNIOsVibrator getVibrator() const;
   bool         hasMicrophone() const;
   bool         isVirtual() const;
-  //bool         supportsSource(int source) const; /* unavailable in API-19 */
+  bool         supportsSource(int source) const;
 
   static void PopulateStaticFields();
   static int SOURCE_GAMEPAD;
diff --git a/xbmc/platform/darwin/ios/IOSEAGLView.mm b/xbmc/platform/darwin/ios/IOSEAGLView.mm
index a226c53..7ebf6ea 100644
--- a/xbmc/platform/darwin/ios/IOSEAGLView.mm
+++ b/xbmc/platform/darwin/ios/IOSEAGLView.mm
@@ -47,7 +47,6 @@
 #import "IOSScreenManager.h"
 #import "platform/darwin/AutoPool.h"
 #import "platform/darwin/DarwinUtils.h"
-#import "platform/darwin/ios-common/AnnounceReceiver.h"
 #import "XBMCDebugHelpers.h"
 
 using namespace KODI::MESSAGING;
@@ -358,9 +357,6 @@ using namespace KODI::MESSAGING;
     {
       CApplicationMessenger::GetInstance().PostMsg(TMSG_QUIT);
     }
-    
-    CAnnounceReceiver::GetInstance()->DeInitialize();
-      
     // wait for animation thread to die
     if ([animationThread isFinished] == NO)
       [animationThreadLock lockWhenCondition:TRUE];
@@ -404,8 +400,6 @@ using namespace KODI::MESSAGING;
     readyToRun = false;
     ELOG(@"%sUnable to create application", __PRETTY_FUNCTION__);
   }
-  
-  CAnnounceReceiver::GetInstance()->Initialize();
 
   if (!g_application.CreateGUI())
   {
diff --git a/xbmc/platform/darwin/ios/XBMCController.mm b/xbmc/platform/darwin/ios/XBMCController.mm
index 2f67a38..00fd94e 100644
--- a/xbmc/platform/darwin/ios/XBMCController.mm
+++ b/xbmc/platform/darwin/ios/XBMCController.mm
@@ -70,6 +70,7 @@ const NSString *MPNowPlayingInfoPropertyPlaybackQueueCount = @"MPNowPlayingInfoP
 #import "IOSEAGLView.h"
 
 #import "XBMCController.h"
+#import "platform/darwin/ios-common/AnnounceReceiver.h"
 #import "IOSScreenManager.h"
 #import "XBMCApplication.h"
 #import "XBMCDebugHelpers.h"
@@ -611,7 +612,9 @@ XBMCController *g_xbmcController;
   }
 
   [m_window makeKeyAndVisible];
-  g_xbmcController = self;
+  g_xbmcController = self;  
+  
+  CAnnounceReceiver::GetInstance()->Initialize();
 
   return self;
 }
@@ -650,6 +653,7 @@ XBMCController *g_xbmcController;
   [m_networkAutoSuspendTimer invalidate];
   [self enableNetworkAutoSuspend:nil];
 
+  CAnnounceReceiver::GetInstance()->DeInitialize();
   [m_glView stopAnimation];
   [m_glView release];
   [m_window release];
diff --git a/xbmc/platform/darwin/osx/XBMCHelper.cpp b/xbmc/platform/darwin/osx/XBMCHelper.cpp
index 2a6b55c..2c1dd03 100644
--- a/xbmc/platform/darwin/osx/XBMCHelper.cpp
+++ b/xbmc/platform/darwin/osx/XBMCHelper.cpp
@@ -36,9 +36,6 @@
 #include "settings/lib/Setting.h"
 #include "settings/Settings.h"
 #include "utils/SystemInfo.h"
-#include "filesystem/Directory.h"
-#include "filesystem/File.h"
-#include "url.h"
 
 #include "threads/Atomics.h"
 
@@ -281,8 +278,7 @@ void XBMCHelper::Install()
   // Make sure directory exists.
   std::string strDir = getenv("HOME");
   strDir += "/Library/LaunchAgents";
-  CURL url = CURL(strDir);
-  XFILE::CDirectory::Create(url);
+  CreateDirectory(strDir.c_str(), NULL);
 
   // Load template.
   std::string plistData = ReadFile(m_launchAgentLocalFile.c_str());
@@ -328,8 +324,7 @@ void XBMCHelper::Uninstall()
     Start();
 
   // Remove the plist file.
-  CURL url = CURL(m_launchAgentInstallFile);
-  XFILE::CFile::Delete(url);
+  DeleteFile(m_launchAgentInstallFile.c_str());
 }
 
 /////////////////////////////////////////////////////////////////////////////
diff --git a/xbmc/profiles/Profile.cpp b/xbmc/profiles/Profile.cpp
index 49af2a7..a8b2f1d 100644
--- a/xbmc/profiles/Profile.cpp
+++ b/xbmc/profiles/Profile.cpp
@@ -32,6 +32,7 @@ CProfile::CLock::CLock(LockType type, const std::string &password):
   music = false;
   settings = LOCK_LEVEL::NONE;
   addonManager = false;
+  games = false;
   mode = type;
 }
 
@@ -90,6 +91,7 @@ void CProfile::Load(const TiXmlNode *node, int nextIdProfile)
   XMLUtils::GetBoolean(node, "lockvideo", m_locks.video);
   XMLUtils::GetBoolean(node, "lockpictures", m_locks.pictures);
   XMLUtils::GetBoolean(node, "lockprograms", m_locks.programs);
+  XMLUtils::GetBoolean(node, "lockgames", m_locks.games);
   
   int lockMode = m_locks.mode;
   XMLUtils::GetInt(node, "lockmode", lockMode);
@@ -121,6 +123,7 @@ void CProfile::Save(TiXmlNode *root) const
   XMLUtils::SetBoolean(node, "lockvideo", m_locks.video);
   XMLUtils::SetBoolean(node, "lockpictures", m_locks.pictures);
   XMLUtils::SetBoolean(node, "lockprograms", m_locks.programs);
+  XMLUtils::SetBoolean(node, "lockgames", m_locks.games);
 
   XMLUtils::SetInt(node, "lockmode", m_locks.mode);
   XMLUtils::SetString(node,"lockcode", m_locks.code);
diff --git a/xbmc/profiles/Profile.h b/xbmc/profiles/Profile.h
index 6cf7f89..3244fc6 100644
--- a/xbmc/profiles/Profile.h
+++ b/xbmc/profiles/Profile.h
@@ -46,6 +46,7 @@ public:
     bool files;
     bool pictures;
     bool programs;
+    bool games;
   };
 
   CProfile(const std::string &directory = "", const std::string &name = "", const int id = -1);
@@ -78,6 +79,7 @@ public:
   bool picturesLocked() const { return m_locks.pictures; }
   bool filesLocked() const { return m_locks.files; }
   bool programsLocked() const { return m_locks.programs; }
+  bool gamesLocked() const { return m_locks.games; }
   const CLock &GetLocks() const { return m_locks; }
 
   void setName(const std::string& name) {m_name = name;}
diff --git a/xbmc/programs/GUIWindowPrograms.cpp b/xbmc/programs/GUIWindowPrograms.cpp
index fe550ed..142e135 100644
--- a/xbmc/programs/GUIWindowPrograms.cpp
+++ b/xbmc/programs/GUIWindowPrograms.cpp
@@ -105,6 +105,10 @@ void CGUIWindowPrograms::GetContextButtons(int itemNumber, CContextButtons &butt
     {
       CGUIDialogContextMenu::GetContextButtons("programs", item, buttons);
     }
+    else
+    {
+      buttons.Add(CONTEXT_BUTTON_GOTO_ROOT, 20128); // Go to Root
+    }
   }
   CGUIMediaWindow::GetContextButtons(itemNumber, buttons);
 }
@@ -118,6 +122,14 @@ bool CGUIWindowPrograms::OnContextButton(int itemNumber, CONTEXT_BUTTON button)
     Update("");
     return true;
   }
+  switch (button)
+  {
+  case CONTEXT_BUTTON_GOTO_ROOT:
+    Update("");
+    return true;
+  default:
+    break;
+  }
   return CGUIMediaWindow::OnContextButton(itemNumber, button);
 }
 
diff --git a/xbmc/pvr/PVRDatabase.cpp b/xbmc/pvr/PVRDatabase.cpp
index 981b5e0..2cfae7d 100644
--- a/xbmc/pvr/PVRDatabase.cpp
+++ b/xbmc/pvr/PVRDatabase.cpp
@@ -139,6 +139,42 @@ void CPVRDatabase::UpdateTables(int iVersion)
 
   if (iVersion < 28)
   {
+    VECADDONS addons;
+    CAddonDatabase database;
+    if (database.Open() && CAddonMgr::GetInstance().GetAddons(addons, ADDON_PVRDLL))
+    {
+      /** find all old client IDs */
+      std::string strQuery(PrepareSQL("SELECT idClient, sUid FROM clients"));
+      m_pDS->query(strQuery);
+      while (!m_pDS->eof() && !addons.empty())
+      {
+        /** try to find an add-on that matches the sUid */
+        for (VECADDONS::iterator it = addons.begin(); it != addons.end(); ++it)
+        {
+          if ((*it)->ID() == m_pDS->fv(1).get_asString())
+          {
+            /** try to get the current ID from the database */
+            int iAddonId = database.GetAddonId(*it);
+            /** register a new id if it didn't exist */
+            if (iAddonId <= 0)
+              iAddonId = database.AddAddon(*it, 0);
+            if (iAddonId > 0)
+            {
+              // this fails when an id becomes the id of one that's being replaced next iteration
+              // but since almost everyone only has 1 add-on enabled...
+              /** update the iClientId in the channels table */
+              strQuery = PrepareSQL("UPDATE channels SET iClientId = %u WHERE iClientId = %u", iAddonId, m_pDS->fv(0).get_asInt());
+              m_pDS->exec(strQuery);
+
+              /** no need to check this add-on again */
+              it = addons.erase(it);
+              break;
+            }
+          }
+        }
+        m_pDS->next();
+      }
+    }
     m_pDS->exec("DROP TABLE clients");
   }
 
diff --git a/xbmc/pvr/PVRManager.cpp b/xbmc/pvr/PVRManager.cpp
index 883ef2e..64fa38e 100644
--- a/xbmc/pvr/PVRManager.cpp
+++ b/xbmc/pvr/PVRManager.cpp
@@ -106,7 +106,6 @@ CPVRManager::CPVRManager(void) :
 
 CPVRManager::~CPVRManager(void)
 {
-  CSettings::GetInstance().UnregisterCallback(this);
   CAnnouncementManager::GetInstance().RemoveAnnouncer(this);
   Stop();
   m_addons.reset();
@@ -392,21 +391,7 @@ void CPVRManager::ResetProperties(void)
 
 void CPVRManager::Init()
 {
-  std::set<std::string> settingSet;
-  settingSet.insert(CSettings::SETTING_PVRMANAGER_CHANNELMANAGER);
-  settingSet.insert(CSettings::SETTING_PVRMANAGER_GROUPMANAGER);
-  settingSet.insert(CSettings::SETTING_PVRMANAGER_CHANNELSCAN);
-  settingSet.insert(CSettings::SETTING_PVRMANAGER_RESETDB);
-  settingSet.insert(CSettings::SETTING_PVRCLIENT_MENUHOOK);
-  settingSet.insert(CSettings::SETTING_PVRMENU_SEARCHICONS);
-  settingSet.insert(CSettings::SETTING_EPG_RESETEPG);
-  settingSet.insert(CSettings::SETTING_EPG_DAYSTODISPLAY);
-  settingSet.insert(CSettings::SETTING_PVRPARENTAL_ENABLED);
-  CSettings::GetInstance().RegisterCallback(this, settingSet);
-
-  // initial check for enabled addons
-  // if at least one pvr addon is enabled, PVRManager start up
-  CJobManager::GetInstance().AddJob(new CPVRStartupJob(), nullptr);
+  m_addons->Start();
 }
 
 void CPVRManager::Start()
@@ -992,12 +977,6 @@ CPVRChannelGroupPtr CPVRManager::GetPlayingGroup(bool bRadio /* = false */)
   return CPVRChannelGroupPtr();
 }
 
-bool CPVRStartupJob::DoWork(void)
-{
-  g_PVRClients->Start();
-  return true;
-}
-
 bool CPVREpgsCreateJob::DoWork(void)
 {
   return g_PVRManager.CreateChannelEpgs();
diff --git a/xbmc/pvr/PVRManager.h b/xbmc/pvr/PVRManager.h
index 1f391e2..41329f6 100644
--- a/xbmc/pvr/PVRManager.h
+++ b/xbmc/pvr/PVRManager.h
@@ -687,16 +687,6 @@ private:
     static const int                m_pvrWindowIds[12];
   };
 
-  class CPVRStartupJob : public CJob
-  {
-  public:
-    CPVRStartupJob(void) {}
-    virtual ~CPVRStartupJob() {}
-    virtual const char *GetType() const { return "pvr-startup"; }
-
-    virtual bool DoWork();
-  };
-
   class CPVREpgsCreateJob : public CJob
   {
   public:
diff --git a/xbmc/pvr/addons/PVRClients.cpp b/xbmc/pvr/addons/PVRClients.cpp
index 780c368..4ab6b1d 100644
--- a/xbmc/pvr/addons/PVRClients.cpp
+++ b/xbmc/pvr/addons/PVRClients.cpp
@@ -236,13 +236,13 @@ bool CPVRClients::HasCreatedClients(void) const
 {
   CSingleLock lock(m_critSection);
 
-  for (auto &client : m_clientMap)
-  {
-    if (client.second->ReadyToUse() && !client.second->IgnoreClient())
+  for (PVR_CLIENTMAP_CITR itr = m_clientMap.begin(); itr != m_clientMap.end(); itr++)
+    if (itr->second->ReadyToUse())
     {
-      return true;
+      PVR_CONNECTION_STATE state = itr->second->GetConnectionState();
+      if (state != PVR_CONNECTION_STATE_CONNECTING)
+        return true;
     }
-  }
 
   return false;
 }
@@ -337,7 +337,8 @@ int CPVRClients::GetCreatedClients(PVR_CLIENTMAP &clients) const
   {
     if (itr->second->ReadyToUse())
     {
-      if (itr->second->IgnoreClient())
+      PVR_CONNECTION_STATE state = itr->second->GetConnectionState();
+      if (state == PVR_CONNECTION_STATE_CONNECTING)
         continue;
       
       clients.insert(std::make_pair(itr->second->GetID(), itr->second));
@@ -1155,12 +1156,11 @@ void CPVRClients::UpdateAddons(void)
       if (iClientId < 0)
         iClientId = -iClientId;
 
-      ADDON_STATUS status;
       if (IsKnownClient(addon))
       {
         PVR_CLIENT client;
         GetClient(iClientId, client);
-        status = client->Create(iClientId);
+        client->Create(iClientId);
       }
       else
       {
@@ -1170,7 +1170,7 @@ void CPVRClients::UpdateAddons(void)
           CLog::Log(LOGERROR, "CPVRClients::UpdateAndInitialiseClients - severe error, incorrect add type");
           continue;
         }
-        status = pvrclient.get()->Create(iClientId);
+        pvrclient.get()->Create(iClientId);
         // register the add-on
         if (m_clientMap.find(iClientId) == m_clientMap.end())
         {
@@ -1178,16 +1178,6 @@ void CPVRClients::UpdateAddons(void)
           m_addonNameIds.insert(make_pair(addon->ID(), iClientId));
         }
       }
-
-      if (status != ADDON_STATUS_OK)
-      {
-        CLog::Log(LOGERROR, "%s - failed to create add-on %s, status = %d", __FUNCTION__, addon->Name().c_str(), status);
-        if (status == ADDON_STATUS_PERMANENT_FAILURE)
-        {
-          CGUIDialogOK::ShowAndGetInput(CVariant{24070}, CVariant{16029});
-          CAddonMgr::GetInstance().DisableAddon(addon->ID());
-        }
-      }
     }
     else if (!bEnabled && IsCreatedClient(addon))
     {
@@ -1572,9 +1562,6 @@ void CPVRClients::ConnectionStateChange(int clientId, std::string &strConnection
     case PVR_CONNECTION_STATE_CONNECTED:
       bError = false;
       iMsg = 36034; // Connection established
-      if (client->GetPreviousConnectionState() == PVR_CONNECTION_STATE_UNKNOWN ||
-          client->GetPreviousConnectionState() == PVR_CONNECTION_STATE_CONNECTING)
-        bNotify = false;
       break;
     case PVR_CONNECTION_STATE_DISCONNECTED:
       iMsg = 36030; // Connection lost
diff --git a/xbmc/pvr/windows/GUIWindowPVRBase.cpp b/xbmc/pvr/windows/GUIWindowPVRBase.cpp
index d5bc527..175b252 100644
--- a/xbmc/pvr/windows/GUIWindowPVRBase.cpp
+++ b/xbmc/pvr/windows/GUIWindowPVRBase.cpp
@@ -295,7 +295,7 @@ bool CGUIWindowPVRBase::OnContextButtonActiveAEDSPSettings(CFileItem *item, CONT
   {
     bReturn = true;
 
-    if (CServiceBroker::GetADSP().IsProcessing())
+    if (ActiveAE::CActiveAEDSP::GetInstance().IsProcessing())
       g_windowManager.ActivateWindow(WINDOW_DIALOG_AUDIO_DSP_OSD_SETTINGS);
   }
 
diff --git a/xbmc/pvr/windows/GUIWindowPVRChannels.cpp b/xbmc/pvr/windows/GUIWindowPVRChannels.cpp
index 85a3b71..e311cd3 100644
--- a/xbmc/pvr/windows/GUIWindowPVRChannels.cpp
+++ b/xbmc/pvr/windows/GUIWindowPVRChannels.cpp
@@ -87,7 +87,7 @@ void CGUIWindowPVRChannels::GetContextButtons(int itemNumber, CContextButtons &b
   else if (g_PVRClients->SupportsTimers(channel->ClientID()))
     buttons.Add(CONTEXT_BUTTON_START_RECORD, 264);   /* Record */
 
-  if (CServiceBroker::GetADSP().IsProcessing())
+  if (ActiveAE::CActiveAEDSP::GetInstance().IsProcessing())
     buttons.Add(CONTEXT_BUTTON_ACTIVE_ADSP_SETTINGS, 15047);                        /* Audio DSP settings */
 
   if (g_PVRClients->HasMenuHooks(channel->ClientID(), PVR_MENUHOOK_CHANNEL))
diff --git a/xbmc/pvr/windows/GUIWindowPVRRecordings.cpp b/xbmc/pvr/windows/GUIWindowPVRRecordings.cpp
index 8da4f9a..47897b7 100644
--- a/xbmc/pvr/windows/GUIWindowPVRRecordings.cpp
+++ b/xbmc/pvr/windows/GUIWindowPVRRecordings.cpp
@@ -157,7 +157,7 @@ void CGUIWindowPVRRecordings::GetContextButtons(int itemNumber, CContextButtons
     buttons.Add(CONTEXT_BUTTON_DELETE, 117);        /* Delete */
   }
 
-  if (CServiceBroker::GetADSP().IsProcessing())
+  if (ActiveAE::CActiveAEDSP::GetInstance().IsProcessing())
     buttons.Add(CONTEXT_BUTTON_ACTIVE_ADSP_SETTINGS, 15047);  /* Audio DSP settings */
 
   if (recording)
diff --git a/xbmc/rendering/dx/CMakeLists.txt b/xbmc/rendering/dx/CMakeLists.txt
index 26d4ec8..38f5d5b 100644
--- a/xbmc/rendering/dx/CMakeLists.txt
+++ b/xbmc/rendering/dx/CMakeLists.txt
@@ -5,7 +5,3 @@ set(HEADERS GUIWindowTestPatternDX.h
             RenderSystemDX.h)
 
 core_add_library(rendering_dx)
-
-if(CORE_SYSTEM_NAME STREQUAL windows)
-  add_dependencies(rendering_dx d3dx11effects)
-endif()
diff --git a/xbmc/rendering/dx/RenderSystemDX.cpp b/xbmc/rendering/dx/RenderSystemDX.cpp
index 9f89112..b90d15e 100644
--- a/xbmc/rendering/dx/RenderSystemDX.cpp
+++ b/xbmc/rendering/dx/RenderSystemDX.cpp
@@ -402,7 +402,7 @@ void CRenderSystemDX::SetFullScreenInternal()
   }
 end:
   // in windowed mode DWM uses triple buffering in any case. 
-  // for FSEM we use double buffering to avoid possible shuttering/tearing
+  // for FSEM we use double buffering
   SetMaximumFrameLatency(2 - m_useWindowedDX);
 }
 
@@ -756,9 +756,7 @@ bool CRenderSystemDX::CreateWindowSizeDependentResources()
   if (m_pSwapChain)
   {
     m_pSwapChain->GetDesc(&scDesc);
-    bNeedResize = m_bResizeRequred || 
-                  m_nBackBufferWidth != scDesc.BufferDesc.Width || 
-                  m_nBackBufferHeight != scDesc.BufferDesc.Height;
+    bNeedResize = m_bResizeRequred || m_nBackBufferWidth != scDesc.BufferDesc.Width || m_nBackBufferHeight != scDesc.BufferDesc.Height;
   }
   else
     bNeedResize = true;
@@ -767,7 +765,7 @@ bool CRenderSystemDX::CreateWindowSizeDependentResources()
   {
     DXGI_SWAP_CHAIN_DESC1 scDesc;
     m_pSwapChain1->GetDesc1(&scDesc);
-    bNeedRecreate = scDesc.Stereo != bHWStereoEnabled;
+    bNeedRecreate = (scDesc.Stereo && !bHWStereoEnabled) || (!scDesc.Stereo && bHWStereoEnabled);
   }
 
   if (!bNeedRecreate && !bNeedResize)
@@ -802,12 +800,6 @@ bool CRenderSystemDX::CreateWindowSizeDependentResources()
 
   if (bNeedRecreate)
   {
-    if (!m_bResizeRequred)
-    {
-      OnDisplayLost();
-      m_bResizeRequred = true;
-    }
-
     BOOL fullScreen;
     m_pSwapChain1->GetFullscreenState(&fullScreen, NULL);
     if (fullScreen)
@@ -855,20 +847,6 @@ bool CRenderSystemDX::CreateWindowSizeDependentResources()
 
       hr = dxgiFactory2->CreateSwapChainForHwnd(m_pD3DDev, m_hFocusWnd, &scDesc1, &scFSDesc, NULL, &m_pSwapChain1);
 
-      // some drivers (AMD) are denied to switch in stereoscopic 3D mode, if so then fallback to mono mode
-      if (FAILED(hr) && bHWStereoEnabled)
-      {
-        // switch to stereo mode failed, create mono swapchain
-        CLog::Log(LOGERROR, "%s - Creating stereo swap chain failed with error: %s.", __FUNCTION__, GetErrorDescription(hr).c_str());
-        CLog::Log(LOGNOTICE, "%s - Fallback to monoscopic mode.", __FUNCTION__);
-
-        scDesc1.Stereo = false;
-        hr = dxgiFactory2->CreateSwapChainForHwnd(m_pD3DDev, m_hFocusWnd, &scDesc1, &scFSDesc, NULL, &m_pSwapChain1);
-
-        // fallback to split_horisontal mode.
-        g_graphicsContext.SetStereoMode(RENDER_STEREO_MODE_SPLIT_HORIZONTAL);
-      }
-
       if (SUCCEEDED(hr))
       {
         m_pSwapChain1->QueryInterface(__uuidof(IDXGISwapChain), reinterpret_cast<void**>(&m_pSwapChain));
@@ -888,6 +866,17 @@ bool CRenderSystemDX::CreateWindowSizeDependentResources()
         }
         m_bHWStereoEnabled = bHWStereoEnabled;
       }
+      else if (bHWStereoEnabled)
+      {
+        // switch to stereo mode failed, create mono swapchain
+        CLog::Log(LOGERROR, "%s - Creating swap chain failed with error: %s.", __FUNCTION__, GetErrorDescription(hr).c_str());
+
+        scDesc1.Stereo = false;
+        hr = dxgiFactory2->CreateSwapChainForHwnd(m_pD3DDev, m_hFocusWnd, &scDesc1, &scFSDesc, NULL, &m_pSwapChain1);
+
+        // fallback to split_horisontal mode.
+        g_graphicsContext.SetStereoMode(RENDER_STEREO_MODE_SPLIT_HORIZONTAL);
+      }
       dxgiFactory2->Release();
     }
     else
@@ -962,6 +951,7 @@ bool CRenderSystemDX::CreateWindowSizeDependentResources()
     if (FAILED(hr))
     {
       CLog::Log(LOGERROR, "%s - Failed to create right eye buffer (%s).", __FUNCTION__, GetErrorDescription(hr).c_str());
+      pBackBuffer->Release();
       g_graphicsContext.SetStereoMode(RENDER_STEREO_MODE_OFF); // try fallback to mono
     }
   }
@@ -1259,8 +1249,6 @@ bool CRenderSystemDX::BeginRender()
     break;
   case DXGI_ERROR_INVALID_CALL: // application provided invalid parameter data. Try to return after resize buffers
     CLog::Log(LOGERROR, "DXGI_ERROR_INVALID_CALL");
-    // in most cases when DXGI_ERROR_INVALID_CALL occurs it means what DXGI silently leaves from FSE mode.
-    // if so, we should return for FSE mode and resize buffers
     SetFullScreenInternal();
     CreateWindowSizeDependentResources();
     m_nDeviceStatus = S_OK;
diff --git a/xbmc/rendering/gl/RenderSystemGL.cpp b/xbmc/rendering/gl/RenderSystemGL.cpp
index 4ae5664..698e6b3 100644
--- a/xbmc/rendering/gl/RenderSystemGL.cpp
+++ b/xbmc/rendering/gl/RenderSystemGL.cpp
@@ -34,9 +34,6 @@
 #include "utils/SystemInfo.h"
 #include "utils/MathUtils.h"
 #include "utils/StringUtils.h"
-#ifdef TARGET_POSIX
-#include "linux/XTimeUtils.h"
-#endif
 
 CRenderSystemGL::CRenderSystemGL() : CRenderSystemBase()
 {
diff --git a/xbmc/settings/AdvancedSettings.cpp b/xbmc/settings/AdvancedSettings.cpp
index 2adc1f5..822c7e8 100644
--- a/xbmc/settings/AdvancedSettings.cpp
+++ b/xbmc/settings/AdvancedSettings.cpp
@@ -397,7 +397,7 @@ void CAdvancedSettings::Initialize()
 
   m_videoAssFixedWorks = false;
 
-  m_logLevelHint = m_logLevel = LOG_LEVEL_NORMAL;
+  m_logLevelHint = m_logLevel = LOG_LEVEL_DEBUG;
   m_extraLogEnabled = false;
   m_extraLogLevels = 0;
 
diff --git a/xbmc/settings/MediaSourceSettings.cpp b/xbmc/settings/MediaSourceSettings.cpp
index d4f725e..0303faa 100644
--- a/xbmc/settings/MediaSourceSettings.cpp
+++ b/xbmc/settings/MediaSourceSettings.cpp
@@ -107,6 +107,7 @@ bool CMediaSourceSettings::Load(const std::string &file)
   GetSources(pRootElement, "pictures", m_pictureSources, m_defaultPictureSource);
   GetSources(pRootElement, "files", m_fileSources, m_defaultFileSource);
   GetSources(pRootElement, "music", m_musicSources, m_defaultMusicSource);
+  GetSources(pRootElement, "games", m_gameSources, dummy);
 
   return true;
 }
@@ -131,6 +132,7 @@ bool CMediaSourceSettings::Save(const std::string &file) const
   SetSources(pRoot, "music", m_musicSources, m_defaultMusicSource);
   SetSources(pRoot, "pictures", m_pictureSources, m_defaultPictureSource);
   SetSources(pRoot, "files", m_fileSources, m_defaultFileSource);
+  SetSources(pRoot, "games", m_gameSources, "");
 
   CWakeOnAccess::GetInstance().QueueMACDiscoveryForAllRemotes();
 
@@ -144,6 +146,7 @@ void CMediaSourceSettings::Clear()
   m_fileSources.clear();
   m_musicSources.clear();
   m_videoSources.clear();
+  m_gameSources.clear();
 }
 
 VECSOURCES* CMediaSourceSettings::GetSources(const std::string &type)
@@ -158,6 +161,8 @@ VECSOURCES* CMediaSourceSettings::GetSources(const std::string &type)
     return &m_videoSources;
   else if (type == "pictures")
     return &m_pictureSources;
+  else if (type == "games")
+    return &m_gameSources;
 
   return NULL;
 }
diff --git a/xbmc/settings/MediaSourceSettings.h b/xbmc/settings/MediaSourceSettings.h
index a7568e2..15add51 100644
--- a/xbmc/settings/MediaSourceSettings.h
+++ b/xbmc/settings/MediaSourceSettings.h
@@ -67,6 +67,7 @@ private:
   VECSOURCES m_fileSources;
   VECSOURCES m_musicSources;
   VECSOURCES m_videoSources;
+  VECSOURCES m_gameSources;
 
   std::string m_defaultProgramSource;
   std::string m_defaultMusicSource;
diff --git a/xbmc/settings/Settings.cpp b/xbmc/settings/Settings.cpp
index d3254f2..c68101c 100644
--- a/xbmc/settings/Settings.cpp
+++ b/xbmc/settings/Settings.cpp
@@ -30,9 +30,11 @@
 #include "addons/RepositoryUpdater.h"
 #include "addons/Skin.h"
 #include "cores/AudioEngine/AEFactory.h"
+#include "cores/AudioEngine/DSPAddons/ActiveAEDSP.h"
 #include "cores/playercorefactory/PlayerCoreFactory.h"
 #include "cores/VideoPlayer/VideoRenderers/BaseRenderer.h"
 #include "filesystem/File.h"
+#include "games/GameSettings.h"
 #include "guilib/GraphicContext.h"
 #include "guilib/GUIAudioManager.h"
 #include "guilib/GUIFontManager.h"
@@ -62,6 +64,7 @@
 #include "peripherals/Peripherals.h"
 #include "powermanagement/PowerManager.h"
 #include "profiles/ProfilesManager.h"
+#include "pvr/PVRManager.h"
 #include "pvr/PVRSettings.h"
 #include "pvr/windows/GUIWindowPVRGuide.h"
 #include "settings/AdvancedSettings.h"
@@ -366,7 +369,6 @@ const std::string CSettings::SETTING_AUDIOOUTPUT_TRUEHDPASSTHROUGH = "audiooutpu
 const std::string CSettings::SETTING_AUDIOOUTPUT_DTSHDPASSTHROUGH = "audiooutput.dtshdpassthrough";
 const std::string CSettings::SETTING_INPUT_PERIPHERALS = "input.peripherals";
 const std::string CSettings::SETTING_INPUT_ENABLEMOUSE = "input.enablemouse";
-const std::string CSettings::SETTING_INPUT_CONTROLLERCONFIG = "input.controllerconfig";
 const std::string CSettings::SETTING_INPUT_APPLEREMOTEMODE = "input.appleremotemode";
 const std::string CSettings::SETTING_INPUT_APPLEREMOTEALWAYSON = "input.appleremotealwayson";
 const std::string CSettings::SETTING_INPUT_APPLEREMOTESEQUENCETIME = "input.appleremotesequencetime";
@@ -409,6 +411,12 @@ const std::string CSettings::SETTING_ADDONS_ALLOW_UNKNOWN_SOURCES = "addons.unkn
 const std::string CSettings::SETTING_ADDONS_MANAGE_DEPENDENCIES = "addons.managedependencies";
 const std::string CSettings::SETTING_GENERAL_ADDONFOREIGNFILTER = "general.addonforeignfilter";
 const std::string CSettings::SETTING_GENERAL_ADDONBROKENFILTER = "general.addonbrokenfilter";
+const std::string CSettings::SETTING_GAMES_CONTROLLERCONFIG = "gamesinput.controllerconfig";
+const std::string CSettings::SETTING_GAMES_EMULATEDCONTROLLERS = "gamesinput.emulatedcontrollers";
+const std::string CSettings::SETTING_GAMES_EMULATEDCONTROLLER1 = "gamesinput.emulatedcontroller1";
+const std::string CSettings::SETTING_GAMES_EMULATEDCONTROLLER2 = "gamesinput.emulatedcontroller2";
+const std::string CSettings::SETTING_GAMES_EMULATEDCONTROLLER3 = "gamesinput.emulatedcontroller3";
+const std::string CSettings::SETTING_GAMES_EMULATEDCONTROLLER4 = "gamesinput.emulatedcontroller4";
 
 CSettings::CSettings()
   : m_initialized(false)
@@ -605,8 +613,10 @@ void CSettings::Uninitialize()
   m_settingsManager->UnregisterCallback(&CInputManager::GetInstance());
   m_settingsManager->UnregisterCallback(&CNetworkServices::GetInstance());
   m_settingsManager->UnregisterCallback(&g_passwordManager);
+  m_settingsManager->UnregisterCallback(&PVR::g_PVRManager);
   m_settingsManager->UnregisterCallback(&CRssManager::GetInstance());
   m_settingsManager->UnregisterCallback(&ADDON::CRepositoryUpdater::GetInstance());
+  m_settingsManager->UnregisterCallback(&GAME::CGameSettings::GetInstance());
 #if defined(TARGET_LINUX)
   m_settingsManager->UnregisterCallback(&g_timezone);
 #endif // defined(TARGET_LINUX)
@@ -615,6 +625,7 @@ void CSettings::Uninitialize()
 #if defined(TARGET_DARWIN_OSX)
   m_settingsManager->UnregisterCallback(&XBMCHelper::GetInstance());
 #endif
+  m_settingsManager->UnregisterCallback(&ActiveAE::CActiveAEDSP::GetInstance());
   m_settingsManager->UnregisterCallback(&CWakeOnAccess::GetInstance());
 
   // cleanup the settings manager
@@ -1141,6 +1152,18 @@ void CSettings::InitializeISettingCallbacks()
   m_settingsManager->RegisterCallback(&g_passwordManager, settingSet);
 
   settingSet.clear();
+  settingSet.insert(CSettings::SETTING_PVRMANAGER_CHANNELMANAGER);
+  settingSet.insert(CSettings::SETTING_PVRMANAGER_GROUPMANAGER);
+  settingSet.insert(CSettings::SETTING_PVRMANAGER_CHANNELSCAN);
+  settingSet.insert(CSettings::SETTING_PVRMANAGER_RESETDB);
+  settingSet.insert(CSettings::SETTING_PVRCLIENT_MENUHOOK);
+  settingSet.insert(CSettings::SETTING_PVRMENU_SEARCHICONS);
+  settingSet.insert(CSettings::SETTING_EPG_RESETEPG);
+  settingSet.insert(CSettings::SETTING_EPG_DAYSTODISPLAY);
+  settingSet.insert(CSettings::SETTING_PVRPARENTAL_ENABLED);
+  m_settingsManager->RegisterCallback(&PVR::g_PVRManager, settingSet);
+
+  settingSet.clear();
   settingSet.insert(CSettings::SETTING_LOOKANDFEEL_RSSEDIT);
   m_settingsManager->RegisterCallback(&CRssManager::GetInstance(), settingSet);
 
@@ -1158,7 +1181,6 @@ void CSettings::InitializeISettingCallbacks()
 
   settingSet.clear();
   settingSet.insert(CSettings::SETTING_INPUT_PERIPHERALS);
-  settingSet.insert(CSettings::SETTING_INPUT_CONTROLLERCONFIG);
   settingSet.insert(CSettings::SETTING_LOCALE_LANGUAGE);
   m_settingsManager->RegisterCallback(&PERIPHERALS::CPeripherals::GetInstance(), settingSet);
 
@@ -1170,6 +1192,12 @@ void CSettings::InitializeISettingCallbacks()
 #endif
 
   settingSet.clear();
+  settingSet.insert(CSettings::SETTING_AUDIOOUTPUT_DSPADDONSENABLED);
+  settingSet.insert(CSettings::SETTING_AUDIOOUTPUT_DSPSETTINGS);
+  settingSet.insert(CSettings::SETTING_AUDIOOUTPUT_DSPRESETDB);
+  m_settingsManager->RegisterCallback(&ActiveAE::CActiveAEDSP::GetInstance(), settingSet);
+
+  settingSet.clear();
   settingSet.insert(CSettings::SETTING_ADDONS_AUTOUPDATES);
   m_settingsManager->RegisterCallback(&ADDON::CRepositoryUpdater::GetInstance(), settingSet);
 
@@ -1182,6 +1210,15 @@ void CSettings::InitializeISettingCallbacks()
   settingSet.clear();
   settingSet.insert(CSettings::SETTING_POWERMANAGEMENT_WAKEONACCESS);
   m_settingsManager->RegisterCallback(&CWakeOnAccess::GetInstance(), settingSet);
+
+  settingSet.clear();
+  settingSet.insert(CSettings::SETTING_GAMES_CONTROLLERCONFIG);
+  settingSet.insert(CSettings::SETTING_GAMES_EMULATEDCONTROLLERS);
+  settingSet.insert(CSettings::SETTING_GAMES_EMULATEDCONTROLLER1);
+  settingSet.insert(CSettings::SETTING_GAMES_EMULATEDCONTROLLER2);
+  settingSet.insert(CSettings::SETTING_GAMES_EMULATEDCONTROLLER3);
+  settingSet.insert(CSettings::SETTING_GAMES_EMULATEDCONTROLLER4);
+  m_settingsManager->RegisterCallback(&GAME::CGameSettings::GetInstance(), settingSet);
 }
 
 bool CSettings::Reset()
diff --git a/xbmc/settings/Settings.h b/xbmc/settings/Settings.h
index 27a69b3..17bbf8b 100644
--- a/xbmc/settings/Settings.h
+++ b/xbmc/settings/Settings.h
@@ -324,7 +324,6 @@ public:
   static const std::string SETTING_AUDIOOUTPUT_DTSHDPASSTHROUGH;
   static const std::string SETTING_INPUT_PERIPHERALS;
   static const std::string SETTING_INPUT_ENABLEMOUSE;
-  static const std::string SETTING_INPUT_CONTROLLERCONFIG;
   static const std::string SETTING_INPUT_APPLEREMOTEMODE;
   static const std::string SETTING_INPUT_APPLEREMOTEALWAYSON;
   static const std::string SETTING_INPUT_APPLEREMOTESEQUENCETIME;
@@ -367,6 +366,12 @@ public:
   static const std::string SETTING_ADDONS_ALLOW_UNKNOWN_SOURCES;
   static const std::string SETTING_GENERAL_ADDONFOREIGNFILTER;
   static const std::string SETTING_GENERAL_ADDONBROKENFILTER;
+  static const std::string SETTING_GAMES_CONTROLLERCONFIG;
+  static const std::string SETTING_GAMES_EMULATEDCONTROLLERS;
+  static const std::string SETTING_GAMES_EMULATEDCONTROLLER1;
+  static const std::string SETTING_GAMES_EMULATEDCONTROLLER2;
+  static const std::string SETTING_GAMES_EMULATEDCONTROLLER3;
+  static const std::string SETTING_GAMES_EMULATEDCONTROLLER4;
 
   /*!
    \brief Creates a new settings wrapper around a new settings manager.
diff --git a/xbmc/settings/dialogs/GUIDialogAudioDSPManager.cpp b/xbmc/settings/dialogs/GUIDialogAudioDSPManager.cpp
index f4873c2..acd7104 100644
--- a/xbmc/settings/dialogs/GUIDialogAudioDSPManager.cpp
+++ b/xbmc/settings/dialogs/GUIDialogAudioDSPManager.cpp
@@ -559,7 +559,7 @@ bool CGUIDialogAudioDSPManager::OnContextButton(int itemNumber, CONTEXT_BUTTON b
     * Open audio dsp addon mode help text dialog
     */
     AE_DSP_ADDON addon;
-    if (CServiceBroker::GetADSP().GetAudioDSPAddon((int)pItem->GetProperty("AddonId").asInteger(), addon))
+    if (CActiveAEDSP::GetInstance().GetAudioDSPAddon((int)pItem->GetProperty("AddonId").asInteger(), addon))
     {
       CGUIDialogTextViewer* pDlgInfo = (CGUIDialogTextViewer*)g_windowManager.GetWindow(WINDOW_DIALOG_TEXT_VIEWER);
       pDlgInfo->SetHeading(g_localizeStrings.Get(15062) + " - " + pItem->GetProperty("Name").asString());
@@ -655,7 +655,7 @@ bool CGUIDialogAudioDSPManager::OnContextButton(int itemNumber, CONTEXT_BUTTON b
     if (hookId > 0)
     {
       AE_DSP_ADDON addon;
-      if (CServiceBroker::GetADSP().GetAudioDSPAddon((int)pItem->GetProperty("AddonId").asInteger(), addon))
+      if (CActiveAEDSP::GetInstance().GetAudioDSPAddon((int)pItem->GetProperty("AddonId").asInteger(), addon))
       {
         AE_DSP_MENUHOOK       hook;
         AE_DSP_MENUHOOK_DATA  hookData;
@@ -792,7 +792,7 @@ void CGUIDialogAudioDSPManager::SaveList(void)
   /* persist all modes */
   if (UpdateDatabase(pDlgBusy))
   {
-    CServiceBroker::GetADSP().TriggerModeUpdate();
+    CActiveAEDSP::GetInstance().TriggerModeUpdate();
 
     m_bContainsChanges = false;
     SetItemsUnchanged();
@@ -959,13 +959,13 @@ CFileItem *CGUIDialogAudioDSPManager::helper_CreateModeListItem(CActiveAEDSPMode
   const int AddonID = ModePointer->AddonID();
 
   std::string addonName;
-  if (!CServiceBroker::GetADSP().GetAudioDSPAddonName(AddonID, addonName))
+  if (!CActiveAEDSP::GetInstance().GetAudioDSPAddonName(AddonID, addonName))
   {
     return pItem;
   }
 
   AE_DSP_ADDON addon;
-  if (!CServiceBroker::GetADSP().GetAudioDSPAddon(AddonID, addon))
+  if (!CActiveAEDSP::GetInstance().GetAudioDSPAddon(AddonID, addon))
   {
     return pItem;
   }
@@ -1033,7 +1033,7 @@ int CGUIDialogAudioDSPManager::helper_GetDialogId(CActiveAEDSPModePtr &ModePoint
     AE_DSP_MENUHOOKS hooks;
 
     // Find first general settings dialog about mode
-    if (CServiceBroker::GetADSP().GetMenuHooks(ModePointer->AddonID(), AE_DSP_MENUHOOK_SETTING, hooks))
+    if (CActiveAEDSP::GetInstance().GetMenuHooks(ModePointer->AddonID(), AE_DSP_MENUHOOK_SETTING, hooks))
     {
       for (unsigned int i = 0; i < hooks.size() && dialogId == 0; i++)
       {
@@ -1045,7 +1045,7 @@ int CGUIDialogAudioDSPManager::helper_GetDialogId(CActiveAEDSPModePtr &ModePoint
     }
 
     // If nothing was present, check for playback settings
-    if (dialogId == 0 && CServiceBroker::GetADSP().GetMenuHooks(ModePointer->AddonID(), MenuHook, hooks))
+    if (dialogId == 0 && CActiveAEDSP::GetInstance().GetMenuHooks(ModePointer->AddonID(), MenuHook, hooks))
     {
       for (unsigned int i = 0; i < hooks.size() && (dialogId == 0 || dialogId != -1); i++)
       {
diff --git a/xbmc/settings/dialogs/GUIDialogAudioDSPSettings.cpp b/xbmc/settings/dialogs/GUIDialogAudioDSPSettings.cpp
index 04eb2ff..19b8c5c 100644
--- a/xbmc/settings/dialogs/GUIDialogAudioDSPSettings.cpp
+++ b/xbmc/settings/dialogs/GUIDialogAudioDSPSettings.cpp
@@ -229,11 +229,11 @@ void CGUIDialogAudioDSPSettings::FrameMove()
       m_settingsManager->SetNumber(SETTING_AUDIO_POST_PROC_AUDIO_DELAY, videoSettings.m_AudioDelay);
 
     bool forceReload = false;
-    unsigned int  streamId = CServiceBroker::GetADSP().GetActiveStreamId();
+    unsigned int  streamId = CActiveAEDSP::GetInstance().GetActiveStreamId();
     if (m_ActiveStreamId != streamId)
     {
       m_ActiveStreamId      = streamId;
-      m_ActiveStreamProcess = CServiceBroker::GetADSP().GetDSPProcess(m_ActiveStreamId);
+      m_ActiveStreamProcess = CActiveAEDSP::GetInstance().GetDSPProcess(m_ActiveStreamId);
       if (m_ActiveStreamId == (unsigned int)-1 || !m_ActiveStreamProcess)
       {
         Close(true);
@@ -447,8 +447,8 @@ void CGUIDialogAudioDSPSettings::InitializeSettings()
   if (g_application.m_pPlayer->HasPlayer())
     g_application.m_pPlayer->GetAudioCapabilities(m_audioCaps);
 
-  m_ActiveStreamId      = CServiceBroker::GetADSP().GetActiveStreamId();
-  m_ActiveStreamProcess = CServiceBroker::GetADSP().GetDSPProcess(m_ActiveStreamId);
+  m_ActiveStreamId      = CActiveAEDSP::GetInstance().GetActiveStreamId();
+  m_ActiveStreamProcess = CActiveAEDSP::GetInstance().GetDSPProcess(m_ActiveStreamId);
   if (m_ActiveStreamId == (unsigned int)-1 || !m_ActiveStreamProcess)
   {
     m_iCategory = FindCategoryIndex(SETTING_AUDIO_CAT_MAIN);
@@ -472,21 +472,21 @@ void CGUIDialogAudioDSPSettings::InitializeSettings()
     /* about size() > 1, it is always the fallback (ignore of master processing) present. */
     StaticIntegerSettingOptions modeEntries;
     if (m_MasterModes[AE_DSP_ASTREAM_BASIC].size() > 1)
-      modeEntries.push_back(std::pair<int, int>(CServiceBroker::GetADSP().GetStreamTypeName(AE_DSP_ASTREAM_BASIC),   AE_DSP_ASTREAM_BASIC));
+      modeEntries.push_back(std::pair<int, int>(CActiveAEDSP::GetInstance().GetStreamTypeName(AE_DSP_ASTREAM_BASIC),   AE_DSP_ASTREAM_BASIC));
     if (m_MasterModes[AE_DSP_ASTREAM_MUSIC].size() > 1)
-      modeEntries.push_back(std::pair<int, int>(CServiceBroker::GetADSP().GetStreamTypeName(AE_DSP_ASTREAM_MUSIC),   AE_DSP_ASTREAM_MUSIC));
+      modeEntries.push_back(std::pair<int, int>(CActiveAEDSP::GetInstance().GetStreamTypeName(AE_DSP_ASTREAM_MUSIC),   AE_DSP_ASTREAM_MUSIC));
     if (m_MasterModes[AE_DSP_ASTREAM_MOVIE].size() > 1)
-      modeEntries.push_back(std::pair<int, int>(CServiceBroker::GetADSP().GetStreamTypeName(AE_DSP_ASTREAM_MOVIE),   AE_DSP_ASTREAM_MOVIE));
+      modeEntries.push_back(std::pair<int, int>(CActiveAEDSP::GetInstance().GetStreamTypeName(AE_DSP_ASTREAM_MOVIE),   AE_DSP_ASTREAM_MOVIE));
     if (m_MasterModes[AE_DSP_ASTREAM_GAME].size() > 1)
-      modeEntries.push_back(std::pair<int, int>(CServiceBroker::GetADSP().GetStreamTypeName(AE_DSP_ASTREAM_GAME),    AE_DSP_ASTREAM_GAME));
+      modeEntries.push_back(std::pair<int, int>(CActiveAEDSP::GetInstance().GetStreamTypeName(AE_DSP_ASTREAM_GAME),    AE_DSP_ASTREAM_GAME));
     if (m_MasterModes[AE_DSP_ASTREAM_APP].size() > 1)
-      modeEntries.push_back(std::pair<int, int>(CServiceBroker::GetADSP().GetStreamTypeName(AE_DSP_ASTREAM_APP),     AE_DSP_ASTREAM_APP));
+      modeEntries.push_back(std::pair<int, int>(CActiveAEDSP::GetInstance().GetStreamTypeName(AE_DSP_ASTREAM_APP),     AE_DSP_ASTREAM_APP));
     if (m_MasterModes[AE_DSP_ASTREAM_MESSAGE].size() > 1)
-      modeEntries.push_back(std::pair<int, int>(CServiceBroker::GetADSP().GetStreamTypeName(AE_DSP_ASTREAM_MESSAGE), AE_DSP_ASTREAM_MESSAGE));
+      modeEntries.push_back(std::pair<int, int>(CActiveAEDSP::GetInstance().GetStreamTypeName(AE_DSP_ASTREAM_MESSAGE), AE_DSP_ASTREAM_MESSAGE));
     if (m_MasterModes[AE_DSP_ASTREAM_PHONE].size() > 1)
-      modeEntries.push_back(std::pair<int, int>(CServiceBroker::GetADSP().GetStreamTypeName(AE_DSP_ASTREAM_PHONE),   AE_DSP_ASTREAM_PHONE));
+      modeEntries.push_back(std::pair<int, int>(CActiveAEDSP::GetInstance().GetStreamTypeName(AE_DSP_ASTREAM_PHONE),   AE_DSP_ASTREAM_PHONE));
     if (modesAvailable > 1 && m_MasterModes[m_streamTypeUsed].size() > 1)
-      modeEntries.insert(modeEntries.begin(), std::pair<int, int>(CServiceBroker::GetADSP().GetStreamTypeName(AE_DSP_ASTREAM_AUTO), AE_DSP_ASTREAM_AUTO));
+      modeEntries.insert(modeEntries.begin(), std::pair<int, int>(CActiveAEDSP::GetInstance().GetStreamTypeName(AE_DSP_ASTREAM_AUTO), AE_DSP_ASTREAM_AUTO));
 
     AddSpinner(groupAudioModeSel,
                 SETTING_AUDIO_MAIN_STREAMTYPE, 15021, 0,
@@ -506,7 +506,7 @@ void CGUIDialogAudioDSPSettings::InitializeSettings()
       {
         m_ModeList.push_back(make_pair(g_localizeStrings.Get(m_MasterModes[m_streamTypeUsed][i]->ModeName()), modeId));
       }
-      else if (CServiceBroker::GetADSP().GetAudioDSPAddon(m_MasterModes[m_streamTypeUsed][i]->AddonID(), addon))
+      else if (CActiveAEDSP::GetInstance().GetAudioDSPAddon(m_MasterModes[m_streamTypeUsed][i]->AddonID(), addon))
       {
         m_ModeList.push_back(make_pair(g_localizeStrings.GetAddonString(addon->ID(), m_MasterModes[m_streamTypeUsed][i]->ModeName()), modeId));
         if (!AddonMasterModeSetupPresent)
@@ -572,10 +572,10 @@ void CGUIDialogAudioDSPSettings::InitializeSettings()
       if (m_MasterModes[m_streamTypeUsed][i]->HasSettingsDialog())
       {
         AE_DSP_ADDON addon;
-        if (CServiceBroker::GetADSP().GetAudioDSPAddon(m_MasterModes[m_streamTypeUsed][i]->AddonID(), addon))
+        if (CActiveAEDSP::GetInstance().GetAudioDSPAddon(m_MasterModes[m_streamTypeUsed][i]->AddonID(), addon))
         {
           AE_DSP_MENUHOOKS hooks;
-          if (CServiceBroker::GetADSP().GetMenuHooks(m_MasterModes[m_streamTypeUsed][i]->AddonID(), AE_DSP_MENUHOOK_MASTER_PROCESS, hooks))
+          if (CActiveAEDSP::GetInstance().GetMenuHooks(m_MasterModes[m_streamTypeUsed][i]->AddonID(), AE_DSP_MENUHOOK_MASTER_PROCESS, hooks))
           {
             for (unsigned int j = 0; j < hooks.size(); j++)
             {
@@ -746,7 +746,7 @@ void CGUIDialogAudioDSPSettings::InitializeSettings()
     for (unsigned int i = 0; i < m_ActiveModes.size(); i++)
     {
       AE_DSP_ADDON addon;
-      if (CServiceBroker::GetADSP().GetAudioDSPAddon(m_ActiveModes[i]->AddonID(), addon))
+      if (CActiveAEDSP::GetInstance().GetAudioDSPAddon(m_ActiveModes[i]->AddonID(), addon))
       {
         std::string label;
         switch (m_ActiveModes[i]->ModeType())
@@ -793,7 +793,7 @@ void CGUIDialogAudioDSPSettings::InitializeSettings()
 
         AE_DSP_MENUHOOKS hooks;
         m_ActiveModesData[i].MenuListPtr = -1;
-        if (CServiceBroker::GetADSP().GetMenuHooks(m_ActiveModes[i]->AddonID(), AE_DSP_MENUHOOK_INFORMATION, hooks))
+        if (CActiveAEDSP::GetInstance().GetMenuHooks(m_ActiveModes[i]->AddonID(), AE_DSP_MENUHOOK_INFORMATION, hooks))
         {
           for (unsigned int j = 0; j < hooks.size(); j++)
           {
@@ -875,13 +875,13 @@ bool CGUIDialogAudioDSPSettings::HaveActiveMenuHooks(AE_DSP_MENUHOOK_CAT categor
 {
   /*!> Check menus are active on current stream */
   AE_DSP_ADDONMAP addonMap;
-  if (CServiceBroker::GetADSP().HaveMenuHooks(category) &&
-      CServiceBroker::GetADSP().GetEnabledAudioDSPAddons(addonMap) > 0)
+  if (CActiveAEDSP::GetInstance().HaveMenuHooks(category) &&
+      CActiveAEDSP::GetInstance().GetEnabledAudioDSPAddons(addonMap) > 0)
   {
     for (AE_DSP_ADDONMAP_ITR itr = addonMap.begin(); itr != addonMap.end(); itr++)
     {
       AE_DSP_MENUHOOKS hooks;
-      if (CServiceBroker::GetADSP().GetMenuHooks(itr->second->GetID(), category, hooks))
+      if (CActiveAEDSP::GetInstance().GetMenuHooks(itr->second->GetID(), category, hooks))
       {
         for (unsigned int i = 0; i < hooks.size(); i++)
         {
@@ -909,7 +909,7 @@ std::string CGUIDialogAudioDSPSettings::GetSettingsLabel(CSetting *pSetting)
     if (settingId.substr(0, 27) == SETTING_STREAM_INFO_MODE_CPU_USAGE)
     {
       ptr = strtol(settingId.substr(27).c_str(), NULL, 0);
-      if (ptr >= 0 && CServiceBroker::GetADSP().GetAudioDSPAddon(m_ActiveModes[ptr]->AddonID(), addon))
+      if (ptr >= 0 && CActiveAEDSP::GetInstance().GetAudioDSPAddon(m_ActiveModes[ptr]->AddonID(), addon))
         return m_ActiveModesData[ptr].MenuName;
     }
     else
@@ -919,7 +919,7 @@ std::string CGUIDialogAudioDSPSettings::GetSettingsLabel(CSetting *pSetting)
       else if (settingId.substr(0, 19) == SETTING_AUDIO_PROC_SETTINGS_MENUS)
         ptr = strtol(settingId.substr(19).c_str(), NULL, 0);
 
-      if (ptr >= 0 && CServiceBroker::GetADSP().GetAudioDSPAddon(m_Menus[ptr].addonId, addon))
+      if (ptr >= 0 && CActiveAEDSP::GetInstance().GetAudioDSPAddon(m_Menus[ptr].addonId, addon))
         return g_localizeStrings.GetAddonString(addon->ID(), m_Menus[ptr].hook.iLocalizedStringId);
     }
   }
@@ -930,12 +930,12 @@ std::string CGUIDialogAudioDSPSettings::GetSettingsLabel(CSetting *pSetting)
 void CGUIDialogAudioDSPSettings::GetAudioDSPMenus(CSettingGroup *group, AE_DSP_MENUHOOK_CAT category)
 {
   AE_DSP_ADDONMAP addonMap;
-  if (CServiceBroker::GetADSP().GetEnabledAudioDSPAddons(addonMap) > 0)
+  if (CActiveAEDSP::GetInstance().GetEnabledAudioDSPAddons(addonMap) > 0)
   {
     for (AE_DSP_ADDONMAP_ITR itr = addonMap.begin(); itr != addonMap.end(); itr++)
     {
       AE_DSP_MENUHOOKS hooks;
-      if (CServiceBroker::GetADSP().GetMenuHooks(itr->second->GetID(), category, hooks))
+      if (CActiveAEDSP::GetInstance().GetMenuHooks(itr->second->GetID(), category, hooks))
       {
         for (unsigned int i = 0; i < hooks.size(); i++)
         {
@@ -958,7 +958,7 @@ void CGUIDialogAudioDSPSettings::GetAudioDSPMenus(CSettingGroup *group, AE_DSP_M
   for (unsigned int i = 0; i < m_Menus.size(); i++)
   {
     AE_DSP_ADDON addon;
-    if (CServiceBroker::GetADSP().GetAudioDSPAddon(m_Menus[i].addonId, addon) && category == m_Menus[i].hook.category)
+    if (CActiveAEDSP::GetInstance().GetAudioDSPAddon(m_Menus[i].addonId, addon) && category == m_Menus[i].hook.category)
     {
       std::string modeName = g_localizeStrings.GetAddonString(addon->ID(), m_Menus[i].hook.iLocalizedStringId);
       if (modeName.empty())
@@ -976,7 +976,7 @@ bool CGUIDialogAudioDSPSettings::OpenAudioDSPMenu(unsigned int setupEntry)
     return false;
 
   AE_DSP_ADDON addon;
-  if (!CServiceBroker::GetADSP().GetAudioDSPAddon(m_Menus[setupEntry].addonId, addon))
+  if (!CActiveAEDSP::GetInstance().GetAudioDSPAddon(m_Menus[setupEntry].addonId, addon))
     return false;
 
   AE_DSP_MENUHOOK       hook;
diff --git a/xbmc/settings/windows/GUIWindowSettingsCategory.cpp b/xbmc/settings/windows/GUIWindowSettingsCategory.cpp
index ed45c31..c27d663 100644
--- a/xbmc/settings/windows/GUIWindowSettingsCategory.cpp
+++ b/xbmc/settings/windows/GUIWindowSettingsCategory.cpp
@@ -39,6 +39,7 @@
 #define SETTINGS_SERVICE                WINDOW_SETTINGS_SERVICE - WINDOW_SETTINGS_START
 #define SETTINGS_APPEARANCE             WINDOW_SETTINGS_APPEARANCE - WINDOW_SETTINGS_START
 #define SETTINGS_PVR                    WINDOW_SETTINGS_MYPVR - WINDOW_SETTINGS_START
+#define SETTINGS_GAMES                  WINDOW_SETTINGS_MYGAMES - WINDOW_SETTINGS_START
 
 #define CONTRL_BTN_LEVELS               20
 
@@ -55,8 +56,9 @@ static const SettingGroup s_settingGroupMap[] = { { SETTINGS_PICTURES,    "pictu
                                                   { SETTINGS_VIDEOS,      "videos" },
                                                   { SETTINGS_SERVICE,     "services" },
                                                   { SETTINGS_APPEARANCE,  "appearance" },
-                                                  { SETTINGS_PVR,         "pvr" } };
-                                                  
+                                                  { SETTINGS_PVR,         "pvr" },
+                                                  { SETTINGS_GAMES,       "games" } };
+
 #define SettingGroupSize sizeof(s_settingGroupMap) / sizeof(SettingGroup)
 
 CGUIWindowSettingsCategory::CGUIWindowSettingsCategory()
@@ -78,6 +80,7 @@ CGUIWindowSettingsCategory::CGUIWindowSettingsCategory()
   m_idRange.push_back(WINDOW_SETTINGS_SERVICE);
   m_idRange.push_back(WINDOW_SETTINGS_APPEARANCE);
   m_idRange.push_back(WINDOW_SETTINGS_MYPVR);
+  m_idRange.push_back(WINDOW_SETTINGS_MYGAMES);
 }
 
 CGUIWindowSettingsCategory::~CGUIWindowSettingsCategory()
diff --git a/xbmc/settings/windows/GUIWindowSettingsScreenCalibration.cpp b/xbmc/settings/windows/GUIWindowSettingsScreenCalibration.cpp
index e81ed87..26b7013 100644
--- a/xbmc/settings/windows/GUIWindowSettingsScreenCalibration.cpp
+++ b/xbmc/settings/windows/GUIWindowSettingsScreenCalibration.cpp
@@ -155,7 +155,10 @@ bool CGUIWindowSettingsScreenCalibration::OnMessage(CGUIMessage& message)
       if (g_application.m_pPlayer->IsPlayingVideo())
       { // don't allow resolution switching if we are playing a video
 
-        g_application.m_pPlayer->TriggerUpdateResolution();
+#ifdef HAS_VIDEO_PLAYBACK
+        RESOLUTION res = g_application.m_pPlayer->GetRenderResolution();
+        g_graphicsContext.SetVideoResolution(res);
+#endif
 
         m_iCurRes = 0;
         m_Res.push_back(g_graphicsContext.GetVideoResolution());
diff --git a/xbmc/storage/IoSupport.cpp b/xbmc/storage/IoSupport.cpp
index 8f19a6d..ca8debd 100644
--- a/xbmc/storage/IoSupport.cpp
+++ b/xbmc/storage/IoSupport.cpp
@@ -61,7 +61,6 @@
 #include "MediaManager.h"
 #ifdef TARGET_POSIX
 #include "XHandle.h"
-#include "XFileUtils.h"
 #endif
 
 #ifdef HAS_DVD_DRIVE
diff --git a/xbmc/storage/cdioSupport.cpp b/xbmc/storage/cdioSupport.cpp
index 6747a0a..d3cd6d4 100644
--- a/xbmc/storage/cdioSupport.cpp
+++ b/xbmc/storage/cdioSupport.cpp
@@ -253,14 +253,14 @@ CCdIoSupport::~CCdIoSupport()
 {
 }
 
-bool CCdIoSupport::EjectTray()
+HRESULT CCdIoSupport::EjectTray()
 {
-  return false;
+  return E_FAIL;
 }
 
-bool CCdIoSupport::CloseTray()
+HRESULT CCdIoSupport::CloseTray()
 {
-  return false;
+  return E_FAIL;
 }
 
 HANDLE CCdIoSupport::OpenCDROM()
diff --git a/xbmc/storage/cdioSupport.h b/xbmc/storage/cdioSupport.h
index d2f831a..6c2cd91 100644
--- a/xbmc/storage/cdioSupport.h
+++ b/xbmc/storage/cdioSupport.h
@@ -279,8 +279,8 @@ public:
   CCdIoSupport();
   virtual ~CCdIoSupport();
 
-  bool EjectTray();
-  bool CloseTray();
+  HRESULT EjectTray();
+  HRESULT CloseTray();
 
   HANDLE OpenCDROM();
   HANDLE OpenIMAGE( std::string& strFilename );
diff --git a/xbmc/test/TestBasicEnvironment.cpp b/xbmc/test/TestBasicEnvironment.cpp
index d2b3f12..44e1516 100644
--- a/xbmc/test/TestBasicEnvironment.cpp
+++ b/xbmc/test/TestBasicEnvironment.cpp
@@ -20,7 +20,6 @@
 
 #include "TestBasicEnvironment.h"
 #include "TestUtils.h"
-#include "cores/AudioEngine/DSPAddons/ActiveAEDSP.h"
 #include "filesystem/Directory.h"
 #include "filesystem/File.h"
 #include "filesystem/SpecialProtocol.h"
diff --git a/xbmc/utils/JobManager.cpp b/xbmc/utils/JobManager.cpp
index 0c0437a..e1d94d9 100644
--- a/xbmc/utils/JobManager.cpp
+++ b/xbmc/utils/JobManager.cpp
@@ -24,9 +24,6 @@
 #include <stdexcept>
 #include "threads/SingleLock.h"
 #include "utils/log.h"
-#ifdef TARGET_POSIX
-#include "linux/XTimeUtils.h"
-#endif
 
 #include "system.h"
 
diff --git a/xbmc/utils/Observer.h b/xbmc/utils/Observer.h
index 3ac032a..d3bfd9b 100644
--- a/xbmc/utils/Observer.h
+++ b/xbmc/utils/Observer.h
@@ -40,7 +40,9 @@ typedef enum
   ObservableMessageTimersReset,
   ObservableMessageRecordings,
   ObservableMessagePeripheralsChanged,
-  ObservableMessageManagerStateChanged
+  ObservableMessageManagerStateChanged,
+  ObservableMessageRemoteAddons,
+  ObservableMessagePortsChanged,
 } ObservableMessage;
 
 class Observer
diff --git a/xbmc/utils/RegExp.h b/xbmc/utils/RegExp.h
index e4071e4..abe9610 100644
--- a/xbmc/utils/RegExp.h
+++ b/xbmc/utils/RegExp.h
@@ -25,11 +25,6 @@
 #include <string>
 #include <vector>
 
-/* make sure stdlib.h is included before including pcre.h inside the
-   namespace; this works around stdlib.h definitions also living in
-   the PCRE namespace */
-#include <stdlib.h>
-
 namespace PCRE {
 struct real_pcre_jit_stack; // forward declaration for PCRE without JIT
 typedef struct real_pcre_jit_stack pcre_jit_stack;
diff --git a/xbmc/utils/RssReader.cpp b/xbmc/utils/RssReader.cpp
index 9186f56..52d7735 100644
--- a/xbmc/utils/RssReader.cpp
+++ b/xbmc/utils/RssReader.cpp
@@ -35,9 +35,6 @@
 #include "guilib/GUIRSSControl.h"
 #include "threads/SingleLock.h"
 #include "log.h"
-#ifdef TARGET_POSIX
-#include "linux/XTimeUtils.h"
-#endif
 
 #define RSS_COLOR_BODY      0
 #define RSS_COLOR_HEADLINE  1
diff --git a/xbmc/utils/SaveFileStateJob.cpp b/xbmc/utils/SaveFileStateJob.cpp
index 8363a67..de86d43 100644
--- a/xbmc/utils/SaveFileStateJob.cpp
+++ b/xbmc/utils/SaveFileStateJob.cpp
@@ -203,7 +203,7 @@ bool CSaveFileStateJob::DoWork()
       }
     }
 
-    if (CServiceBroker::GetADSP().IsProcessing())
+    if (ActiveAE::CActiveAEDSP::GetInstance().IsProcessing())
     {
       std::string redactPath = CURL::GetRedacted(progressTrackingFile);
       CLog::Log(LOGDEBUG, "%s - Saving file state for dsp audio item %s", __FUNCTION__, redactPath.c_str());
diff --git a/xbmc/utils/SystemInfo.cpp b/xbmc/utils/SystemInfo.cpp
index 03b9f65..eb85abb 100644
--- a/xbmc/utils/SystemInfo.cpp
+++ b/xbmc/utils/SystemInfo.cpp
@@ -27,7 +27,6 @@
 #include <conio.h>
 #else
 #include <sys/utsname.h>
-#include "linux/XFileUtils.h"
 #endif
 #include "guiinfo/GUIInfoLabels.h"
 #include "filesystem/CurlFile.h"
diff --git a/xbmc/utils/Weather.cpp b/xbmc/utils/Weather.cpp
index b3ecae4..4378c37 100644
--- a/xbmc/utils/Weather.cpp
+++ b/xbmc/utils/Weather.cpp
@@ -47,9 +47,6 @@
 #include "utils/Temperature.h"
 #include "XBDateTime.h"
 #include "XMLUtils.h"
-#ifdef TARGET_POSIX
-#include "linux/XTimeUtils.h"
-#endif
 
 using namespace ADDON;
 using namespace XFILE;
diff --git a/xbmc/video/CMakeLists.txt b/xbmc/video/CMakeLists.txt
index 11f4046..1fe1c81 100644
--- a/xbmc/video/CMakeLists.txt
+++ b/xbmc/video/CMakeLists.txt
@@ -1,5 +1,6 @@
 set(SOURCES Bookmark.cpp
             ContextMenus.cpp
+            FFmpegVideoDecoder.cpp
             GUIViewStateVideo.cpp
             PlayerController.cpp
             Teletext.cpp
@@ -15,6 +16,7 @@ set(SOURCES Bookmark.cpp
 set(HEADERS Bookmark.h
             ContextMenus.h
             Episode.h
+            FFmpegVideoDecoder.h
             GUIViewStateVideo.h
             PlayerController.h
             Teletext.h
@@ -34,7 +36,3 @@ add_dependencies(video libcpluff)
 if(ENABLE_INTERNAL_FFMPEG)
   add_dependencies(video ffmpeg)
 endif()
-
-if(CORE_SYSTEM_NAME STREQUAL windows)
-  add_dependencies(video d3dx11effects)
-endif()
diff --git a/xbmc/video/ContextMenus.cpp b/xbmc/video/ContextMenus.cpp
index de20bd4..16586a3 100644
--- a/xbmc/video/ContextMenus.cpp
+++ b/xbmc/video/ContextMenus.cpp
@@ -21,7 +21,6 @@
 #include "ContextMenus.h"
 #include "Application.h"
 #include "Autorun.h"
-#include "video/dialogs/GUIDialogVideoInfo.h"
 
 
 namespace CONTEXTMENU
@@ -37,8 +36,14 @@ bool CVideoInfo::IsVisible(const CFileItem& item) const
 
 bool CVideoInfo::Execute(const CFileItemPtr& item) const
 {
-  CGUIDialogVideoInfo::ShowFor(*item);
-  return true;
+  auto window = static_cast<CGUIWindowVideoNav*>(g_windowManager.GetWindow(WINDOW_VIDEO_NAV));
+  if (window)
+  {
+    ADDON::ScraperPtr info;
+    window->OnItemInfo(item.get(), info);
+    return true;
+  }
+  return false;
 }
 
 bool CMarkWatched::IsVisible(const CFileItem& item) const
diff --git a/xbmc/video/FFmpegVideoDecoder.cpp b/xbmc/video/FFmpegVideoDecoder.cpp
new file mode 100644
index 0000000..3fd8b47
--- /dev/null
+++ b/xbmc/video/FFmpegVideoDecoder.cpp
@@ -0,0 +1,302 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "system.h"
+#include "guilib/Texture.h"
+
+#include "FFmpegVideoDecoder.h"
+
+extern "C" {
+#include "libavformat/avformat.h"
+#include "libavcodec/avcodec.h"
+#include "libavutil/avutil.h"
+#include "libswscale/swscale.h"
+}
+
+FFmpegVideoDecoder::FFmpegVideoDecoder()
+{
+  m_pFormatCtx = 0;
+  m_pCodecCtx = 0;
+  m_pCodec = 0;
+  m_pFrame = 0;
+  m_pFrameRGB = 0;
+}
+
+FFmpegVideoDecoder::~FFmpegVideoDecoder()
+{
+  close();
+}
+
+void FFmpegVideoDecoder::close()
+{
+  // Free the YUV frame
+  if ( m_pFrame )
+	av_free( m_pFrame );
+
+  // Free the RGB frame
+  if ( m_pFrameRGB )
+  {
+	avpicture_free( m_pFrameRGB );
+	av_free( m_pFrameRGB );
+  }
+
+  // Close the codec
+  if ( m_pCodecCtx )
+	avcodec_close( m_pCodecCtx );
+
+  // Close the video file
+  if ( m_pFormatCtx )
+	avformat_close_input( &m_pFormatCtx );
+
+  m_pFormatCtx = 0;
+  m_pCodecCtx = 0;
+  m_pCodec = 0;
+  m_pFrame = 0;
+  m_pFrameRGB = 0;
+}
+
+bool FFmpegVideoDecoder::isOpened() const
+{
+  return m_pFrame ? true : false;
+}
+
+double FFmpegVideoDecoder::getDuration() const
+{
+  if (m_pFormatCtx)
+  {
+    double duration = static_cast<double>(m_pFormatCtx->duration) / AV_TIME_BASE;
+    if (duration > 0.0)
+      return duration;
+  }
+
+  return 0.0;
+}
+  
+double FFmpegVideoDecoder::getFramesPerSecond() const
+{
+#if defined(AVFORMAT_HAS_STREAM_GET_R_FRAME_RATE)
+  return m_pFormatCtx ? av_q2d( av_stream_get_r_frame_rate( m_pFormatCtx->streams[ m_videoStream ] ) ) : 0.0;
+#else
+  return m_pFormatCtx ? av_q2d( m_pFormatCtx->streams[ m_videoStream ]->r_frame_rate ) : 0.0;
+#endif
+}
+  
+unsigned int FFmpegVideoDecoder::getWidth() const
+{
+  if ( !m_pCodecCtx )
+    return 0;
+
+  return m_pCodecCtx->width;
+}
+
+unsigned int FFmpegVideoDecoder::getHeight() const
+{
+  if ( !m_pCodecCtx )
+    return 0;
+
+  return m_pCodecCtx->height;
+}
+
+const AVFormatContext * FFmpegVideoDecoder::getAVFormatContext() const
+{
+  return m_pFormatCtx;
+}
+
+const AVCodecContext * FFmpegVideoDecoder::getAVCodecContext() const
+{
+  return m_pCodecCtx;
+}
+
+const AVCodec * FFmpegVideoDecoder::getAVCodec() const
+{
+  return m_pCodec;
+}
+
+std::string FFmpegVideoDecoder::getErrorMsg() const
+{
+  return m_errorMsg;
+}
+
+double FFmpegVideoDecoder::getLastFrameTime() const
+{
+  return m_lastFrameTime;
+}
+
+
+bool FFmpegVideoDecoder::open( const std::string& filename )
+{
+  // See http://dranger.com/ffmpeg/tutorial01.html
+  close();
+  
+  // Open the video file
+  if ( avformat_open_input( &m_pFormatCtx, filename.c_str(), NULL, NULL ) < 0 )
+  {
+    m_errorMsg = "Could not open the video file";
+   close();
+    return false;
+  }
+
+  // Retrieve the stream information
+  if ( avformat_find_stream_info( m_pFormatCtx, 0 ) < 0 )
+  {
+    m_errorMsg = "Could not find the stream information";
+    close();
+    return false;
+  }
+
+  // Find the first video stream
+  m_videoStream = -1;
+
+  for ( unsigned i = 0; i < m_pFormatCtx->nb_streams; i++ )
+  {
+    if ( m_pFormatCtx->streams[i]->codec->codec_type == AVMEDIA_TYPE_VIDEO )
+    {
+      m_videoStream = i;
+      break;
+    }
+  }
+
+  if ( m_videoStream == -1 )
+  {
+    m_errorMsg = "Could not find a playable video stream";
+    close();
+    return false;
+  }
+
+  // Get a pointer to the codec context for the video stream
+  m_pCodecCtx = m_pFormatCtx->streams[ m_videoStream ]->codec;
+
+  // Find the decoder for the video stream
+  m_pCodec = avcodec_find_decoder( m_pCodecCtx->codec_id );
+
+  if ( m_pCodec == NULL )
+  {
+    m_errorMsg = "Could not find a video decoder";
+    close();
+    return false;
+  }
+    
+  // Open the codec
+  if ( avcodec_open2( m_pCodecCtx, m_pCodec, 0 ) < 0 )
+  {
+    m_errorMsg = "Could not open the video decoder";
+    close();
+    return false;
+  }
+  
+  // Allocate video frames
+  m_pFrame = av_frame_alloc();
+
+  if ( !m_pFrame )
+  {
+    m_errorMsg = "Could not allocate memory for a frame";
+    close();
+    return false;
+  }
+  
+  return true;
+}
+
+
+bool FFmpegVideoDecoder::seek( double time )
+{
+  // Convert the frame number into time stamp
+  int64_t timestamp = (int64_t) (time * AV_TIME_BASE * av_q2d( m_pFormatCtx->streams[ m_videoStream ]->time_base ));
+
+  if ( av_seek_frame( m_pFormatCtx, m_videoStream, timestamp, AVSEEK_FLAG_ANY ) < 0 )
+	return false;
+
+  avcodec_flush_buffers( m_pCodecCtx );
+  return true;
+}
+
+bool FFmpegVideoDecoder::nextFrame( CBaseTexture * texture )
+{
+  // Just in case
+  if ( !m_pCodecCtx )
+	return false;
+
+  // If we did not preallocate the picture or the texture size changed, (re)allocate it
+  if ( !m_pFrameRGB || texture->GetWidth() != m_frameRGBwidth || texture->GetHeight() != m_frameRGBheight )
+  {
+    if ( m_pFrameRGB )
+    {
+      avpicture_free( m_pFrameRGB );
+      av_free( m_pFrameRGB );
+    }
+
+    m_frameRGBwidth = texture->GetWidth();
+    m_frameRGBheight = texture->GetHeight();
+
+    // Allocate the conversion frame and relevant picture
+    m_pFrameRGB = (AVPicture*)av_mallocz(sizeof(AVPicture));
+
+    if ( !m_pFrameRGB )
+      return false;
+
+    // Due to a bug in swsscale we need to allocate one extra line of data
+    if ( avpicture_alloc( m_pFrameRGB, AV_PIX_FMT_RGB32, m_frameRGBwidth, m_frameRGBheight + 1 ) < 0 )
+      return false;
+  }
+
+  AVPacket packet;
+  int frameFinished;
+
+  while ( true )
+  {
+    // Read a frame
+    if ( av_read_frame( m_pFormatCtx, &packet ) < 0 )
+      return false;  // Frame read failed (e.g. end of stream)
+
+    if ( packet.stream_index == m_videoStream )
+    {
+      // Is this a packet from the video stream -> decode video frame
+      avcodec_decode_video2( m_pCodecCtx, m_pFrame, &frameFinished, &packet );
+
+      // Did we get a video frame?
+      if ( frameFinished )
+      {
+        if ( packet.dts != (int64_t)AV_NOPTS_VALUE )
+	  m_lastFrameTime = packet.dts * av_q2d( m_pFormatCtx->streams[ m_videoStream ]->time_base );
+        else
+	   m_lastFrameTime = 0.0;
+
+	break;
+      }
+    }
+
+    av_free_packet( &packet );
+  }
+
+  // We got the video frame, render it into the picture buffer
+  struct SwsContext * context = sws_getContext( m_pCodecCtx->width, m_pCodecCtx->height, m_pCodecCtx->pix_fmt,
+                           m_frameRGBwidth, m_frameRGBheight, AV_PIX_FMT_RGB32, SWS_FAST_BILINEAR, NULL, NULL, NULL );
+
+  sws_scale( context, m_pFrame->data, m_pFrame->linesize, 0, m_pCodecCtx->height,
+                                                                     m_pFrameRGB->data, m_pFrameRGB->linesize );
+  sws_freeContext( context );
+  av_free_packet( &packet );
+
+  // And into the texture
+  texture->Update( m_frameRGBwidth, m_frameRGBheight, m_frameRGBwidth * 4, XB_FMT_A8R8G8B8, m_pFrameRGB->data[0], false );
+
+  return true;
+}
+
diff --git a/xbmc/video/FFmpegVideoDecoder.h b/xbmc/video/FFmpegVideoDecoder.h
new file mode 100644
index 0000000..510b9e1
--- /dev/null
+++ b/xbmc/video/FFmpegVideoDecoder.h
@@ -0,0 +1,158 @@
+#ifndef FFMPEGVIDEODECODER_H
+#define FFMPEGVIDEODECODER_H
+
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <string>
+
+class CBaseTexture;
+
+extern "C" {
+struct AVFormatContext;
+struct AVCodecContext;
+struct AVCodec;
+struct AVFrame;
+struct AVPicture;
+}
+
+/**
+ * A simple FFMpeg-based background video decoder.
+ * 
+ * This class only decodes the video using the standard FFmpeg calls, so likely no hardware acceleration.
+ * No audio decoding, and no rendering.
+ * 
+ */
+class FFmpegVideoDecoder
+{
+public:
+  FFmpegVideoDecoder();
+  ~FFmpegVideoDecoder();
+
+  /**
+   * Opens the video file for decoding. Supports all the formats supported by the used FFmpeg.
+   * The file must have at least one video track. If it has more than one, the first video track
+   * would be decoded.
+   * 
+   * If an existing stream was opened, it is automatically closed and the new stream is opened.
+   * 
+   * Returns true if the file was opened successfully, and false otherwise, in which case
+   * the getErrorMsg() function could be used to retrieve the reason.
+   * 
+   * @param filename The video file name, which must be translated through CSpecialProtocol::TranslatePath()
+   */
+  bool open( const std::string& filename );
+
+  /**
+   * Returns true if the decoder has the video file opened.
+   */
+  bool isOpened() const;
+
+  /**
+   * Returns the movie duration in seconds or 0.0 if the duration is not available. For some formats
+   * is calculated through the heuristics, and the video might not really be that long (for example if it is incomplete).
+   * The total number of frames is calculated by multiplying the duration by getFramesPerSecond()
+   */
+  double getDuration() const;
+  
+  /**
+   * Returns the frames per second for this video
+   */
+  double getFramesPerSecond() const;
+  
+  /**
+   * Returns the original video width or 0 if the video wasn't opened.
+   */  
+  unsigned int getWidth() const;
+
+  /**
+   * Returns the original video height or 0 if the video wasn't opened.
+   */  
+  unsigned int getHeight() const;
+
+  /**
+   * Returns the last rendered frame number.
+   */
+  double getLastFrameTime() const;
+
+  /**
+   * Returns the AVFormatContext structure associated with this video format
+   */  
+  const AVFormatContext * getAVFormatContext() const;
+
+  /**
+   * Returns the AVCodecContext structure associated with this video codec
+   */  
+  const AVCodecContext * getAVCodecContext() const;
+  
+  /**
+   * Returns the AVCodec structure associated with this video codec
+   */  
+  const AVCodec * getAVCodec() const;
+
+  /**
+   * Returns the error message text if opening the video failed
+   */  
+  std::string getErrorMsg() const;
+
+  /**
+   * Decodes and renders the next video frame into the provided texture which
+   * must be in a XB_FMT_A8R8G8B8 format.
+   * The frame will be rescaled to fit the whole texture (i.e. texture width/height)
+   * so make sure the texture aspect ratio is the same as in the original movie.
+   * 
+   * @param texture The texture to render the frame into. Must be preallocated, 
+   * have the appropriate width/height and in XB_FMT_A8R8G8B8 format.
+   * 
+   * @return true if the frame rendered, false if there are no more frames
+   */  
+  bool nextFrame( CBaseTexture * texture );
+
+  /**
+	* Seeks to a specific time position in the video file. Note that the seek is limited to the keyframes only.
+	* @param time The time to seek to, in seconds
+	* @return true if the seek succeed, false if failed
+	*/
+  bool seek( double time );
+
+  /**
+   * Closes the video stream.
+   */  
+  void close();
+
+private:
+  bool readFrame( int frame );
+  
+  AVFormatContext *m_pFormatCtx;
+  AVCodecContext  *m_pCodecCtx;
+  AVCodec         *m_pCodec;
+  AVFrame         *m_pFrame;
+  AVPicture       *m_pFrameRGB;
+  int              m_videoStream;
+  double           m_lastFrameTime;
+  
+  // The dimensions of the allocated pFrameRGB
+  unsigned int     m_frameRGBwidth;
+  unsigned int     m_frameRGBheight;
+  
+  std::string       m_errorMsg;
+};
+
+#endif
diff --git a/xbmc/video/Makefile b/xbmc/video/Makefile
index be03ee1..e35f39b 100644
--- a/xbmc/video/Makefile
+++ b/xbmc/video/Makefile
@@ -1,5 +1,6 @@
 SRCS=Bookmark.cpp \
      ContextMenus.cpp \
+     FFmpegVideoDecoder.cpp \
      GUIViewStateVideo.cpp \
      PlayerController.cpp \
      Teletext.cpp \
diff --git a/xbmc/video/VideoReferenceClock.cpp b/xbmc/video/VideoReferenceClock.cpp
index b6eaa9e..d78caa5 100644
--- a/xbmc/video/VideoReferenceClock.cpp
+++ b/xbmc/video/VideoReferenceClock.cpp
@@ -17,6 +17,8 @@
  *  <http://www.gnu.org/licenses/>.
  *
  */
+#include "system.h"
+#include <list>
 #include "VideoReferenceClock.h"
 #include "utils/MathUtils.h"
 #include "utils/log.h"
@@ -46,13 +48,6 @@
 #if defined(TARGET_DARWIN_IOS)
 #include "video/videosync/VideoSyncIos.h"
 #endif
-#if defined(TARGET_ANDROID)
-#include "video/videosync/VideoSyncAndroid.h"
-#endif
-
-#ifdef TARGET_POSIX
-#include "linux/XTimeUtils.h"
-#endif
 
 CVideoReferenceClock::CVideoReferenceClock() : CThread("RefClock")
 {
@@ -70,7 +65,7 @@ CVideoReferenceClock::CVideoReferenceClock() : CThread("RefClock")
   m_MissedVblanks = 0;
   m_VblankTime = 0;
 
-  m_pVideoSync = nullptr;
+  m_pVideoSync = NULL;
 }
 
 CVideoReferenceClock::~CVideoReferenceClock()
@@ -129,8 +124,6 @@ void CVideoReferenceClock::Process()
     m_pVideoSync = new CVideoSyncPi();
 #elif defined(HAS_IMXVPU)
     m_pVideoSync = new CVideoSyncIMX();
-#elif defined(TARGET_ANDROID)
-    m_pVideoSync = new CVideoSyncAndroid();
 #endif
 
     if (m_pVideoSync)
@@ -175,7 +168,7 @@ void CVideoReferenceClock::Process()
     {
       m_pVideoSync->Cleanup();
       delete m_pVideoSync;
-      m_pVideoSync = nullptr;
+      m_pVideoSync = NULL;
     }
 
     if (!SetupSuccess)
@@ -199,26 +192,26 @@ void CVideoReferenceClock::UpdateClock(int NrVBlanks, bool CheckMissed)
   {
     m_MissedVblanks += NrVBlanks;      //tell the vblank clock how many vblanks it missed
     m_TotalMissedVblanks += NrVBlanks; //for the codec information screen
-    m_VblankTime += m_SystemFrequency * static_cast<int64_t>(NrVBlanks) / MathUtils::round_int(m_RefreshRate); //set the vblank time forward
+    m_VblankTime += m_SystemFrequency * (int64_t)NrVBlanks / MathUtils::round_int(m_RefreshRate); //set the vblank time forward
   }
 
   if (NrVBlanks > 0) //update the clock with the adjusted frequency if we have any vblanks
   {
     double increment = UpdateInterval() * NrVBlanks;
     double integer   = floor(increment);
-    m_CurrTime      += static_cast<int64_t>(integer + 0.5); //make sure it gets correctly converted to int
+    m_CurrTime      += (int64_t)(integer + 0.5); //make sure it gets correctly converted to int
 
     //accumulate what we lost due to rounding in m_CurrTimeFract, then add the integer part of that to m_CurrTime
     m_CurrTimeFract += increment - integer;
     integer          = floor(m_CurrTimeFract);
-    m_CurrTime      += static_cast<int64_t>(integer + 0.5);
+    m_CurrTime      += (int64_t)(integer + 0.5);
     m_CurrTimeFract -= integer;
   }
 }
 
-double CVideoReferenceClock::UpdateInterval() const
+double CVideoReferenceClock::UpdateInterval()
 {
-  return m_ClockSpeed * m_fineadjust / m_RefreshRate * static_cast<double>(m_SystemFrequency);
+  return m_ClockSpeed * m_fineadjust / m_RefreshRate * (double)m_SystemFrequency;
 }
 
 //called from dvdclock to get the time
@@ -244,12 +237,12 @@ int64_t CVideoReferenceClock::GetTime(bool interpolated /* = true*/)
     if (interpolated)
     {
       //interpolate from the last time the clock was updated
-      double elapsed = static_cast<double>(Now - m_VblankTime) * m_ClockSpeed * m_fineadjust;
+      double elapsed = (double)(Now - m_VblankTime) * m_ClockSpeed * m_fineadjust;
       //don't interpolate more than 2 vblank periods
       elapsed = std::min(elapsed, UpdateInterval() * 2.0);
 
       //make sure the clock doesn't go backwards
-      int64_t intTime = m_CurrTime + static_cast<int64_t>(elapsed);
+      int64_t intTime = m_CurrTime + (int64_t)elapsed;
       if (intTime > m_LastIntTime)
         m_LastIntTime = intTime;
 
@@ -267,7 +260,7 @@ int64_t CVideoReferenceClock::GetTime(bool interpolated /* = true*/)
 }
 
 //called from dvdclock to get the clock frequency
-int64_t CVideoReferenceClock::GetFrequency() const
+int64_t CVideoReferenceClock::GetFrequency()
 {
   return m_SystemFrequency;
 }
@@ -339,7 +332,7 @@ int64_t CVideoReferenceClock::Wait(int64_t Target)
       //calculate how long to sleep before we should have gotten a signal that a vblank happened
       Now = CurrentHostCounter();
       int64_t NextVblank = TimeOfNextVblank();
-      SleepTime = static_cast<int>((NextVblank - Now) * 1000 / m_SystemFrequency);
+      SleepTime = (int)((NextVblank - Now) * 1000 / m_SystemFrequency);
 
       int64_t CurrTime = m_CurrTime; //save current value of the clock
 
@@ -370,7 +363,7 @@ int64_t CVideoReferenceClock::Wait(int64_t Target)
     SingleLock.Leave();
     Now = CurrentHostCounter();
     //sleep until the timestamp has passed
-    SleepTime = static_cast<int>((Target - (Now + ClockOffset)) * 1000 / m_SystemFrequency);
+    SleepTime = (int)((Target - (Now + ClockOffset)) * 1000 / m_SystemFrequency);
     if (SleepTime > 0)
       Sleep(SleepTime);
 
@@ -389,13 +382,13 @@ void CVideoReferenceClock::SendVblankSignal()
 //guess when the next vblank should happen,
 //based on the refreshrate and when the previous one happened
 //increase that by 30% to allow for errors
-int64_t CVideoReferenceClock::TimeOfNextVblank() const
+int64_t CVideoReferenceClock::TimeOfNextVblank()
 {
   return m_VblankTime + (m_SystemFrequency / MathUtils::round_int(m_RefreshRate) * MAXVBLANKDELAY / 10LL);
 }
 
 //for the codec information screen
-bool CVideoReferenceClock::GetClockInfo(int& MissedVblanks, double& ClockSpeed, double& RefreshRate) const
+bool CVideoReferenceClock::GetClockInfo(int& MissedVblanks, double& ClockSpeed, double& RefreshRate)
 {
   if (m_UseVblank)
   {
diff --git a/xbmc/video/VideoReferenceClock.h b/xbmc/video/VideoReferenceClock.h
index b459e87..4681373 100644
--- a/xbmc/video/VideoReferenceClock.h
+++ b/xbmc/video/VideoReferenceClock.h
@@ -31,24 +31,24 @@ class CVideoReferenceClock : public CThread
     virtual ~CVideoReferenceClock();
 
     int64_t GetTime(bool interpolated = true);
-    int64_t GetFrequency() const;
+    int64_t GetFrequency();
     void    SetSpeed(double Speed);
     double  GetSpeed();
-    double  GetRefreshRate(double* interval = nullptr);
+    double  GetRefreshRate(double* interval = NULL);
     int64_t Wait(int64_t Target);
-    bool    GetClockInfo(int& MissedVblanks, double& ClockSpeed, double& RefreshRate) const;
+    bool    GetClockInfo(int& MissedVblanks, double& ClockSpeed, double& RefreshRate);
     void    SetFineAdjust(double fineadjust);
     void    RefreshChanged();
     void    Start();
     void    Stop();
 
   private:
-    void    Process() override;
+    void    Process();
     void    UpdateRefreshrate();
     void    SendVblankSignal();
     void    UpdateClock(int NrVBlanks, bool CheckMissed);
-    double  UpdateInterval() const;
-    int64_t TimeOfNextVblank() const;
+    double  UpdateInterval();
+    int64_t TimeOfNextVblank();
     static void CBUpdateClock(int NrVBlanks, uint64_t time);
 
     int64_t m_CurrTime;          //the current time of the clock when using vblank as clock source
diff --git a/xbmc/video/VideoThumbLoader.cpp b/xbmc/video/VideoThumbLoader.cpp
index d538598..ef50de8 100644
--- a/xbmc/video/VideoThumbLoader.cpp
+++ b/xbmc/video/VideoThumbLoader.cpp
@@ -131,9 +131,7 @@ bool CThumbExtractor::DoWork()
       }
     }
   }
-  else if (!m_item.IsPlugin() &&
-           (!m_item.HasVideoInfoTag() ||
-           !m_item.GetVideoInfoTag()->HasStreamDetails()))
+  else if (!m_item.HasVideoInfoTag() || !m_item.GetVideoInfoTag()->HasStreamDetails())
   {
     // No tag or no details set, so extract them
     CLog::Log(LOGDEBUG,"%s - trying to extract filestream details from video file %s", __FUNCTION__, CURL::GetRedacted(m_item.GetPath()).c_str());
diff --git a/xbmc/video/dialogs/GUIDialogVideoInfo.cpp b/xbmc/video/dialogs/GUIDialogVideoInfo.cpp
index b3280a1..827bd91 100644
--- a/xbmc/video/dialogs/GUIDialogVideoInfo.cpp
+++ b/xbmc/video/dialogs/GUIDialogVideoInfo.cpp
@@ -2032,13 +2032,3 @@ bool CGUIDialogVideoInfo::OnGetFanart(const CFileItemPtr &videoItem)
 
   return true;
 }
-
-void CGUIDialogVideoInfo::ShowFor(const CFileItem& item)
-{
-  auto window = static_cast<CGUIWindowVideoNav*>(g_windowManager.GetWindow(WINDOW_VIDEO_NAV));
-  if (window)
-  {
-    ADDON::ScraperPtr info;
-    window->OnItemInfo(item, info);
-  }
-}
\ No newline at end of file
diff --git a/xbmc/video/dialogs/GUIDialogVideoInfo.h b/xbmc/video/dialogs/GUIDialogVideoInfo.h
index facd55a..dc7d3b9 100644
--- a/xbmc/video/dialogs/GUIDialogVideoInfo.h
+++ b/xbmc/video/dialogs/GUIDialogVideoInfo.h
@@ -65,9 +65,6 @@ public:
   static bool ManageVideoItemArtwork(const CFileItemPtr &item, const MediaType &type);
 
   static std::string GetLocalizedVideoType(const std::string &strType);
-
-  static void ShowFor(const CFileItem& item);
-
 protected:
   virtual void OnInitWindow();
   void Update();
diff --git a/xbmc/video/videosync/CMakeLists.txt b/xbmc/video/videosync/CMakeLists.txt
index 147373a..8c718c6 100644
--- a/xbmc/video/videosync/CMakeLists.txt
+++ b/xbmc/video/videosync/CMakeLists.txt
@@ -1,5 +1,10 @@
 set(HEADERS VideoSync.h)
 
+if(CORE_SYSTEM_NAME STREQUAL "rbpi")
+  list(APPEND SOURCES VideoSyncPi.cpp)
+  list(APPEND HEADERS VideoSyncPi.h)
+endif()
+
 if(OPENGL_FOUND)
   list(APPEND SOURCES VideoSyncGLX.cpp)
   list(APPEND HEADERS VideoSyncGLX.h)
@@ -10,34 +15,21 @@ if(X_FOUND)
   list(APPEND HEADERS VideoSyncDRM.h)
 endif()
 
-if(CORE_SYSTEM_NAME STREQUAL windows)
+if(CORE_SYSTEM_NAME STREQUAL "windows")
   list(APPEND SOURCES VideoSyncD3D.cpp)
   list(APPEND HEADERS VideoSyncD3D.h)
 endif()
 
-if(CORE_SYSTEM_NAME STREQUAL rbpi)
-  list(APPEND SOURCES VideoSyncPi.cpp)
-  list(APPEND HEADERS VideoSyncPi.h)
-endif()
-
-if(CORE_SYSTEM_NAME STREQUAL darwin)
+if(CORE_SYSTEM_NAME STREQUAL "darwin")
   list(APPEND SOURCES VideoSyncOsx.cpp)
   list(APPEND HEADERS VideoSyncOsx.h)
 endif()
 
-if(CORE_SYSTEM_NAME STREQUAL ios)
+if(CORE_SYSTEM_NAME STREQUAL "ios")
   list(APPEND SOURCES VideoSyncIos.cpp)
   list(APPEND HEADERS VideoSyncIos.h)
 endif()
 
-if(CORE_SYSTEM_NAME STREQUAL android)
-  list(APPEND SOURCES VideoSyncAndroid.cpp)
-  list(APPEND HEADERS VideoSyncAndroid.h)
-endif()
-
 if(SOURCES AND HEADERS)
   core_add_library(video_sync)
-  if(CORE_SYSTEM_NAME STREQUAL windows)
-    add_dependencies(video_sync d3dx11effects)
-  endif()
 endif()
diff --git a/xbmc/video/videosync/Makefile b/xbmc/video/videosync/Makefile
index fda1c06..a4fb395 100644
--- a/xbmc/video/videosync/Makefile
+++ b/xbmc/video/videosync/Makefile
@@ -4,7 +4,6 @@ SRCS=VideoSyncGLX.cpp \
      VideoSyncDRM.cpp \
      VideoSyncPi.cpp \
      VideoSyncIMX.cpp \
-     VideoSyncAndroid.cpp \
 
 LIB=videosync.a
 
diff --git a/xbmc/video/videosync/VideoSyncAndroid.cpp b/xbmc/video/videosync/VideoSyncAndroid.cpp
deleted file mode 100644
index a248fcf..0000000
--- a/xbmc/video/videosync/VideoSyncAndroid.cpp
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- *      Copyright (C) 2015 Team Kodi
- *      http://kodi.tv
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#include "system.h"
-
-#if defined(TARGET_ANDROID)
-#include "utils/log.h"
-#include "VideoSyncAndroid.h"
-#include "video/VideoReferenceClock.h"
-#include "utils/TimeUtils.h"
-#include "platform/android/activity/XBMCApp.h"
-#include "windowing/WindowingFactory.h"
-#include "guilib/GraphicContext.h"
-#include "utils/MathUtils.h"
-#include "linux/XTimeUtils.h"
-
-
-bool CVideoSyncAndroid::Setup(PUPDATECLOCK func)
-{
-  CLog::Log(LOGDEBUG, "CVideoSyncAndroid::%s setting up", __FUNCTION__);
-  
-  //init the vblank timestamp
-  m_LastVBlankTime = CurrentHostCounter();
-  UpdateClock = func;
-  m_abort = false;
-  
-  CXBMCApp::InitFrameCallback(this);
-  g_Windowing.Register(this);
-
-  return true;
-}
-
-void CVideoSyncAndroid::Run(volatile bool& stop)
-{
-  while(!stop && !m_abort)
-  {
-    Sleep(100);
-  }
-}
-
-void CVideoSyncAndroid::Cleanup()
-{
-  CLog::Log(LOGDEBUG, "CVideoSyncAndroid::%s cleaning up", __FUNCTION__);
-  CXBMCApp::DeinitFrameCallback();
-  g_Windowing.Unregister(this);
-}
-
-float CVideoSyncAndroid::GetFps()
-{
-  m_fps = g_graphicsContext.GetFPS();
-  CLog::Log(LOGDEBUG, "CVideoSyncAndroid::%s Detected refreshrate: %f hertz", __FUNCTION__, m_fps);
-  return m_fps;
-}
-
-void CVideoSyncAndroid::OnResetDevice()
-{
-  m_abort = true;
-}
-
-void CVideoSyncAndroid::FrameCallback(int64_t frameTimeNanos)
-{
-  int           NrVBlanks;
-  double        VBlankTime;
-  int64_t       nowtime = CurrentHostCounter();
-  
-  //calculate how many vblanks happened
-  VBlankTime = (double)(nowtime - m_LastVBlankTime) / (double)g_VideoReferenceClock.GetFrequency();
-  NrVBlanks = MathUtils::round_int(VBlankTime * m_fps);
-
-  //save the timestamp of this vblank so we can calculate how many happened next time
-  m_LastVBlankTime = nowtime;
-  
-  //update the vblank timestamp, update the clock and send a signal that we got a vblank
-  UpdateClock(NrVBlanks, nowtime);
-}
-
-#endif //TARGET_ANDROID
diff --git a/xbmc/video/videosync/VideoSyncAndroid.h b/xbmc/video/videosync/VideoSyncAndroid.h
deleted file mode 100644
index 93e479f..0000000
--- a/xbmc/video/videosync/VideoSyncAndroid.h
+++ /dev/null
@@ -1,48 +0,0 @@
-#pragma once
-/*
- *      Copyright (C) 2015 Team Kodi
- *      http://kodi.tv
- *
- *  This Program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  This Program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with XBMC; see the file COPYING.  If not, see
- *  <http://www.gnu.org/licenses/>.
- *
- */
-
-#if defined(TARGET_ANDROID)
-#include "VideoSync.h"
-#include "guilib/DispResource.h"
-
-class CVideoSyncAndroid : public CVideoSync, IDispResource
-{
-public:
-  CVideoSyncAndroid() : m_LastVBlankTime(0), m_abort(false){}
-  
-  // CVideoSync interface
-  virtual bool Setup(PUPDATECLOCK func);
-  virtual void Run(volatile bool& stop);
-  virtual void Cleanup();
-  virtual float GetFps();
-  
-  // IDispResource interface
-  virtual void OnResetDevice();
-
-  // Choreographer callback
-  void FrameCallback(int64_t frameTimeNanos);
-  
-private:
-  int64_t m_LastVBlankTime;  //timestamp of the last vblank, used for calculating how many vblanks happened
-  volatile bool m_abort;
-};
-
-#endif// TARGET_ANDROID
diff --git a/xbmc/video/videosync/VideoSyncGLX.cpp b/xbmc/video/videosync/VideoSyncGLX.cpp
index b1279b4..eb25791 100644
--- a/xbmc/video/videosync/VideoSyncGLX.cpp
+++ b/xbmc/video/videosync/VideoSyncGLX.cpp
@@ -32,10 +32,6 @@
 #include "utils/TimeUtils.h"
 #include <string>
 
-#ifdef TARGET_POSIX
-#include "linux/XTimeUtils.h"
-#endif
-
 Display* CVideoSyncGLX::m_Dpy = NULL;
 
 void CVideoSyncGLX::OnLostDisplay()
diff --git a/xbmc/video/videosync/VideoSyncIos.cpp b/xbmc/video/videosync/VideoSyncIos.cpp
index cd57124..fa77dd5 100644
--- a/xbmc/video/videosync/VideoSyncIos.cpp
+++ b/xbmc/video/videosync/VideoSyncIos.cpp
@@ -52,7 +52,7 @@ void CVideoSyncIos::Run(volatile bool& stop)
   //because cocoa has a vblank callback, we just keep sleeping until we're asked to stop the thread
   while(!stop && !m_abort)
   {
-    usleep(100000);
+    Sleep(100);
   }
 }
 
diff --git a/xbmc/video/videosync/VideoSyncOsx.cpp b/xbmc/video/videosync/VideoSyncOsx.cpp
index 678655a..69047d3 100644
--- a/xbmc/video/videosync/VideoSyncOsx.cpp
+++ b/xbmc/video/videosync/VideoSyncOsx.cpp
@@ -31,7 +31,6 @@
 #include <QuartzCore/CVDisplayLink.h>
 #include <CoreVideo/CVHostTime.h>
 #include "platform/darwin/osx/CocoaInterface.h"
-#include <unistd.h>
 
 bool CVideoSyncOsx::Setup(PUPDATECLOCK func)
 {
@@ -56,14 +55,14 @@ void CVideoSyncOsx::Run(volatile bool& stop)
   //because cocoa has a vblank callback, we just keep sleeping until we're asked to stop the thread
   while(!stop && !m_displayLost && !m_displayReset)
   {
-    usleep(100000);
+    Sleep(100);
   }
 
   m_lostEvent.Set();
 
   while(!stop && m_displayLost && !m_displayReset)
   {
-    usleep(10000);
+    Sleep(10);
   }
 
   DeinitDisplayLink();
diff --git a/xbmc/video/windows/GUIWindowVideoBase.cpp b/xbmc/video/windows/GUIWindowVideoBase.cpp
index e09cf65..8855af8 100644
--- a/xbmc/video/windows/GUIWindowVideoBase.cpp
+++ b/xbmc/video/windows/GUIWindowVideoBase.cpp
@@ -202,13 +202,18 @@ bool CGUIWindowVideoBase::OnMessage(CGUIMessage& message)
   return CGUIMediaWindow::OnMessage(message);
 }
 
-void CGUIWindowVideoBase::OnItemInfo(const CFileItem& fileItem, ADDON::ScraperPtr& scraper)
+void CGUIWindowVideoBase::OnItemInfo(CFileItem* pItem, ADDON::ScraperPtr& scraper)
 {
-  if (fileItem.IsParentFolder() || fileItem.m_bIsShareOrDrive || fileItem.IsPath("add") ||
-     (fileItem.IsPlayList() && !URIUtils::HasExtension(fileItem.GetPath(), ".strm")))
+  if (!pItem)
     return;
 
-  CFileItem item(fileItem);
+  if (pItem->IsParentFolder() || pItem->m_bIsShareOrDrive || pItem->IsPath("add") ||
+     (pItem->IsPlayList() && !URIUtils::HasExtension(pItem->GetPath(), ".strm")))
+    return;
+
+  // ShowIMDB can kill the item as this window can be closed while we do it,
+  // so take a copy of the item now
+  CFileItem item(*pItem);
   bool fromDB = false;
   if ((item.IsVideoDb() && item.HasVideoInfoTag()) ||
       (item.HasVideoInfoTag() && item.GetVideoInfoTag()->m_iDbId != -1))
@@ -255,8 +260,8 @@ void CGUIWindowVideoBase::OnItemInfo(const CFileItem& fileItem, ADDON::ScraperPt
   }
 
   // we need to also request any thumbs be applied to the folder item
-  if (fileItem.m_bIsFolder)
-    item.SetProperty("set_folder_thumb", fileItem.GetPath());
+  if (pItem->m_bIsFolder)
+    item.SetProperty("set_folder_thumb", pItem->GetPath());
 
   bool modified = ShowIMDB(CFileItemPtr(new CFileItem(item)), scraper, fromDB);
   if (modified &&
@@ -733,7 +738,7 @@ bool CGUIWindowVideoBase::OnItemInfo(int iItem)
       return true;
   }
 
-  OnItemInfo(*item, scraper);
+  OnItemInfo(item.get(), scraper);
 
   // Return whether or not we have information to display.
   // Note: This will cause the default select action to start
@@ -1045,7 +1050,7 @@ bool CGUIWindowVideoBase::OnContextButton(int itemNumber, CONTEXT_BUTTON button)
         OnScan(strPath, true);
       }
       else
-        OnItemInfo(*item, info);
+        OnItemInfo(item.get(),info);
 
       return true;
     }
diff --git a/xbmc/video/windows/GUIWindowVideoBase.h b/xbmc/video/windows/GUIWindowVideoBase.h
index 1d1408b..ce9b5ae 100644
--- a/xbmc/video/windows/GUIWindowVideoBase.h
+++ b/xbmc/video/windows/GUIWindowVideoBase.h
@@ -49,7 +49,7 @@ public:
   static bool HasResumeItemOffset(const CFileItem *item);
 
   void AddToDatabase(int iItem);
-  virtual void OnItemInfo(const CFileItem& fileItem, ADDON::ScraperPtr& scraper);
+  virtual void OnItemInfo(CFileItem* pItem, ADDON::ScraperPtr& scraper);
 
 
   /*! \brief Show the resume menu for this item (if it has a resume bookmark)
diff --git a/xbmc/video/windows/GUIWindowVideoNav.cpp b/xbmc/video/windows/GUIWindowVideoNav.cpp
index 3ebc4b5..3de40d5 100644
--- a/xbmc/video/windows/GUIWindowVideoNav.cpp
+++ b/xbmc/video/windows/GUIWindowVideoNav.cpp
@@ -739,22 +739,22 @@ void CGUIWindowVideoNav::PlayItem(int iItem)
   CGUIWindowVideoBase::PlayItem(iItem);
 }
 
-void CGUIWindowVideoNav::OnItemInfo(const CFileItem& fileItem, ADDON::ScraperPtr& scraper)
+void CGUIWindowVideoNav::OnItemInfo(CFileItem* pItem, ADDON::ScraperPtr& scraper)
 {
   if (!scraper || scraper->Content() == CONTENT_NONE)
   {
     m_database.Open(); // since we can be called from the music library without being inited
-    if (fileItem.IsVideoDb())
-      scraper = m_database.GetScraperForPath(fileItem.GetVideoInfoTag()->m_strPath);
+    if (pItem->IsVideoDb())
+      scraper = m_database.GetScraperForPath(pItem->GetVideoInfoTag()->m_strPath);
     else
     {
       std::string strPath,strFile;
-      URIUtils::Split(fileItem.GetPath(),strPath,strFile);
+      URIUtils::Split(pItem->GetPath(),strPath,strFile);
       scraper = m_database.GetScraperForPath(strPath);
     }
     m_database.Close();
   }
-  CGUIWindowVideoBase::OnItemInfo(fileItem, scraper);
+  CGUIWindowVideoBase::OnItemInfo(pItem,scraper);
 }
 
 void CGUIWindowVideoNav::OnDeleteItem(CFileItemPtr pItem)
diff --git a/xbmc/video/windows/GUIWindowVideoNav.h b/xbmc/video/windows/GUIWindowVideoNav.h
index 722232a..1f59c26 100644
--- a/xbmc/video/windows/GUIWindowVideoNav.h
+++ b/xbmc/video/windows/GUIWindowVideoNav.h
@@ -49,7 +49,7 @@ public:
   virtual bool OnAction(const CAction &action) override;
   virtual bool OnMessage(CGUIMessage& message) override;
 
-  virtual void OnItemInfo(const CFileItem& fileItem, ADDON::ScraperPtr &info) override;
+  virtual void OnItemInfo(CFileItem* pItem, ADDON::ScraperPtr &info) override;
 
   /*! \brief Load video information from the database for these items (public static version)
    Useful for grabbing information for file listings, from watched status to full metadata
diff --git a/xbmc/view/GUIViewState.cpp b/xbmc/view/GUIViewState.cpp
index e88dc52..cc5f91f 100644
--- a/xbmc/view/GUIViewState.cpp
+++ b/xbmc/view/GUIViewState.cpp
@@ -27,6 +27,7 @@
 #include "pictures/GUIViewStatePictures.h"
 #include "profiles/ProfilesManager.h"
 #include "programs/GUIViewStatePrograms.h"
+#include "games/windows/GUIViewStateWindowGames.h"
 #include "PlayListPlayer.h"
 #include "utils/URIUtils.h"
 #include "URL.h"
@@ -174,7 +175,10 @@ CGUIViewState* CGUIViewState::GetViewState(int windowId, const CFileItemList& it
 
   if (windowId == WINDOW_PROGRAMS)
     return new CGUIViewStateWindowPrograms(items);
-  
+
+  if (windowId == WINDOW_GAMES)
+    return new CGUIViewStateWindowGames(items);
+
   if (windowId == WINDOW_ADDON_BROWSER)
     return new CGUIViewStateAddonBrowser(items);
 
diff --git a/xbmc/view/ViewStateSettings.cpp b/xbmc/view/ViewStateSettings.cpp
index a608a82..8d9d31f 100644
--- a/xbmc/view/ViewStateSettings.cpp
+++ b/xbmc/view/ViewStateSettings.cpp
@@ -62,6 +62,7 @@ CViewStateSettings::CViewStateSettings()
   AddViewState("pictures", DEFAULT_VIEW_AUTO);
   AddViewState("videofiles", DEFAULT_VIEW_AUTO);
   AddViewState("musicfiles", DEFAULT_VIEW_AUTO);
+  AddViewState("games", DEFAULT_VIEW_AUTO);
 
   Clear();
 }
diff --git a/xbmc/win32/Win32DelayedDllLoad.cpp b/xbmc/win32/Win32DelayedDllLoad.cpp
index 9f34a11..9d39218 100644
--- a/xbmc/win32/Win32DelayedDllLoad.cpp
+++ b/xbmc/win32/Win32DelayedDllLoad.cpp
@@ -27,13 +27,13 @@ static const std::string dlls[] = {
   "sqlite3.dll",
   "dnssd.dll",
   "libxslt.dll",
-  "avcodec-57.dll",
-  "avfilter-6.dll",
-  "avformat-57.dll",
-  "avutil-55.dll",
-  "postproc-54.dll",
-  "swresample-2.dll",
-  "swscale-4.dll"
+  "avcodec-56.dll",
+  "avfilter-5.dll",
+  "avformat-56.dll",
+  "avutil-54.dll",
+  "postproc-53.dll",
+  "swresample-1.dll",
+  "swscale-3.dll"
 };
 
 FARPROC WINAPI delayHookNotifyFunc (unsigned dliNotify, PDelayLoadInfo pdli)
diff --git a/xbmc/windowing/X11/XRandR.cpp b/xbmc/windowing/X11/XRandR.cpp
index e0595f3..71b2800 100644
--- a/xbmc/windowing/X11/XRandR.cpp
+++ b/xbmc/windowing/X11/XRandR.cpp
@@ -37,10 +37,6 @@
 #include <sys/wait.h>
 #endif
 
-#ifdef TARGET_POSIX
-#include "linux/XTimeUtils.h"
-#endif
-
 CXRandR::CXRandR(bool query)
 {
   m_bInit = false;
diff --git a/xbmc/windowing/egl/EGLNativeTypeIMX.cpp b/xbmc/windowing/egl/EGLNativeTypeIMX.cpp
index c7567a9..dd8bfae 100644
--- a/xbmc/windowing/egl/EGLNativeTypeIMX.cpp
+++ b/xbmc/windowing/egl/EGLNativeTypeIMX.cpp
@@ -303,7 +303,7 @@ bool CEGLNativeTypeIMX::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutio
   for (size_t i = 0; i < probe_str.size(); i++)
   {
     if(!StringUtils::StartsWith(probe_str[i], "S:") && !StringUtils::StartsWith(probe_str[i], "U:") &&
-       !StringUtils::StartsWith(probe_str[i], "V:") && !StringUtils::StartsWith(probe_str[i], "D:"))
+       !StringUtils::StartsWith(probe_str[i], "V:"))
       continue;
 
     if(ModeToResolution(probe_str[i], &res))
diff --git a/xbmc/windows/GUIMediaWindow.cpp b/xbmc/windows/GUIMediaWindow.cpp
index 521ece7..be91cfa 100644
--- a/xbmc/windows/GUIMediaWindow.cpp
+++ b/xbmc/windows/GUIMediaWindow.cpp
@@ -794,6 +794,8 @@ bool CGUIMediaWindow::Update(const std::string &strDirectory, bool updateFilterP
     showLabel = 997;
   else if (m_vecItems->IsPath("sources://files/"))
     showLabel = 1026;
+  if (m_vecItems->IsPath("sources://games/"))
+    showLabel = 27017; // Add Games...
   if (showLabel && (m_vecItems->Size() == 0 || !m_guiState->DisableAddSourceButtons())) // add 'add source button'
   {
     std::string strLabel = g_localizeStrings.Get(showLabel);
diff --git a/xbmc/windows/GUIWindowDebugInfo.cpp b/xbmc/windows/GUIWindowDebugInfo.cpp
index ff3299f..43f8a93 100644
--- a/xbmc/windows/GUIWindowDebugInfo.cpp
+++ b/xbmc/windows/GUIWindowDebugInfo.cpp
@@ -35,10 +35,6 @@
 #include "utils/Variant.h"
 #include "utils/StringUtils.h"
 
-#ifdef TARGET_POSIX
-#include "linux/XMemUtils.h"
-#endif
-
 CGUIWindowDebugInfo::CGUIWindowDebugInfo(void)
   : CGUIDialog(WINDOW_DEBUG_INFO, "", DialogModalityType::MODELESS)
 {
diff --git a/xbmc/windows/GUIWindowFileManager.cpp b/xbmc/windows/GUIWindowFileManager.cpp
index 602c254..360ae3b 100644
--- a/xbmc/windows/GUIWindowFileManager.cpp
+++ b/xbmc/windows/GUIWindowFileManager.cpp
@@ -56,9 +56,6 @@
 #include "utils/Variant.h"
 #include "Autorun.h"
 #include "URL.h"
-#ifdef TARGET_POSIX
-#include "linux/XFileUtils.h"
-#endif
 
 using namespace XFILE;
 using namespace PLAYLIST;
@@ -73,6 +70,7 @@ using namespace KODI::MESSAGING;
 #define CONTROL_BTNMOVE                 7
 #define CONTROL_BTNNEWFOLDER            8
 #define CONTROL_BTNCALCSIZE             9
+#define CONTROL_BTNGOTOROOT             10
 #define CONTROL_BTNSWITCHMEDIA          11
 #define CONTROL_BTNCANCELJOB            12
 
@@ -1011,6 +1009,7 @@ void CGUIWindowFileManager::OnPopupMenu(int list, int item, bool bContextDriven
     choices.Add(CONTROL_BTNNEWFOLDER, 20309);
   if (item >= 0 && pItem->m_bIsFolder && !pItem->IsParentFolder())
     choices.Add(CONTROL_BTNCALCSIZE, 13393);
+  choices.Add(CONTROL_BTNGOTOROOT, 20128);
   choices.Add(CONTROL_BTNSWITCHMEDIA, 523);
   if (CJobManager::GetInstance().IsProcessing("filemanager"))
     choices.Add(CONTROL_BTNCANCELJOB, 167);
@@ -1076,6 +1075,11 @@ void CGUIWindowFileManager::OnPopupMenu(int list, int item, bool bContextDriven
     if (progress)
       progress->Close();
   }
+  if (btnid == CONTROL_BTNGOTOROOT)
+  {
+    Update(list,"");
+    return;
+  }
   if (btnid == CONTROL_BTNSWITCHMEDIA)
   {
     CGUIDialogContextMenu::SwitchMedia("files", m_vecItems[list]->GetPath());
diff --git a/xbmc/windows/GUIWindowLoginScreen.cpp b/xbmc/windows/GUIWindowLoginScreen.cpp
index ca2edb7..43a07dc 100644
--- a/xbmc/windows/GUIWindowLoginScreen.cpp
+++ b/xbmc/windows/GUIWindowLoginScreen.cpp
@@ -278,7 +278,7 @@ void CGUIWindowLoginScreen::LoadProfile(unsigned int profile)
   g_application.StopPVRManager();
 
   // stop audio DSP services with a blocking message
-  CServiceBroker::GetADSP().Deactivate();
+  CApplicationMessenger::GetInstance().SendMsg(TMSG_SETAUDIODSPSTATE, ACTIVE_AE_DSP_STATE_OFF);
 
   if (profile != 0 || !CProfilesManager::GetInstance().IsMasterProfile())
   {
@@ -333,6 +333,9 @@ void CGUIWindowLoginScreen::LoadProfile(unsigned int profile)
   g_application.UpdateLibraries();
   CStereoscopicsManager::GetInstance().Initialize();
 
+  // start audio DSP related services with a blocking message
+  CApplicationMessenger::GetInstance().SendMsg(TMSG_SETAUDIODSPSTATE, ACTIVE_AE_DSP_STATE_ON, ACTIVE_AE_DSP_SYNC_ACTIVATE);
+
   // if the user interfaces has been fully initialized let everyone know
   if (uiInitializationFinished)
   {
